{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to CS-Map\n\n\nThis is a work in progress, original code and site should be taken from \nhere\n\n\nCS-Map is part of a bigger OSGeo project called MetaCRS that gathers several open source projections, and coordinate system related technologies.\n\n\nGithub\n\n\nAll code is maintained as a github svn clone of the original repository.\n\n\nThe documentation for installation and usage is maintained here.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-cs-map", 
            "text": "This is a work in progress, original code and site should be taken from  here  CS-Map is part of a bigger OSGeo project called MetaCRS that gathers several open source projections, and coordinate system related technologies.", 
            "title": "Welcome to CS-Map"
        }, 
        {
            "location": "/#github", 
            "text": "All code is maintained as a github svn clone of the original repository.  The documentation for installation and usage is maintained here.", 
            "title": "Github"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\nBuilding CS-MAP on Windows and Linux\n\n\nThe CS-MAP distribution will produce a series of five directories:\n\n\n\n\nInclude: Contains all header files referenced the source code in the Source directory.\n\n\nSource: Contains all the source code for the CS-MAP library itself.\n\n\nDictionaries: Contains the coordinate system dictionaries in source form, and the source code for a compiler which will convert the dictionary source to the operational binary form.\n\n\nTest: Contains the source code for a console type test program and the test data which it uses.\n\n\nData: Contains a series of data files used to construct name mapping files.\n\n\n\n\nBuilding the entire product is a series of five steps:\n\n\n\n\nBuild the CS-MAP library.\n\n\nBuild the dictionary compiler.\n\n\nRun the dictionary compiler.\n\n\nBuild the console test program.\n\n\nExecute the console test program.\n\n\n\n\nAfter installation, and before building, it will be best to obtain a copy of the Canadian National\nTransformation file (NTV2_0.gsb) and copy it to the Dictionaries/Canada directory.  This data file may\nnot be distributed by OSGeo.  Geomatics Canada reserves the right to distribute this file and maintain a\nlist of those using it.  Therefore, since we do not distribute the file as part of this open source\ndistribution, we recommend strongly that you simply obtain a copy, even if for testing purposes only.\nChances are very good you already have a copy of this file on your system already.  If not, you can\nobtain one (no fee) at: \nhttp://www.geod.nrcan.gc.ca\n\n\nThe TEST.DAT data file in the Test directory contains several hundred test points which are directly\nrelated to the above mentioned grid shift data file.  To prevent confusion and unnecessary technical\nsupport, tests related to the Canadian National Transformation data file are commented out in the\ndistribution.  After obtaining a copy of the above mentioned data file, these test should be\n\"uncommented\" back in, so that the test program will test this feature.\n\n\nOK. Now for building on your system:\n\n\nWindows\n\n\n\n\n\n\nBuild the CS-MAP Library:\n\n\n\n\nMake the \nSource\n directory your current working directory.\n\n\nUse the MSVC set variables script to set the environmental variables correctly.\n\n\nUse the \nnmake\n command and supply it with the \nLibrary.nmk\n make file.  E.g. \nnmake /fLibrary.nmk\n\n\n\n\n\n\n\n\nBuild the Dictionary Compiler (\nCS_comp\n)\n\n\n\n\nMake the 'Dictionaries' directory your current working directory.\n\n\nUse the MSVC set variables script to set the environmental variables correctly.\n\n\nUse the \nnmake\n command and supply it with the \nCompiler.nmk\n make file.  E.g. \nnmake /fCompiler.nmk\n\n\n\n\n\n\n\n\nRun the Dictionary Compiler\n\n\n\n\nMake the \nDictionaries\n directory your current working directory.\n\n\nExecute the \nCS_comp\n program.  E.g. \nCS_Comp . .\n\n\nNote that the first argument to this command is the folder containing the dictionary source, the second argument is the directory to which the binary dictionary files are to be written.\n\n\n\n\n\n\n\n\nBuild the Console Test program (\nCS_Test\n)\n\n\n\n\nMake the \nTest\n directory your current working directory.\n\n\nUse the MSVC set variables script to set the environmental variables correctly.\n\n\nUse the \nnmake\n command and supply it with the \nTest.nmk\n make file.  E.g. \nnmake /fTest.nmk\n\n\n\n\n\n\nExecute the console test program\n\n\nMake the \nTest\n directory your current working directory.\n\n\nExecute the \nCS_Test\n program.  E.g. \nCS_Test /d..\\Dictionaries\n\n\nNote that the /d argument is the directory which the test program is to look to for the dictionaries and related data files.\n\n\n\n\n\n\n\n\nLinux\n\n\n\n\nBuild the CS-MAP Library:\n\n\nMake the \nSource\n directory your current working directory.\n\n\nUse the \nmake\n command and supply it with the \nLibrary.mak\n make file.  E.g. \nmake -fLibrary.mak\n\n\n\n\n\n\nBuild the Dictionary Compiler (\nCS_Comp\n)\n\n\nMake the \nDictionaries\n directory your current working directory.\n\n\nUse the \nmake\n command and supply it with the \nCompiler.mak\n make file.  E.g. \nmake -f Compiler.mak\n\n\n\n\n\n\nRun the Dictionary Compiler\n\n\nMake the \nDictionaries\n directory your current working directory.\n\n\nExecute the \nCS_Comp\n program.  E.g. \n./CS_Comp . .\n\n\nNote that the first argument is the directory containing the dictionary source, the second argument is the directory to which the binary dictionary files are written.\n\n\n\n\n\n\nBuild the Console Test program (\nCS_Test\n)\n\n\nMake the \nTest\n directory your current working directory.\n\n\nUse the \nmake\n command and supply it with the \nTest.mak\n make file.  E.g. \nmake -fTest.mak\n\n\n\n\n\n\nExecute the console test program\n\n\nMake the \nTest\n directory your current working directory.\n\n\nExecute the \nCS_Test\n program.  E.g. \n./CS_Test -d../Dictionaries\n\n\nNote that the /d argument is the directory which the test program is to look to for the dictionaries and related data files.\n\n\n\n\n\n\n\n\nMS VC++ 2005 (Version 8):\n\n\nThe CS-MAP Open Source distribution will deposit in the primary directory a Microsoft Visual C++\nVersion 8.0 (VC2005) solution file.  This file references project files in the Source, Dictionaries, and\nTest directories.  This solution file and its related project files can be used to manufacture the library,\ndictionary compiler, and the test module.  No provisions have been made for executing the dictionary\ncompiler or the test module.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "Building CS-MAP on Windows and Linux  The CS-MAP distribution will produce a series of five directories:   Include: Contains all header files referenced the source code in the Source directory.  Source: Contains all the source code for the CS-MAP library itself.  Dictionaries: Contains the coordinate system dictionaries in source form, and the source code for a compiler which will convert the dictionary source to the operational binary form.  Test: Contains the source code for a console type test program and the test data which it uses.  Data: Contains a series of data files used to construct name mapping files.   Building the entire product is a series of five steps:   Build the CS-MAP library.  Build the dictionary compiler.  Run the dictionary compiler.  Build the console test program.  Execute the console test program.   After installation, and before building, it will be best to obtain a copy of the Canadian National\nTransformation file (NTV2_0.gsb) and copy it to the Dictionaries/Canada directory.  This data file may\nnot be distributed by OSGeo.  Geomatics Canada reserves the right to distribute this file and maintain a\nlist of those using it.  Therefore, since we do not distribute the file as part of this open source\ndistribution, we recommend strongly that you simply obtain a copy, even if for testing purposes only.\nChances are very good you already have a copy of this file on your system already.  If not, you can\nobtain one (no fee) at:  http://www.geod.nrcan.gc.ca  The TEST.DAT data file in the Test directory contains several hundred test points which are directly\nrelated to the above mentioned grid shift data file.  To prevent confusion and unnecessary technical\nsupport, tests related to the Canadian National Transformation data file are commented out in the\ndistribution.  After obtaining a copy of the above mentioned data file, these test should be\n\"uncommented\" back in, so that the test program will test this feature.  OK. Now for building on your system:", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#windows", 
            "text": "Build the CS-MAP Library:   Make the  Source  directory your current working directory.  Use the MSVC set variables script to set the environmental variables correctly.  Use the  nmake  command and supply it with the  Library.nmk  make file.  E.g.  nmake /fLibrary.nmk     Build the Dictionary Compiler ( CS_comp )   Make the 'Dictionaries' directory your current working directory.  Use the MSVC set variables script to set the environmental variables correctly.  Use the  nmake  command and supply it with the  Compiler.nmk  make file.  E.g.  nmake /fCompiler.nmk     Run the Dictionary Compiler   Make the  Dictionaries  directory your current working directory.  Execute the  CS_comp  program.  E.g.  CS_Comp . .  Note that the first argument to this command is the folder containing the dictionary source, the second argument is the directory to which the binary dictionary files are to be written.     Build the Console Test program ( CS_Test )   Make the  Test  directory your current working directory.  Use the MSVC set variables script to set the environmental variables correctly.  Use the  nmake  command and supply it with the  Test.nmk  make file.  E.g.  nmake /fTest.nmk    Execute the console test program  Make the  Test  directory your current working directory.  Execute the  CS_Test  program.  E.g.  CS_Test /d..\\Dictionaries  Note that the /d argument is the directory which the test program is to look to for the dictionaries and related data files.", 
            "title": "Windows"
        }, 
        {
            "location": "/installation/#linux", 
            "text": "Build the CS-MAP Library:  Make the  Source  directory your current working directory.  Use the  make  command and supply it with the  Library.mak  make file.  E.g.  make -fLibrary.mak    Build the Dictionary Compiler ( CS_Comp )  Make the  Dictionaries  directory your current working directory.  Use the  make  command and supply it with the  Compiler.mak  make file.  E.g.  make -f Compiler.mak    Run the Dictionary Compiler  Make the  Dictionaries  directory your current working directory.  Execute the  CS_Comp  program.  E.g.  ./CS_Comp . .  Note that the first argument is the directory containing the dictionary source, the second argument is the directory to which the binary dictionary files are written.    Build the Console Test program ( CS_Test )  Make the  Test  directory your current working directory.  Use the  make  command and supply it with the  Test.mak  make file.  E.g.  make -fTest.mak    Execute the console test program  Make the  Test  directory your current working directory.  Execute the  CS_Test  program.  E.g.  ./CS_Test -d../Dictionaries  Note that the /d argument is the directory which the test program is to look to for the dictionaries and related data files.", 
            "title": "Linux"
        }, 
        {
            "location": "/installation/#ms-vc-2005-version-8", 
            "text": "The CS-MAP Open Source distribution will deposit in the primary directory a Microsoft Visual C++\nVersion 8.0 (VC2005) solution file.  This file references project files in the Source, Dictionaries, and\nTest directories.  This solution file and its related project files can be used to manufacture the library,\ndictionary compiler, and the test module.  No provisions have been made for executing the dictionary\ncompiler or the test module.", 
            "title": "MS VC++ 2005 (Version 8):"
        }, 
        {
            "location": "/userguide/releasenotes/", 
            "text": "Distribution/Release Notes\n\n\nDue to distribution permission issues, it was determined that the polynomial coefficients for the System 34 coordinate conversions could not be open sourced.  Thus, to properly incorporate Syatem 34 capabilities into your application, you will need to obtain a copy of these coefficients for yourself. Refer to the source module named CSsys34KMS.c for details.\n\n\nCSV File Support\n\n\nImplemented as a C++ object, there now exists rather substantial support for reading and writing data\nfile in the CSV (comma separated value) format.\n\n\nEPSG Support\n\n\nStill a work inprogress, there now exists substantial support for accessing data provided by the EPSG\nParameter Dataset.  As this dataset is traditionally distributed in Microsoft Access format, this facility\nrelies on the conversion of all EPSG data tables to .CSV format, and uses the new CSV FIle SUpport\nobject to access them.\n\n\nWKT Flavor Support\n\n\nUsing the new Name Mapper facility, CS-MAP's ability to handle various flavors of WKT has been\nimporved.  There is lots yet to be done, but a non-trivial improvement in the accuracy and number of\nflavors supported.\n\n\nSo, there remains much to do to bring this document up to the standard desired by the CS-MAP\ncontributor team.  For now, it's important to provide potential users with the basic information\nnecessary to get started using CS-MAP.\n\n\nThe Distribution\n\n\nDetailed instructions on how to obtain the distribution are available at\n\nhttp://trac.osgeo.org/csmap/wiki/HowToGetTheSourceCode\n\n\nThe distribution includes many somewhat voluminous grid data files known to OSGeo as being in the\npublic domain.  There are several such grid data files which are not in the public domain and which\nmust be obtained from the source on an individual user basis.  Simple registration is all that is required\nin many cases, license fees are rarely required.  Mostly, the issuing authority just wants to keep track of\nwho is using the data in order to adhere to ISO quality control standards.\n\n\nThe Canadian National Transformation data file is, perhaps, the most widely used example of a grid\ndata file which OSGeo is not permitted to distribute.  You and your clients will need to obtain this file\nfrom the Canadian government. A license fee is no longer required, but Geomatics Canada still needs\nto know who is using the data file.  Contact: \nwww.geod.nrcan.gc.ca\n\n\nSince the distribution cannot include a copy of the Canadian National Transformation file, the test\ncases for this transformation are commented out in the provided TEST.DAT file.  After obtaining the\nCanadian National Transformation file, you will probably want to uncomment these test cases from the\ntest file.\n\n\nTypically, a README.txt file is placed in the folder in which an undistributable grid data files would\nnormally reside.  THis text file will usually provide information as to how to obtain a copy of the data\nfile.  When a CS-MAP error message which indicates that a file is missing is encountered, check to see\nif there is not a README.txt file in the folder in which CS-MAP was looking for the file and examine\nits contents.\n\n\nSource Layout\n\n\nInclude Directory\n\n\nYou don't need to be a genius to figure out that all header files are installed into this sub-directory.\nWhat might surprise you is that there is only one real header file: \ncs_map.h\n.  While this file is quite\nlarge, the precompiled header feature of most modern compilers make this approach most convenient.\n\n\nAlso, you never have to guess in which header file a specific item is defined in. They're all defined in\n\ncs_map.h\n.  Neither do you have to wonder which files must be included into your application; \ncs_map.h\n\nis the one.  There are other include files, but are those required by the rather strange environment used\nfor MFC development.\n\n\nThe \ncs_map.h\n header file will specifically include two files.  The files, and exactly where they are\nincluded, are described below.  These provide a means by which users can incorporate their own\nfeatures without having to modify \ncs_map.h\n after each new release.\n\n\n\n\ncs_clientBeg.h\n --  The inclusion of this file occurs immediately after the check for a previous include\nof \ncs_map.h\n, but before the \ncs_map.h\n file does anything else.  An excellent place to place defines\nwhich control the environment of the compilation.\n\n\ncs_clientEnd.h\n -- The inclusion of this file occurs immediately before the \n#endif\n which terminates\nthe multiple inclusion protection.  That is, it is included after everything else in \ncs_map.h\n.\n\n\n\n\nLibrary Source Code\n\n\nThe directory named Source will contain all source code to the library proper.  The source code\ncomponents of CS-MAP are normally compiled and the resulting objects used to construct an object\nmodule library.  Source code to dictionary compilers and test programs are provided elsewhere.  Make\nfiles for building the library are provided in this folder.\n\n\n\n\nLibrary.mak\n can used used to build the object library in the Linux environment.\n\n\nLibrary.nmk\n can use used int the Microsoft WIndows environment using the nmake facility.\n\n\n\n\nEach of the make files includes a list of all the modules that belong in the library.  This list represents\nmost of the drudgery of creating a make file.  Adjust the actual rules as necessary for your\nplatform/compiler.  Notice that leaving the manifest constant \n__MFC__\n undefined will cause all MFC\nrelated code to be skipped during the compilation process.  Obviously, if compiling in an environment\nother than Windows 32/64, be sure to leave the \n__MFC__\n constant undefined.\n\n\nDictionary Source Code and Data\n\n\nThe directory named Dictionaries will contain the source code to the dictionary compiler, and the data\nfiles which this compiler compiles to produce the binary form of the Category Dictionary, the\nCoordinate System Dictionary, the Datum Dictionary, the Ellipsoid Dictionary, and the Multiple\nRegression Transformation data files.  Be sure to compile these dictionaries with the \n/t\n option if you\nintend to run the CS-MAP test program.  \n\n\nMake files for building the compiler are provided in this folder.\n\n\n\n\nCompiler.mak\n can used used to build the compiler in the Linux environment.\n\n\nCompiler.nmk\n can use used to build the compiler in the Microsoft Windows environment using the nmake facility.\n\n\n\n\nThe distribution also uses this directory to convey sample Geodetic Data Catalogs which you will\ndefinitely want to inspect and perhaps modify.  Geodetic data files which OSGeo believes to be in the\npublic domain are deposited in sub-folders of this folder in a specific hierarchy.  This hierarchy is\nconsistent with the provided Geodetic Data Catalog (.gdc) files.  There is no specific requirement for\nthe location of the geodetic data files other than their location must be consistent with the\nspecifications int he Geodetic Data Catalog files.\n\n\nAlso please note that the OSTN97.TXT and OSTN02.TXT data files must also reside in the primary data\ndirectory.  Again, by design, there is only one file for each of these transformations, and the\nimplementation of a Geodetic Data Catalog file was skipped.  Also, due to the rather strange nature of\nthese files, most of the features of a Geodetic Data Catalog file do not apply anyway.\n\n\nTest Source Code and Data\n\n\nThe directory named Test will contain the source code to the CS-MAP test program and the supporting\ndata file, TEST.DAT. Compilation and linking of this program will obviously require the inclusion of the\nheader file and library.  Make files for building the test program are provided in this folder.\n\n\n\n\nTest.mak can used used to build the test program in the Linux environment.\n\n\nTest.nmk can use used int the Microsoft WIndows environment using the nmake facility.\n\n\n\n\nIn order to execute the entire test sequence, you will need to have compiled the dictionaries with the \n/t\n\noption.  This causes the retention of the test coordinate systems (not normally distributed with an\napplication) in the dictionary files.  The test program will also expect to have access to the NADCON\nand HPGN data files provided in the sub-directories of the Dictionaries directory.  When executing the\ntest program, use the \n/d\n option to indicate the location of the directory in which the dictionaries,\nNADCON, and HPGN data files reside; e.g. /d..\\Dictionaries.\n\n\nThis program performs a fairly substantial test of most all features and capabilities of CS-MAP.  This\nprogram should be used each time CS-MAP is used in a new configuration or compiled with a different\ncompiler.\n\n\nNote that a large number of the tests encoded in the TEST.DAT file are commented out as they rely on\nthe existence of specific geodetic data files which OSGeo cannot distribute.  For example, since\nOSGeo cannot distribute the Canadian National Transformation, all test dependent upon that data file\nare commented out.  Upon obtaining geodetic data files which Mentor Software cannot distribute, you\nshould consider un-commenting the tests related to such files.\n\n\nDocumentation Directory\n\n\nThe directory named Documentation is where you will find a copy of this documentation.  Depending\nupon the format, it may consist of a single file, or a directory containing multiple files.  A printable\nversion may also be present.\n\n\nAdditionally, this directory will contain the source code to the help file which is provided for use with\nthe MFC based components of CS-MAP.  The source code files include an .rtf file, a contents file (.cnt),\nand several screen shots in .bmp format.  Again, a make file compatible with Visual C++ Version 6 (or\nlater) nmake is provided; it is named \nhelp.nmk\n.  (As the help file is not generally usable in the Linux\nenvironment, no Linux compatible make file is provided.)  Note, that the CS-MAP MFC based\nfunctions expect to find the help file in the same directory as the mapping data files.  Of course, a\nfunction exists which enables application programmers to override this default location\n(CS_setHelpPath).  If for any reason, the MFC based functions cannot locate the help file, the help\nbutton on all dialogs will be grayed out.\n\n\nPlease note that the help file is designed for distribution with your application.  It does not mention\nOSGeo, CS-MAP, or the original developers of CS-MAP.  It uses a rather generic term \"coordinate\nconversion system\" to refer to that which it is describing.\n\n\nData Directory\n\n\nSeveral data files used in the construction of CS-MAP's Name Mapper facility are included in the Data\ndirectory.  It is envisioned that these files will be replaced by a more convenient and controllable\nmeans in the near future.", 
            "title": "Release Notes"
        }, 
        {
            "location": "/userguide/releasenotes/#distributionrelease-notes", 
            "text": "Due to distribution permission issues, it was determined that the polynomial coefficients for the System 34 coordinate conversions could not be open sourced.  Thus, to properly incorporate Syatem 34 capabilities into your application, you will need to obtain a copy of these coefficients for yourself. Refer to the source module named CSsys34KMS.c for details.", 
            "title": "Distribution/Release Notes"
        }, 
        {
            "location": "/userguide/releasenotes/#csv-file-support", 
            "text": "Implemented as a C++ object, there now exists rather substantial support for reading and writing data\nfile in the CSV (comma separated value) format.", 
            "title": "CSV File Support"
        }, 
        {
            "location": "/userguide/releasenotes/#epsg-support", 
            "text": "Still a work inprogress, there now exists substantial support for accessing data provided by the EPSG\nParameter Dataset.  As this dataset is traditionally distributed in Microsoft Access format, this facility\nrelies on the conversion of all EPSG data tables to .CSV format, and uses the new CSV FIle SUpport\nobject to access them.", 
            "title": "EPSG Support"
        }, 
        {
            "location": "/userguide/releasenotes/#wkt-flavor-support", 
            "text": "Using the new Name Mapper facility, CS-MAP's ability to handle various flavors of WKT has been\nimporved.  There is lots yet to be done, but a non-trivial improvement in the accuracy and number of\nflavors supported.  So, there remains much to do to bring this document up to the standard desired by the CS-MAP\ncontributor team.  For now, it's important to provide potential users with the basic information\nnecessary to get started using CS-MAP.", 
            "title": "WKT Flavor Support"
        }, 
        {
            "location": "/userguide/releasenotes/#the-distribution", 
            "text": "Detailed instructions on how to obtain the distribution are available at http://trac.osgeo.org/csmap/wiki/HowToGetTheSourceCode  The distribution includes many somewhat voluminous grid data files known to OSGeo as being in the\npublic domain.  There are several such grid data files which are not in the public domain and which\nmust be obtained from the source on an individual user basis.  Simple registration is all that is required\nin many cases, license fees are rarely required.  Mostly, the issuing authority just wants to keep track of\nwho is using the data in order to adhere to ISO quality control standards.  The Canadian National Transformation data file is, perhaps, the most widely used example of a grid\ndata file which OSGeo is not permitted to distribute.  You and your clients will need to obtain this file\nfrom the Canadian government. A license fee is no longer required, but Geomatics Canada still needs\nto know who is using the data file.  Contact:  www.geod.nrcan.gc.ca  Since the distribution cannot include a copy of the Canadian National Transformation file, the test\ncases for this transformation are commented out in the provided TEST.DAT file.  After obtaining the\nCanadian National Transformation file, you will probably want to uncomment these test cases from the\ntest file.  Typically, a README.txt file is placed in the folder in which an undistributable grid data files would\nnormally reside.  THis text file will usually provide information as to how to obtain a copy of the data\nfile.  When a CS-MAP error message which indicates that a file is missing is encountered, check to see\nif there is not a README.txt file in the folder in which CS-MAP was looking for the file and examine\nits contents.", 
            "title": "The Distribution"
        }, 
        {
            "location": "/userguide/releasenotes/#source-layout", 
            "text": "", 
            "title": "Source Layout"
        }, 
        {
            "location": "/userguide/releasenotes/#include-directory", 
            "text": "You don't need to be a genius to figure out that all header files are installed into this sub-directory.\nWhat might surprise you is that there is only one real header file:  cs_map.h .  While this file is quite\nlarge, the precompiled header feature of most modern compilers make this approach most convenient.  Also, you never have to guess in which header file a specific item is defined in. They're all defined in cs_map.h .  Neither do you have to wonder which files must be included into your application;  cs_map.h \nis the one.  There are other include files, but are those required by the rather strange environment used\nfor MFC development.  The  cs_map.h  header file will specifically include two files.  The files, and exactly where they are\nincluded, are described below.  These provide a means by which users can incorporate their own\nfeatures without having to modify  cs_map.h  after each new release.   cs_clientBeg.h  --  The inclusion of this file occurs immediately after the check for a previous include\nof  cs_map.h , but before the  cs_map.h  file does anything else.  An excellent place to place defines\nwhich control the environment of the compilation.  cs_clientEnd.h  -- The inclusion of this file occurs immediately before the  #endif  which terminates\nthe multiple inclusion protection.  That is, it is included after everything else in  cs_map.h .", 
            "title": "Include Directory"
        }, 
        {
            "location": "/userguide/releasenotes/#library-source-code", 
            "text": "The directory named Source will contain all source code to the library proper.  The source code\ncomponents of CS-MAP are normally compiled and the resulting objects used to construct an object\nmodule library.  Source code to dictionary compilers and test programs are provided elsewhere.  Make\nfiles for building the library are provided in this folder.   Library.mak  can used used to build the object library in the Linux environment.  Library.nmk  can use used int the Microsoft WIndows environment using the nmake facility.   Each of the make files includes a list of all the modules that belong in the library.  This list represents\nmost of the drudgery of creating a make file.  Adjust the actual rules as necessary for your\nplatform/compiler.  Notice that leaving the manifest constant  __MFC__  undefined will cause all MFC\nrelated code to be skipped during the compilation process.  Obviously, if compiling in an environment\nother than Windows 32/64, be sure to leave the  __MFC__  constant undefined.", 
            "title": "Library Source Code"
        }, 
        {
            "location": "/userguide/releasenotes/#dictionary-source-code-and-data", 
            "text": "The directory named Dictionaries will contain the source code to the dictionary compiler, and the data\nfiles which this compiler compiles to produce the binary form of the Category Dictionary, the\nCoordinate System Dictionary, the Datum Dictionary, the Ellipsoid Dictionary, and the Multiple\nRegression Transformation data files.  Be sure to compile these dictionaries with the  /t  option if you\nintend to run the CS-MAP test program.    Make files for building the compiler are provided in this folder.   Compiler.mak  can used used to build the compiler in the Linux environment.  Compiler.nmk  can use used to build the compiler in the Microsoft Windows environment using the nmake facility.   The distribution also uses this directory to convey sample Geodetic Data Catalogs which you will\ndefinitely want to inspect and perhaps modify.  Geodetic data files which OSGeo believes to be in the\npublic domain are deposited in sub-folders of this folder in a specific hierarchy.  This hierarchy is\nconsistent with the provided Geodetic Data Catalog (.gdc) files.  There is no specific requirement for\nthe location of the geodetic data files other than their location must be consistent with the\nspecifications int he Geodetic Data Catalog files.  Also please note that the OSTN97.TXT and OSTN02.TXT data files must also reside in the primary data\ndirectory.  Again, by design, there is only one file for each of these transformations, and the\nimplementation of a Geodetic Data Catalog file was skipped.  Also, due to the rather strange nature of\nthese files, most of the features of a Geodetic Data Catalog file do not apply anyway.", 
            "title": "Dictionary Source Code and Data"
        }, 
        {
            "location": "/userguide/releasenotes/#test-source-code-and-data", 
            "text": "The directory named Test will contain the source code to the CS-MAP test program and the supporting\ndata file, TEST.DAT. Compilation and linking of this program will obviously require the inclusion of the\nheader file and library.  Make files for building the test program are provided in this folder.   Test.mak can used used to build the test program in the Linux environment.  Test.nmk can use used int the Microsoft WIndows environment using the nmake facility.   In order to execute the entire test sequence, you will need to have compiled the dictionaries with the  /t \noption.  This causes the retention of the test coordinate systems (not normally distributed with an\napplication) in the dictionary files.  The test program will also expect to have access to the NADCON\nand HPGN data files provided in the sub-directories of the Dictionaries directory.  When executing the\ntest program, use the  /d  option to indicate the location of the directory in which the dictionaries,\nNADCON, and HPGN data files reside; e.g. /d..\\Dictionaries.  This program performs a fairly substantial test of most all features and capabilities of CS-MAP.  This\nprogram should be used each time CS-MAP is used in a new configuration or compiled with a different\ncompiler.  Note that a large number of the tests encoded in the TEST.DAT file are commented out as they rely on\nthe existence of specific geodetic data files which OSGeo cannot distribute.  For example, since\nOSGeo cannot distribute the Canadian National Transformation, all test dependent upon that data file\nare commented out.  Upon obtaining geodetic data files which Mentor Software cannot distribute, you\nshould consider un-commenting the tests related to such files.", 
            "title": "Test Source Code and Data"
        }, 
        {
            "location": "/userguide/releasenotes/#documentation-directory", 
            "text": "The directory named Documentation is where you will find a copy of this documentation.  Depending\nupon the format, it may consist of a single file, or a directory containing multiple files.  A printable\nversion may also be present.  Additionally, this directory will contain the source code to the help file which is provided for use with\nthe MFC based components of CS-MAP.  The source code files include an .rtf file, a contents file (.cnt),\nand several screen shots in .bmp format.  Again, a make file compatible with Visual C++ Version 6 (or\nlater) nmake is provided; it is named  help.nmk .  (As the help file is not generally usable in the Linux\nenvironment, no Linux compatible make file is provided.)  Note, that the CS-MAP MFC based\nfunctions expect to find the help file in the same directory as the mapping data files.  Of course, a\nfunction exists which enables application programmers to override this default location\n(CS_setHelpPath).  If for any reason, the MFC based functions cannot locate the help file, the help\nbutton on all dialogs will be grayed out.  Please note that the help file is designed for distribution with your application.  It does not mention\nOSGeo, CS-MAP, or the original developers of CS-MAP.  It uses a rather generic term \"coordinate\nconversion system\" to refer to that which it is describing.", 
            "title": "Documentation Directory"
        }, 
        {
            "location": "/userguide/releasenotes/#data-directory", 
            "text": "Several data files used in the construction of CS-MAP's Name Mapper facility are included in the Data\ndirectory.  It is envisioned that these files will be replaced by a more convenient and controllable\nmeans in the near future.", 
            "title": "Data Directory"
        }, 
        {
            "location": "/userguide/desc/", 
            "text": "CS-Map Overview\n\n\nAs one programmer to another, I present this Overview Section as the manual for people who, like\nmyself, don't read the manual (until something doesn't work).  This section contains all of the\ninformation you'll need to get started quickly, and the specific information you'll need to stay out of\ntrouble.  Please read this section before attempting to use CS-MAP.  Refer to the remainder of the\nguide as necessary.\n\n\nDeferring the details to subsequent sections, it is helpful to consider CS-MAP as consisting of a\nCoordinate System Dictionary and a set of functions which use the information in the dictionary to\naccomplish the desired task.  All coordinate systems used by CS-MAP reside in the dictionary and are\ngiven a name, which we refer to as a key name, much like we give names to files.  CS-MAP, then,\nperforms coordinate system conversion based on the names of the coordinate systems provided.  This\ntechnique eliminates the need to have your users process through a long list of parameters which they\n(usually) don't understand whenever a conversion is necessary.  All they need provide are the names of\nthe appropriate coordinate systems.\n\n\nInitialization\n\n\nCS-MAP needs to be initialized.  Initialization consists of providing CS-MAP with the directory in\nwhich the dictionary files reside.  This is accomplished by calling the \nCS_altdr\n function.  This function\ntakes a single argument, a character string which is the path to the appropriate directory.  Calling\n\nCS_altdr\n with a \nNULL\n pointer as an argument will cause the value of the environmental variable named\n\nCS_MAP_DIR\n to be used as the data directory.  \nCS_altdr\n returns and integer zero if the initialization was\nsuccessful, -1 if not.\n\n\nThis was not a requirement in the past, thus the rather strange name for this initialization function.\n\n\nImportant Note 1\n: Whenever CS-MAP needs to go to disk to find something, that something often needs\nto reside in the directory specified by this function call.\n\n\nImportant Note 2\n: Failing to call this function successfully prior to using CS-MAP almost always results\nin an memory addressing fault.\n\n\nHigh Level Interface\n\n\nGiven the name of the source and target coordinate systems, conversion of coordinate data from one to\nthe other is as simple as a single function call.  The following example would cause the coordinate in\nthe array of three doubles named coordinate to be converted from NAD27 based UTM Zone 13\ncoordinates to NAD83 based Colorado State Plane, Central Zone, coordinates:\n\n\nstatus = CS_cnvrt(\nUTM27-13\n,\nCO83-C\n, coordinate);\n\n\n\n\nIt's that simple.  The simplicity of this hides several important features.  First, note that the datum shift\nimplied by the coordinate systems, NAD27 to NAD83 in this case, is automatically applied.  Second,\nyou would hardly ever code an application with hard coded coordinate system names as was done in\nthis example.  Simple character arrays that are passed by argument, providing data entered by the user\nfrom a choice list, or providing data obtained from a database, whatever, all work just fine.  These are\njust very simple, case insensitive, null terminated strings.  Third, the application programmer has no\nneed to know which projections, datums, and/or ellipsoids are involved.  Fourth, the source and/or\ntarget coordinate systems could just as easily be Latitude and Longitude coordinates, based on any of\nseveral units, and referenced to any prime meridian.\n\n\nSimilarly, should your application need to know the grid scale factor at a specific point, all you need\ncode is a function call similar to the following:\n\n\ngrid_scale = CS_scale(\nCO83-C\n, coordinate);\n\n\n\n\nCoordinate in this case must be geographic, i.e. the latitude and longitude of the point at which the grid\nscale is to be determined.  Again, it is unlikely that the name of the coordinate system would be hard\ncoded as was done in this example.  Need the convergence angle?  You have probably figured it out\nalready:\n\n\nconvergence = CS_cnvrg(\nCO83-C\n, coordinate);\n\n\n\n\nConcerned about performance?  Originally, the above interface was designed as a means by which\napplications written in languages other than 'C' could access CS-MAP; i.e. no pointers required.\nHowever, due to its design and the high speed processors with on-board caches which are common\ntoday, this interface provides amazing levels of performance.  It is now the interface which we\nrecommend for all simple applications.\n\n\nSeveral other features are made available in what we call the High Level Interface; that is features\nwhich are available without the use of pointers.  The details of all such features are provided in the\ntopic named High Level Interface.\n\n\nCoordinate System Dictionary\n\n\nThe coordinate system is the heart of the CS-MAP package.  The CS-MAP distribution includes the\ndefinition of more than 5,000 coordinate systems.  Each definition includes the projection to be used,\nthe projection parameters, the datum or ellipsoid to which the coordinate system is referenced, and the\nunit to be used.  Admittedly, many of the coordinate system definitions provided are very similar to\nothers, differing only in the system unit or datum referenced. However, we believe your users will\nappreciate the simplicity of having only to remember and enter an easy to remember name or two to\nget what they need.  The default feature described elsewhere in this manual can be used in those cases\nwhere this design becomes inconvenient.\n\n\nCoordinate system definitions are stored in a file we refer to as the Coordinate System Dictionary.\nThis file is a simple fixed length record file containing binary data.  It is maintained in sorted order by\ncoordinate system name and is accessed using a binary search technique.  This provides portability to\nalmost any environment without having to license any other software.  Your application will need to\nprovide the CS-MAP functions with the location of the directory in which the Coordinate System\nDictionary resides (see \nCS_altdr\n).  Once CS-MAP locates the Coordinate System Dictionary, it expects\nto find all most other data files in the same directory.\n\n\nCS-MAP distributions include an ASCII file which defines all of the coordinate systems included in\nthe distribution. This file is usually committed to version control and treated has a highly valuable\nsource file.  A compiler included with CS-MAP can convert this ASCII file into the binary form used\nby the system.\n\n\nImportant Note\n: The first four bytes of a binary coordinate system dictionary file is a \"magic number\".\nThis sequence of bytes are used to identify that the file is indeed a coordinate system dictionary file.\nThe revision level of the dictionary format is also encoded into this \"magic number\".\n\n\nOther Interfaces\n\n\nIt is probably obvious to you that the interface described above can not be the most efficient interface\npossible. Applications which require the absolute highest performance, may want to use the High\nPerformance Interface.  This interface requires the knowledge of as many as ten functions.  It also\nrequires the use of pointers to structures and, therefore, is usable only from languages such as C, C++,\nor Pascal which can handle pointers appropriately.  It does, however, provide the application\nprogrammer with the highest performance level possible, while still insulating your application from\nchanges to the internals of CS-MAP.  Using this interface, performance levels of 1,000,000 non-trivial\nconversions per second are routinely observed.\n\n\nApplications which are hard coded around specific projections can use the Low Level Interface to\nobtain high performance solutions which do not require a Coordinate System Dictionary or, for that\nmatter, any other supporting data.  That is, at this level, the application programmer has access to the\nspecific code for each projection.  Similarly, applications can use the low level interface to access any\nof the 12 or so datum shift techniques supported by the library.\n\n\nThe High Performance and Low Level Interfaces are described in detail in the remaining chapters of\nthis guide.\n\n\nOther Dictionaries\n\n\nLike coordinate systems, datums are many and varied.  (The term datum is widely used to refer to a\nHorizontal Geodetic Reference System.  Although this usage is not technically incorrect, we will go\nalong with the crowd and use the simpler term.)  While several datum conversion techniques are hard\ncoded into CS-MAP, the actual definitions are not.  As you might suspect, there exists a Datum\nDictionary which contains the definition of all datums known to the system and provides a name by\nwhich they can be accessed (i.e. key name).  Coordinate systems are referenced to a datum by\nincluding the datum key name in the coordinate system definition.  Thus, when converting from one\ncoordinate system to another, CS-MAP can automatically activate the appropriate datum shifts\nnecessary by examining the datum references in the coordinate system definitions.  While full support\nis provided, application programmers rarely, if ever, access the Datum Dictionary directly.\n\n\nAll datum definitions \nmust\n include a reference to an ellipsoid; coordinate system definitions can\ninclude a reference to an ellipsoid.  Again, there are many ellipsoid definitions and these are not hard\ncoded into CS-MAP.  You guessed it!  There is an Ellipsoid Dictionary:\n\n\n\n\nthat carries the definitions of all ellipsoids,\n\n\nthat assigns each ellipsoid definition a name (i.e. a key name),\n\n\nto which CS-MAP provides a full set of access functions; and\n\n\nthat the application programmer rarely, if ever, accesses directly.\n\n\n\n\nImportant Note\n: Datum and Ellipsoid dictionaries include a \"magic number\" as the first four bytes of\nthe binary file.  These \"magic numbers\" identify the type of the file in addition to the file format\nrevision level.\n\n\nCartographic vs. Geodetic Referencing of Coordinate Systems\n\n\nWhile coordinate system definitions can be referenced to a datum, they can also be referenced directly\nto an ellipsoid. In this manual, we will use the term \ngeodetically referenced\n coordinate system to refer\nto the former case, and \ncartographically referenced\n coordinate system to refer to the latter.  When both\nthe source and target coordinate systems involved in a conversion are geodetically referenced, CS-\nMAP can automatically perform the necessary datum shift without any additional information required\nfrom the user, or any additional code required by the application programmer.  When either or both\ncoordinate system definitions are cartographically referenced, the datum shift feature is effectively\ndisabled.  That is, CS-MAP cannot calculate a datum shift it does not know both the source and target\ndatums.\n\n\nIn many cases, the datums upon which coordinates are based are known.  In these cases, coordinate\nsystem definitions are usually geodetically referenced and CS-MAP can, therefore, include the\nappropriate datum shift automatically whenever appropriate.  In other cases, the datum upon which a\ncoordinate system is based is not known and the coordinate system should be cartographically\nreferenced to an ellipsoid.  CS-MAP's automatic datum shift feature is then disabled whenever this\ncoordinate system is involved in a coordinate conversion.  Therefore, while the individual maintaining\nthe coordinate system definitions may need to understand the distinctions between geodetic and\ncartographic references, the typical end user is not usually concerned.\n\n\nCartographically referenced coordinate systems can be a great convenience to both user and application\nprogrammer.  For example, the LL coordinate system which you will find in the CS-MAP distribution is\ncartographically referenced to the WGS84 \nellipsoid (not the WGS84 datum)\n.  This means that using the\nLL coordinate system as the target in any conversion produces geographic coordinates which are always\nbased on the same datum as the source coordinate system.  This is often very convenient indeed.\n\n\nLatitudes and Longitudes\n\n\nCoordinate systems can be defined to be geographic, i.e. consist of latitude and longitude coordinates.\nThis is achieved through the use of a pseudo projection we call the Unity projection.  The Unity\nProjection is simply a projection which does nothing, the results being geographic coordinates.  Since\nthe definitions of a latitude and longitude coordinate systems are included in the Coordinate System\nDictionary, they can, and indeed do, have datum references, origin longitudes, and units specifications.\nThus, several latitude and longitude definitions appear in the coordinate system dictionary.  As with\nany other coordinate system definition, these definitions are either geodetically or cartographically\nreferenced, have a unit specification, and have an origin longitude.  In this context, the units are the\nangular units of measure to be used (e.g. degrees, minutes, seconds, grads, etc.) and the origin\nlongitude is the prime meridian (i.e. Greenwich, Meridian of Paris, etc.).  Thus, latitude and longitude\ncoordinates are fully supported by the system, and the application programmer is not required to write\nany special code to process them.\n\n\nThe distribution Coordinate System Dictionary contains a geographic coordinate system simply named\n\nLL\n.  This is a cartographically referenced latitude and longitude coordinate system which is referenced\nto the Greenwich Prime Meridian, using units of degrees.  Thus, \nLL\n should be considered to be the\ngeneric latitude and longitude coordinate system, and can be used as such.  For example, to obtain the\ngrid scale factor of a coordinate system using cartesian coordinates (as opposed to the geographic\ncoordinates required by the CS_scale function) one could simply write as follows:\n\n\nstatus = CS_cnvrt(\nCO83-C\n, \nLL\n, coordinate);\ngrid_scale = CS_scale(\nCO83-C\n, coordinate);\n\n\n\n\nNote, that due to the generic nature of the \nLL\n coordinate system (i.e. cartographically referenced,\nthereby disabling datum shifts), the intermediary latitude and longitude results will be always be based\non the same datum as that of the source coordinate system.  Also, the \nLL\n coordinate system is defined\nto match the specific definition of latitude and longitude used internally within CS-MAP.  That is, in\nthose few cases where CS-MAP specifically requires a coordinate in terms of latitude and longitude:\n\n\n\n\nthe coordinates must be in degrees,\n\n\nreferenced to the Greenwich Prime Meridian, and\n\n\nwest longitude and south latitude must be negative values.\n\n\n\n\nCoordinate Arrays\n\n\nAs is common in the industry, cartesian coordinates are passed in arrays of doubles.  The X coordinate\nis always the first element in the array, the Y coordinate being the second element, and the Z\ncoordinate being the third element.  When performing a two dimensional conversion, CS-MAP often\nignores the Z coordinate.  Obviously, when performing a three dimensional conversion, a valid Z\ncoordinate is required.  To simplify use of the library, all coordinate arrays should be dimensioned at\nthree.  Typically, a Z value of zero is provided when performing a two dimensional conversion.\n\n\nIn the case of cartesian coordinates, coordinates must be ordered as described above; specifically X, Y,\nand then Z.  While it is common usage to refer to geographic coordinates as latitude and longitude, and\nit is also common to give the latitude first and the longitude second, CS-MAP requires that the first\nelement of a geographic coordinate be the longitude, the second element be the latitude, and the third\nelement the height.  While negative values are usually used to indicate west longitude and south\nlatitude, geographic coordinate systems can be defined where the opposite sign convention is used.\n\n\nIt is important to note that there is a significant difference between coordinates returned to the user\nwhich may just happen to be geographic, and the geographic coordinates required by certain CS-MAP\nfunctions.  The conventions used in \"user\" coordinates are determined by the coordinate system\ndefinition.  Thus, in a \"user\" geographic coordinate, as returned by CS_cs2ll for example, the prime\nmeridian may be other than Greenwich and the unit other than degrees.  Users can also define\ngeographic coordinate systems where west longitude is positive and/or the order of the coordinates is\nswapped.\n\n\nHowever, wherever a CS-MAP function specifically requires a geographic coordinate, the values\nprovided \nmust\n:\n\n\n\n\nbe given in degrees,\n\n\nbe referenced to the Greenwich Prime Meridian, and\n\n\nwest longitude and south latitude be given as negative values.\n\n\n\n\nSelected Source Code\n\n\nFor historical reasons, most all global data definitions are coded in distinct modules.  This has been\nvery convenient over the years.  Many of the features of CS-MAP can be adjusted to better fit into your\napplication by tweaking one of these source modules.  Four of these modules are worth mention in this\noverview: \nCSdata\n, \nCSdataU\n, \nCSdataPJ\n, and \nCS_error\n.  In \nCSdata\n you will find the definition of many\nglobal constants used throughout CS-MAP.  While you obviously don't want to change the definition\nof \u03c0, there are several other aspects of CS-MAP which are controlled by global variables defined in\nthis module.  Make the modifications which you need, recompile, and re-link your application.\n\n\nCSdataU\n contains the unit table which CS-MAP uses.  To add (or remove) a unit, simply modify the\ntable and recompile.\n\n\nCSdataPJ\n contains CS-MAP's projection table.  To remove a projection (to reduce the size of your\nexecutable, for example), simply remove the projection's entry in the table an all object code references\nto the projection will be removed.\n\n\nCS_error\n contains the text of all error messages.\n\n\nAll data which may be language related is contained in these four modules.  To translate the entire\nsystem to another language, only these four modules, and perhaps the help file, need attention.\n\n\nNaming Conventions\n\n\nOriginally, the names of global variables, manifest constants (i.e. defines), structures, and functions\nused in CS-MAP adhered to a very definitive naming convention.  Much of the library still adheres to\nthis convention.  This convention was developed with three purposes in mind.  First, and foremost, it is\nnecessary to insure that the probability of a name collision with existing application code is kept to a\nminimum.  Second, to enable programmers to quickly determine the type of entity being referenced by\na name and to quickly determine where the definition of such can be found.  Third, provide an efficient\nmeans by which the libraries and other components of CS-MAP can be efficiently maintained and\nmanufactured.\n\n\nIn later developments of the library, such as the inclusion of some C++ elements and the planned\nporting of the entire library to C++, there are several modules no longer adhere to the original naming\nconvention.\n\n\nName Collisions\n\n\nAll names whose scope extends outside the specific file in which is it is defined will start with the two\ncharacter sequence \nCS\n.  As described below, this initial sequence may be in upper or lower case.\nAdditionally, every such name will contain at least one upper case character and at least one lower case\ncharacter.  In this way, the possibility of a CS-MAP global name being the same as a name already\nused in your application is virtually nil.\n\n\nFunction Names\n\n\nAll function names begin with an upper case \nCS\n sequence.  If the function is expected to be accessed\nby modules outside of the CS-MAP library in normal use, the initial CS sequence is followed by an\nunderscore character.  The remainder of the function name follows, the first of which will be lower\ncase if it is an alphabetic character.\n\n\nStructure Tags\n\n\nStructure tags begin with a lower case cs sequence.  If the structure is expected to be accessed by\nmodules outside of the CS-MAP library in normal use, the initial sequence is followed by an\nunderscore character.  The remainder of the structure tag follows, the first character of which will\nalways be uppercase.  Finally, the last character of all structure tags will be the underscore character.\n\n\nGlobal Variable Names\n\n\nGlobal variable names begin with a lower case cs sequence.  If the global variable is expected to be\naccessed by modules outside of the CS-MAP library in normal use, the initial sequence is followed by\nan underscore character.  The remainder of the global variable name follows, the first character of\nwhich will always be an upper case letter.  A global variable name will never end with the underscore\ncharacter.  A global variable which is a definition of a structure, or a pointer to same, will usually have\nthe same name as the structure tag, sans the trailing underscore.\n\n\nManifest contents\n\n\nManifest constant names, e.g. include file define's, begin with a lower case cs sequence.  If the constant\nbeing defined is expected to be used by modules outside of the CS-MAP library, the initial sequence is\nfollowed by an underscore character.  The remainder of the constant name follows and will be all upper\ncase.\n\n\nNaming Convention Examples\n\n\nThe table below shows several examples of the naming convention;\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nComment\n\n\n\n\n\n\n\n\n\n\nCS_csloc\n\n\nFunction, external\n\n\nName of a function expected to be called from outside of the CS-MAP library.\n\n\n\n\n\n\nCSnad283\n\n\nFunction, internal\n\n\nName of a function not expected to be called from outside of the CS-MAP library.\n\n\n\n\n\n\ncs_Csdef_\n\n\nStructure tag, external\n\n\nStructure tag name for a structure expected to be referenced by modules outside of the CS-MAP library.\n\n\n\n\n\n\ncsNaddir_\n\n\nStructure tag, internal\n\n\nStructure tag name for a structure not expected to be accessed outside of the CS-MAP library.\n\n\n\n\n\n\ncs_Dir\n\n\nGlobal Variable, external\n\n\nGlobal variable name expected to be accessed outside of the CS-MAP library\n\n\n\n\n\n\ncsErrlng\n\n\nGlobal Variable, internal\n\n\nGlobal variable name not expected to be accessed outside of the CS-MAP library.\n\n\n\n\n\n\ncs_NO_MEM\n\n\nManifest Constant, external\n\n\nManifest constant expected to be referenced by modules outside of the CS-MAP library.\n\n\n\n\n\n\ncsGRF_MAX_ACTIVE\n\n\nManifest Constant, internal\n\n\nManifest constant not expected to be referenced by modules outside of the CS-MAP library.\n\n\n\n\n\n\n\n\nProjection Code Names\n\n\nEach of the thirty eight projections has a five character code name which is used in all structure tags\nand function names associated with the specific projection.  The table below lists each projection, the five\ncharacter code value, the structure tag name, and setup function name associated with each as examples\nof how this code value is used to identify the projection each is associated with.  All code elements\nwhich are specifically related to specific projection are named in a similar manner.\n\n\n\n\n\n\n\n\nProjection\n\n\nCode\n\n\nStructure Tag\n\n\nSetup Function\n\n\n\n\n\n\n\n\n\n\nTransverse Mercator\n\n\ntrmer\n\n\ncs_Trmer_\n\n\nCStrmerS\n\n\n\n\n\n\nLambert Conformal Conic\n\n\nlmbrt\n\n\ncs_Lmbrt_\n\n\nCSlmbrtS\n\n\n\n\n\n\nHotine Oblique Mercator\n\n\noblqm\n\n\ncs_Oblqm_\n\n\nCSoblqmS\n\n\n\n\n\n\nAlber's Equal Area\n\n\nalber\n\n\ncs_Alber_\n\n\nCSalberS\n\n\n\n\n\n\nMercator\n\n\nmrcat\n\n\ncs_Mrcat_\n\n\nCSmrcatS\n\n\n\n\n\n\nMiller Cylindrical\n\n\nmillr\n\n\ncs_Millr_\n\n\nCSmillrS\n\n\n\n\n\n\nLambert Equidistant Azimuthal\n\n\nazmed\n\n\ncs_Azmed_\n\n\nCSazmedS\n\n\n\n\n\n\nLambert Equal Area Azimuthal\n\n\nazmea\n\n\ncs_Azmea_\n\n\nCSazmeaS\n\n\n\n\n\n\nPolar Stereographic\n\n\npstro\n\n\ncs_Pstro_\n\n\nCSpstroS\n\n\n\n\n\n\nOblique Stereographic\n\n\nostro\n\n\ncs_Ostro_\n\n\nCSostroS\n\n\n\n\n\n\nSnyder's Oblique Stereographic\n\n\nsstro\n\n\ncs_Sstro_\n\n\nCSsstroS\n\n\n\n\n\n\nEquidistant Conic\n\n\nedcnc\n\n\ncs_Edcnc_\n\n\nCsedcncS\n\n\n\n\n\n\nSinusoidal\n\n\nsinus\n\n\ncs_Sinus_\n\n\nCSsinusS\n\n\n\n\n\n\nAmerican Polyconic\n\n\nplycn\n\n\ncs_Plycn_\n\n\nCSplycnS\n\n\n\n\n\n\nModified Polyconic\n\n\nmodpc\n\n\ncs_Modpc_\n\n\nCsmodpcS\n\n\n\n\n\n\nLambert Tangential\n\n\nlmtan\n\n\ncs_Lmtan_\n\n\nCSlmtanS\n\n\n\n\n\n\nVan der Grinten\n\n\nvdgrn\n\n\ncs_Vdgrn_\n\n\nCSvdgrnS\n\n\n\n\n\n\nOrthographic\n\n\northo\n\n\ncs_Ortho_\n\n\nCSorthoS\n\n\n\n\n\n\nGnomonic\n\n\ngnomc\n\n\ncs_Gnomc_\n\n\nCsgnomcS\n\n\n\n\n\n\nEquidistant Cylindrical\n\n\nedcyl\n\n\ncs_Edcyl_\n\n\nCSedcylS\n\n\n\n\n\n\nCassini\n\n\ncsini\n\n\ncs_Csini_\n\n\nCScsiniS\n\n\n\n\n\n\nModified Stereographic\n\n\nmstro\n\n\ncs_Mstro_\n\n\nCSmstroS\n\n\n\n\n\n\nNew Zealand National Grid\n\n\nnzlnd\n\n\ncs_Nzlnd_\n\n\nCSnzlndS\n\n\n\n\n\n\nRobinson Cylindrical\n\n\nrobin\n\n\ncs_Robin_\n\n\nCSrobinS\n\n\n\n\n\n\nBonne\n\n\nbonne\n\n\ncs_Bonne_\n\n\nCsbonneS\n\n\n\n\n\n\nEqual Area (Authalic) Cylindrical, Normal Aspect\n\n\nnacyl\n\n\ncs_Nacyl_\n\n\nCSnacylS\n\n\n\n\n\n\nEqual Area (Authalic) Cylindrical, Transverse Aspect\n\n\ntacyl\n\n\ncs_Tacyl_\n\n\nCStacylS\n\n\n\n\n\n\nMollweide\n\n\nmolwd\n\n\ncs_Molwd_\n\n\nCsmolwdS\n\n\n\n\n\n\nEckert IV\n\n\nekrt4\n\n\ncs_Ekrt4_\n\n\nCSekrt4S\n\n\n\n\n\n\nEckert VI\n\n\nekrt6\n\n\ncs_Ekrt6_\n\n\nCSekrt6S\n\n\n\n\n\n\nGoode Homolosine\n\n\nhmlsn\n\n\ncs_Hmlsn_\n\n\nCShmlsnS\n\n\n\n\n\n\nBipolar Oblique Conformal Conic\n\n\nbpcnc\n\n\ncs_Bpcnc_\n\n\nCSbpcncS\n\n\n\n\n\n\nOblique Cylindrical\n\n\nswiss\n\n\ncs_Swiss_\n\n\nCSswissS\n\n\n\n\n\n\nSnyder Transverse Mercator\n\n\ntrmrs\n\n\ncs_Trmrs_\n\n\nCStrmrsS\n\n\n\n\n\n\nKrovak Oblique Conformal Conic\n\n\nkrovk\n\n\ncs_Krovk_\n\n\nCSkrovkS\n\n\n\n\n\n\nNon-georeferenced Coordinates\n\n\nnerth\n\n\ncs_Nerth_\n\n\nCSnerthS\n\n\n\n\n\n\nDanish System 34\n\n\nsys34\n\n\ncs_Sys34_\n\n\nCSsys34S\n\n\n\n\n\n\nUnity Pseudo Projection\n\n\nunity\n\n\ncs_Unity_\n\n\nCSunityS\n\n\n\n\n\n\n\n\nHigh Level Interface\n\n\nFunctions are provided which can convert a coordinate from one coordinate system to another with a single function call. This set of functions was originally developed specifically for the application programmer who is coding in \nBASIC\n, \nFORTRAN\n, \nAPL\n, or other language (other than C or Pascal) which can make simple function calls. It does not use structure pointers of any sort. Since the affect on performance is small (about a 20% reduction), it is now the recommended interface for most applications.\nMost of the functions described in this section use \nCSbcclu\n and \nCSbdclu\n to cache coordinate system and datum conversion definitions. Therefore the performance penalty of these functions is reduced to a search of a linked list for the coordinate system names involved. These cache functions are smart enough to keep the most recently accessed items at the front of the list to further minimize the performance penalty.\nThe information presented in this section is intended only to associate a function name with a specific capability.\n\n\nBasic Coordinate Conversion -- CS_cnvrt\n\n\nGiven a coordinate as an array of three doubles, and the names of two coordinate systems as two character arrays, \nCS_cnvrt\n converts the coordinate from one system to another. It's that simple. Where cartesian coordinates are provided and returned, the X coordinate is the first element of the array, the Y coordinate is the second, and the Z is the third element of the array. Where geographic coordinates are provided, the first element in the array must contain the longitude, the second the latitude, and the third element must contain the height. In either case, the manner in which the values are interpreted depends upon the coordinate systems involved. For example, if the source coordinate system definition specifies the unit to be meters, the X, Y, and Z coordinates are considered to be in meters. Similarly, if the target coordinate system is defined as a latitude and longitude system with an angular unit of grads, the returned latitude and longitude coordinates will be in units of grads.\n\n\nThe status value returned by \nCS_cnvrt\n informs the calling application of the validity of the results. A zero return value indicates that the requested conversion was completed without complication and the results now occupy the coordinate array. A negative status return value indicates a hard error occurred and that the contents of the coordinate array remain unchanged. A positive, non-zero return status indicates that the conversion was performed, but an abnormality was encountered during the conversion. In this case, the results returned in the coordinate array may not be exactly what the user expects.\n\n\nIn all cases of a negative status return, the values in the provided coordinate array will remain unchanged. Taking the absolute value of the returned status value will often produce the CS-MAP error code for the specific condition causing the hard error. The numeric error code which defines the specific cause of the problem will also be stored in the \ncs_Error\n global variable, and a textual description of the error condition can be obtained by calling the \nCS_errmsg\n function before calling any other CS-MAP function. Typically, when applications detect a negative status return, the application informs the user using the textual description obtained from \nCS_errmsg\n and terminates the current operation.\n\n\nCS_cnvrt\n returns a positive non-zero status value whenever it encounters something suspicious, but not something that precludes a conversion. Positive non-zero return values are usually caused by coordinate systems and coordinates which are incompatible, or specific values which are singularity points for the projection(s) involved. A common cause of a positive non-zero return value is the conversion of a point at either pole. CS-MAP will return a positive non-zero value in these cases as longitude is undefined at the poles, and reversing the calculation is unlikely to reproduce the initial value. Another common cause of a positive non-zero status return is providing, say, UTM coordinates when the source coordinate system is given as \"LL\". UTM coordinates, usually, will not be in the normal range of geographic coordinates and CS-MAP will consider this to be suspicious. A positive return value will also be returned if, for example, it is requested to convert a geographic coordinate in Europe from NAD27 to NAD83.\n\n\nWhen a positive non-zero return value from \nCS_cnvrt\n is encountered, the typical application issues a warning message to the user and continues. These abnormal, but not necessarily fatal, conditions are often the result the user desires. It should be left the user to decide. For performance reasons, CS- MAP does not automatically generate a textual message for these conditions. However, application programs can analyze the returned status value in order to present a more specific warning message to the end user.\n\n\nGrid Scale Factor -- CS_scale\n\n\nGiven a coordinate system name and a location in the form of a geographic coordinate, \nCS_scale\n will return the grid scale factor of the coordinate system at the specified location. \nCS_scale\n returns a negative one in the event of an error condition. In such cases, the cause of the error can be determined by examining \ncs_Error\n which will contain the CS-MAP numeric error code of the condition which caused the error. \nCS_errmsg\n can be used to obtain a textual description of the error condition. An error caused by the location being outside of the domain of the coordinate system will be indicated by a \ncs_Error\n value of zero. In this case, no textual description will be available.\n\n\nNote that the coordinate provided as the second argument must be a geographic coordinate, i.e. latitude and longitude in degrees referenced to the Greenwich prime meridian. Longitude is the first element in the array, latitude is the second. (The third element is not currently used for grid scale calculations, but may be in the future.) As always for internal geographic coordinates, use negative values for west longitude and south latitude.\n\n\nConvergence Angle -- CS_cnvrg\n\n\nGiven a coordinate system name and a location in the form of a geographic coordinate, \nCS_cnvrg\n will return the convergence angle of the coordinate system at the specified location, in degrees east of north. \nCS_cnvrg\n returns a negative 360 (i.e. -360) value in the event of an error condition. In such cases, the cause of the error can be determined by examining \ncs_Error\n which will contain the CS- MAP numeric error code of the condition which caused the error. \nCS_errmsg\n can then be used to obtain a textual description of the error condition. An error caused by the location being outside of the domain of the coordinate system will be indicated by a \ncs_Error\n value of zero. In this case, no textual description will be available.\n\n\nNote that the coordinate provided as the second argument must be a geographic coordinate, i.e. latitude and longitude in degrees referenced to the Greenwich prime meridian. Longitude is the first element in the array, latitude is the second. (The third element is not used for convergence calculations.) As always, use negative values for west longitude and south latitude.\n\n\nData Directory -- CS_altdr\n\n\nIn order to operate correctly, CS-MAP needs to access to several data files, the most important of which is the Coordinate System Dictionary. \nCS_altdr\n can be used to provide CS-MAP with the path to the directory it should look in for all of its data files. The single argument should contain the full path to the directory containing all of CS-MAP's supporting data files. You can instruct \nCS_altdr\n to use the value of the \nCS_MAP_DIR\n environmental variable by setting the argument to the NULL pointer. Should the argument point to the null string, CS-MAP will consider the current directory on the current drive as the directory in which to search for data file.\n\n\nIn all cases, \nCS_altdr\n will return a -1 if a valid Coordinate System Dictionary file could not be located in the indicated directory, for whatever reason.\n\n\nImportant Note:\n Failure to successfully call this function prior to calling any other CS-MAP function is likely to cause a fatal addressing error and the host application to crash.\n\n\nRecover System Resources -- CS_recvr\n\n\nUse this function to recover any and all system resources, such as file descriptors and heap memory, which CS-MAP may have allocated due to calls to \nCS_cnvrt\n, \nCS_scale\n, and \nCS_cnvrg\n functions.\n\n\nGet Error Message Text -- CS_errmsg\n\n\nCS_errmsg\n returns in the buffer supplied by the calling module a null terminated string which is suitable for reporting the last error condition detected by CS-MAP. This function should be used only after any CS-MAP function returns a negative status. It should be called prior to any other CS-MAP function call.\n\n\nCompute Azimuth and Distance -- CS_llazdd\n\n\nCS_llazdd\n is a utility function which is a part of the High Level Interface. Use this function to compute the azimuth from one geographic coordinate to another. It also returns the distance between the two points. These calculations take full account of the ellipsoid, and ellipsoid parameters are part of the calling sequence.\n\n\nUnit Lookup -- CS_unitlu\n\n\nUse \nCS_unitlu\n function to obtain the conversion constant for any of the unit systems understood by CS- MAP. \nCS_unitlu\n will return a zero if the supplied unit name is not valid.\n\f\n\n\nCoordinate System Name Verification \u2013 CS_csIsValid\n\n\nUse the \nCS_csIsValid\n function to determine if a coordinate system key name is that of an existing coordinate system defined in the currently active Coordinate System Dictionary without any side affects.\n\n\nDatum Name Verification \u2013 CS_dtIsValid\n\n\nUse the \nCS_dtIsValid\n function to determine if a datum key name is that of an existing datum defined in the currently active Datum Dictionary without any side affects.\n\n\nEllipsoid Name Verification \u2013 CS_elIsValid\n\n\nUse the \nCS_elIsValid\n function to determine if a ellipsoid key name is that of an existing ellipsoid defined in the currently active Ellipsoid Dictionary without any side affects.\n\n\nLow Level Functions\n\n\nWhile the use of the High Level or the High Performance Interfaces described above is highly recommended, certain applications may require the use of the lower level functions. The sub-sections of this section organize these functions into three major groups:\n\n\n\n\ncartographic projection functions,\n\n\ngeodetic datum shift functions, and\n\n\ngeneral mapping/geodetic functions.\n\n\n\n\nCartographic Projections\n\n\nFor each projection supported, there exist eight, possibly nine, functions which comprise the full implementation of a projection. The brief description of these functions is given below. These descriptions will be important to those adding a new projection as well.\n\n\nThose adding projections to the system only need to add an entry to the projection table \ncs_Prjtab\n. Doing so, you will need to add a pointer to the Definition Check and the Setup functions. To activate the proper parameter settings in the MFC dialog, you will also need to add the projection to the \ncs_PrjprmMap\n table. It is unlikely, but if your new projection uses a new type of parameter, you may need to add a new entry to the \ncs_Prjprm\n table. All of these tables are defined in the \nCSdataPJ.c\n module.\n\n\nDefinition Check Functions\n\n\nFor each projection there exists a function which verifies that a coordinate system definition adheres to the requirements of the projection. These functions are named in a manner similar to all other projection functions, but the distinguishing final character is Q. To prevent large scale duplication of code, each Q function checks only those elements of a coordinate system definition which are specific to the projection. The generalized check function, \nCS_cschk\n, checks those elements which are common to all coordinate systems (e.g. datum, ellipsoid, and units).\n\n\nCS_csloc\n calls this function prior to calling the setup function, thus providing the setup function with data known to be valid for the given projection. This also implies that the pointer to the Q function for each projection must reside in the projection table.\n\n\nSetup Function\n\n\nThe setup function for each projection has two basic responsibilities. It should perform all of the one- time calculations which can be performed independent of the specific coordinates which are to be converted and insert in the \ncs_Csprm_\n structure pointers to the nine functions required for coordinate conversion. It is the setup function which is the primary repository for all knowledge about a specific projection. Therefore, it is one of the five elements required in the projection table other than the name of the projection. (C++ users would use the term constructor for the setup function. The design of CS- MAP predates the availability of C++ compilers on personal computers.)\n\n\nThis function is always supplied with a pointer to a \ncs_Csprm_\n structure. This single argument supplies the setup function with the information required to perform the setup via the csdef and datum elements and the repository for the results of the setup by way of the \nll2cs\n, \ncs2ll\n, \ncs_csscl\n, \ncs_cscnv\n, \ncs_cssck\n, \ncs_cssch\n, \nllchk\n, \nxychk\n, and \nprj_prmselements\n. Note that the \nprj_prms\n element of the \ncs_Csprm_\n structure is a union of all the pre-processed projection parameter structures, thus providing a repository for setup parameters regardless of the projection in use.\n\n\nAlso note that in order to reduce the amount of duplicated code necessary to support the large number of projection variations now supported, the \nprj_code\n element of the \ncs_Csprm_\nstructure must be filled in as well prior to calling the setup function.\n\n\nForward Functions\n\n\nFor each supported projection, there exists a forward function. It is responsible for converting latitudes and longitudes to the appropriate coordinates given a pointer to the projection parameters for the specific projection. A pointer to such function is inserted into the \nll2cs\n element of the \ncs_Csprm_\n structure by the setup function. These functions require that they be given a pointer to the projection parameters calculated by the setup function, e.g. a pointer to a element of the \nprj_prms\n union in the \ncs_Csprm_\n structure.\n\n\n\n\n\n\n\n\nSetup Function\n\n\nForward Function\n\n\nInverse Function\n\n\nProjection\n\n\n\n\n\n\n\n\n\n\nCstrmerS\n\n\nCStrmerF\n\n\nCStrmerI\n\n\nTransverse Mercator\n\n\n\n\n\n\nCSlmbrtS\n\n\nCSlmbrtF\n\n\nCSlmbrtI\n\n\nLambert Conformal Conic\n\n\n\n\n\n\nCsoblqmS\n\n\nCSoblqmF\n\n\nCSoblqmI\n\n\nHotine Oblique Mercator\n\n\n\n\n\n\nCSalberS\n\n\nCSalberF\n\n\nCSalberI\n\n\nAlber\u2019s Equal Area Conic\n\n\n\n\n\n\nCSmrcatS\n\n\nCSmrcatF\n\n\nCSmrcatI\n\n\nMercator\n\n\n\n\n\n\nCSmillrS\n\n\nCSmillrF\n\n\nCSmillrI\n\n\nMiller Cylindrical\n\n\n\n\n\n\nCsazmedS\n\n\nCSazmedF\n\n\nCSazmedI\n\n\nLambert Equidistant Azimuthal\n\n\n\n\n\n\nCsazmeaS\n\n\nCSazmeaF\n\n\nCSazmeaI\n\n\nLambert Equal Area Azimuthal\n\n\n\n\n\n\nCSpstroS\n\n\nCSpstroF\n\n\nCSpstroI\n\n\nPolar Stereographic\n\n\n\n\n\n\nCSostroS\n\n\nCSostroF\n\n\nCsostroI\n\n\nOblique Stereographic\n\n\n\n\n\n\nCSsstroS\n\n\nCSsstroF\n\n\nCSsstroI\n\n\nSnyder\u2019s Oblique Stereographic\n\n\n\n\n\n\nCsedcncS\n\n\nCSedcncF\n\n\nCSedcncI\n\n\nEquidistant Conic\n\n\n\n\n\n\nCSsinusS\n\n\nCSsinusF\n\n\nCSsinusI\n\n\nSinusoidal\n\n\n\n\n\n\nCSplycnS\n\n\nCSplycnF\n\n\nCSplycnI\n\n\nAmerican Polyconic\n\n\n\n\n\n\nCsmodpcS\n\n\nCSmodpcF\n\n\nCSmodpcI\n\n\nModified Polyconic\n\n\n\n\n\n\nCSlmtanS\n\n\nCSlmtanF\n\n\nCSlmtanI\n\n\nLambert Tangential\n\n\n\n\n\n\nCSvdgrnS\n\n\nCSvdgrnF\n\n\nCSvdgrnI\n\n\nVan der Grinten\n\n\n\n\n\n\nCSorthoS\n\n\nCSorthoF\n\n\nCSorthoI\n\n\nOrthographic\n\n\n\n\n\n\nCsgnomcS\n\n\nCSgnomcF\n\n\nCSgnomcI\n\n\nGnomonic\n\n\n\n\n\n\nCSedcylS\n\n\nCSedcylF\n\n\nCSedcylI\n\n\nEquidistant Cylindrical\n\n\n\n\n\n\nCScsiniS\n\n\nCScsiniF\n\n\nCScsiniI\n\n\nCassini\n\n\n\n\n\n\nCSmstroS\n\n\nCSmstroF\n\n\nCSmstroI\n\n\nModified Stereographic\n\n\n\n\n\n\nCSnzlndS\n\n\nCSnzlndF\n\n\nCSnzlndI\n\n\nNew Zealand National Grid\n\n\n\n\n\n\nCSrobinS\n\n\nCSrobinF\n\n\nCSrobinI\n\n\nRobinson\n\n\n\n\n\n\nCSbonneS\n\n\nCSbonneF\n\n\nCSbonneI\n\n\nBonne\n\n\n\n\n\n\nCSnacylS\n\n\nCSnacylF\n\n\nCSnacylI\n\n\nNormal Aspect, Equal Area (Authalic) Cylindrical\n\n\n\n\n\n\nCStacylS\n\n\nCStacylF\n\n\nCSnacylI\n\n\nTransverse Aspect, Equal Area (Authalic) Cylindrical\n\n\n\n\n\n\nCsmolwdS\n\n\nCSmolwdF\n\n\nCSmolwdI\n\n\nMollweide\n\n\n\n\n\n\nCSekrt4S\n\n\nCSekrt4F\n\n\nCSekrt4I\n\n\nEckert IV\n\n\n\n\n\n\nCSekrt6S\n\n\nCSekrt6F\n\n\nCSekrt6I\n\n\nEckert VII\n\n\n\n\n\n\nCShmlsnS\n\n\nCShmlsnF\n\n\nCShmlsnI\n\n\nGoode Homolosine\n\n\n\n\n\n\nCSbpcncS\n\n\nCSbpcncF\n\n\nCSbpcncI\n\n\nBipolar Oblique Conformal Conic\n\n\n\n\n\n\nCSswissS\n\n\nCSswissF\n\n\nCSswissI\n\n\nOblique Cylindrical\n\n\n\n\n\n\nCStrmrsS\n\n\nCStrmrsF\n\n\nCStrmrsI\n\n\nTransverse Mercator ala Snyder\n\n\n\n\n\n\nCSkrovkS\n\n\nCSkrovkF\n\n\nCSkrovkI\n\n\nKrovak Oblique Conformal Conic\n\n\n\n\n\n\nCSnerthS\n\n\nCSnerthF\n\n\nCSnerthI\n\n\nNon-georeferenced coordinate system\n\n\n\n\n\n\nCSsys34S\n\n\nCSsys34F\n\n\nCSsys34I\n\n\nDanish System 34\n\n\n\n\n\n\nCSunityS\n\n\nCSunityF\n\n\nCSunityI\n\n\nUnity (pseudo projection)\n\n\n\n\n\n\n\n\nInverse Functions\n\n\nSimilarly, there exists for each projection an inverse function, responsible for converting coordinate system coordinates to latitudes and longitudes. A pointer to such function is inserted into the \ncs2ll\n element of the \ncs_Csprm_\n structure by the setup function, and these functions require a pointer to the setup parameters calculated by the setup function.\n\n\nScale Funcions\n\n\nThe Coordinate System Mapping Package also includes the ability to determine the grid scale factor of a coordinate system at any point. In many cases there is an analytical formula which produces the desired results. Since analytical formulas for the grid scale factor for all thirty eight projections could not be found, the grid scale factor is determined empirically for some projections using the latitude/longitude azimuth and distance calculation function \nCS_llazdd\n.\n\n\n\n\n\n\n\n\nK Scale Function\n\n\nH Scale Function\n\n\nConvergence Function\n\n\nProjection\n\n\n\n\n\n\n\n\n\n\nCStrmerK\n\n\nnone\n\n\nCStrmerC\n\n\nTransverse Mercator\n\n\n\n\n\n\nCSlmbrtK\n\n\nnone\n\n\nCSlmbrtC\n\n\nLambert Conformal Conic\n\n\n\n\n\n\nCSoblqmK\n\n\nnone\n\n\nCSoblqmC\n\n\nHotine Oblique Mercator\n\n\n\n\n\n\nCSalberK\n\n\nCSalberH\n\n\nCSalberC\n\n\nAlber's Equal Area Conic\n\n\n\n\n\n\nCSmrcatK\n\n\nnone\n\n\nCSmrcatC\n\n\nMercator\n\n\n\n\n\n\nCSmillrK\n\n\nCSmillrH\n\n\nCSmillrC\n\n\nMiller Cylindrical\n\n\n\n\n\n\nCSazmedK\n\n\nCSazmedH\n\n\nCSazmedC\n\n\nLambert Equidistant Azimuthal\n\n\n\n\n\n\nCSazmeaK\n\n\nCSazmeaH\n\n\nCSazmeaC\n\n\nLambert Equal Area Azimuthal\n\n\n\n\n\n\nCSpstroK\n\n\nnone\n\n\nCSpstroC\n\n\nPolar Stereographic\n\n\n\n\n\n\nCSostroK\n\n\nnone\n\n\nCSostroC\n\n\nOblique Stereographic\n\n\n\n\n\n\nCSsstroK\n\n\nnone\n\n\nCSsstroC\n\n\nSnyder's Oblique Stereographic\n\n\n\n\n\n\nCsedcncK\n\n\nCSedcncH\n\n\nCSedcncC\n\n\nEquidistant Conic\n\n\n\n\n\n\nCSsinusK\n\n\nCSsinusH\n\n\nCSsinusC\n\n\nSinusoidal\n\n\n\n\n\n\nCSplycnK\n\n\nCSplycnH\n\n\nCSplycnC\n\n\nAmerican Polyconic\n\n\n\n\n\n\nCsmodpcK\n\n\nCSmodpcH\n\n\nCSmodpcC\n\n\nModified Polyconic\n\n\n\n\n\n\nCSlmtanK\n\n\nCSlmtanH\n\n\nCSlmtanC\n\n\nLambert Tangential\n\n\n\n\n\n\nCSvdgrnK\n\n\nCSvdgrnH\n\n\nCSvdgrnC\n\n\nVan der Grinten\n\n\n\n\n\n\nCSorthoK\n\n\nCSorthoH\n\n\nCSorthoC\n\n\nOrthographic\n\n\n\n\n\n\nCsgnomcK\n\n\nCSgnomcH\n\n\nCSgnomcC\n\n\nGnomonic\n\n\n\n\n\n\nCSedcylK\n\n\nCSedcylH\n\n\nCSedcylC\n\n\nEquidistant Cylindrical\n\n\n\n\n\n\nCScsiniK\n\n\nCScsiniH\n\n\nCScsiniC\n\n\nCassini\n\n\n\n\n\n\nCSmstroK\n\n\nnone\n\n\nCSmstroC\n\n\nModified Stereographic\n\n\n\n\n\n\nCSnzlndK\n\n\nnone\n\n\nCSnzlndC\n\n\nNew Zealand National Grid\n\n\n\n\n\n\nCSrobinK\n\n\nCSrobinH\n\n\nCSrobinC\n\n\nRobinson\n\n\n\n\n\n\nCsbonneK\n\n\nCSbonneH\n\n\nCSbonneC\n\n\nBonne\n\n\n\n\n\n\nCSnacylK\n\n\nCSnacylH\n\n\nCSnacylC\n\n\nNormal Aspect, Equal Area (Authalic) Cylindrical\n\n\n\n\n\n\nCStacylK\n\n\nCStacylH\n\n\nCSnacylC\n\n\nTransverse Aspect, Equal Area (Authalic) Cylindrical\n\n\n\n\n\n\nCsmolwdK\n\n\nCSmolwdH\n\n\nCSmolwdC\n\n\nMollweide\n\n\n\n\n\n\nCSekrt4K\n\n\nCSekrt4H\n\n\nCSekrt4C\n\n\nEckert IV\n\n\n\n\n\n\nCSekrt6K\n\n\nCSekrt6H\n\n\nCSekrt6C\n\n\nEckert VII\n\n\n\n\n\n\nCShmlsnK\n\n\nCShmlsnH\n\n\nCShmlsnC\n\n\nGoode Homolosine\n\n\n\n\n\n\nCSbpcncK\n\n\nnone\n\n\nCSbpcncC\n\n\nBipolar Oblique Conformal Conic\n\n\n\n\n\n\nCSswissK\n\n\nnone\n\n\nCSswissC\n\n\nSwiss Oblique Cylindrical\n\n\n\n\n\n\nCStrmrsK\n\n\nnone\n\n\nCStrmrsC\n\n\nTransverse Mercator ala Snyder\n\n\n\n\n\n\nCSkrovkK\n\n\nnone\n\n\nCSkrovkC\n\n\nKrovak Oblique Conformal Conic\n\n\n\n\n\n\nCSnerthK\n\n\nnone\n\n\nCSnerthC\n\n\nNon-georeferenced coordinate system; scale is always 1.0, convergence is always zero.\n\n\n\n\n\n\nCSsys34K\n\n\nnone\n\n\nCSsys34C\n\n\nDanish System 34 (believed to be conformal, but this is not a sure thing)\n\n\n\n\n\n\nCSunityK\n\n\nnone\n\n\nCSunityC\n\n\nUnity\n\n\n\n\n\n\n\n\nAs mentioned above, for non-conformal projections, there are two scale factors, K and H. Therefore, for all thirty eight projections, there exists a K function, and for all non-conformal projections there exists an H function. A pointer to the appropriate function is inserted into the cs_Csprm_ structure by the setup function and, as you might expect, each of these functions requires a pointer to the projection parameters as calculated by the setup function.\n\n\nRefer to the table above for the names of the K scale functions, i.e. grid scale factor along a parallel, and the H scale functions (i.e. scale along a meridian) for all thirty five projections currently supported. The name of the H function is given as \n for conformal projections. In these cases, the H scale factor is the same as the K scale factor.\n\n\nConvergence Functions\n\n\nFor each projection there exists a function which computes the convergence angle for any point given a coordinate system definition. Refer to the table above for the names of the convergence angle functions for all thirty one projections currently supported. Again, analytical formulas for the convergence angle have not been located for all projections. Therefore, for some projections the convergence angle is determined empirically using the \nCS_llazdd\n function.\n\n\nGeographic Limits Check Functions\n\n\nFor each projection, there exists a function which determines if a given geographic coordinate, great circle, or region is entirely within the mathematical domain of a coordinate system. These functions are named in a manner similar to all other projection functions, but the distinguishing final character is L.\n\n\nFor performance reasons, the actual conversion functions of CS-MAP check the coordinate data they are provided only to the extent necessary to prevent floating point exceptions. The geographic limits function of each projection can be used prior to a conversion to determine if a specific geographic coordinate, great circle defined by two geographic coordinates, or a closed region defined by four or more geographic coordinates is entirely within the mathematical domain of the projection. It is not unusual for applications to know the extents of the data set which is to be converted, and thus the extents only, not each individual coordinate, need be checked. This can provide significant performance advantages.\n\n\nCartographic Limits Check Functions\n\n\nFor each projection, there exists a function which determines if a given cartesian coordinate, line segment, or region is entirely within the mathematical domain of a coordinate system. These functions are named in a manner similar to all other projection functions, but the distinguishing final character is X.\n\n\nFor performance reasons, the actual conversion functions of CS-MAP check the coordinate data they are provided only to the extent necessary to prevent floating point exceptions. The cartesian limits function of each projection can be used prior to a conversion to determine if a specific cartesian coordinate, line defined by two cartesian coordinates, or a closed region defined by four or more cartesian coordinates are entirely within the mathematical domain of the projection. It is not unusual for applications to know the extents of the data set which is to be converted, and thus the extents only, not each individual coordinate, need be checked. This can provide significant performance advantages.\n\n\nGeodetic Datum Shift Functions\n\n\nThe methods/functions associated with geodetic datum shifts are not nearly as well organized as those of cartographic projections. This is the result of many different governmental agencies solving the problem independently and relying on different data sets and calculation techniques. However, the basic functions involved in the most generalized techniques are described in the following sub- sections.\n\n\nNADCON Emulation Functions\n\n\nFour lower level functions can be used to perform NAD27 to NAD83 conversions. Use \nCSnadInit\n to initialize the system, and \nCSnadCls\n to release all resources absorbed by \nCS_nadinit\n.\n\n\nOnce \nCSnadInit\n has been called, \nCSnad27ToNad83\n can be called to convert geographic coordinates from NAD27 to NAD83. \nCSnad83ToNad27\n can be used to convert NAD83 to NAD27. Its that simple.\n\n\nDatum Conversion Functions\n\n\nThe basic technique used for NAD83 and HARN described in previous sections is used for several other datums now defined worldwide. In the descriptions given below, you will see how this technique applies to AGD66; the Geodetic Datum of Australia of 1966. A similar pattern exists for the following datums and descriptions of these inidividual sets of functions will not be repeated in this section of the manual. In the future, there are likely to be a lot more of these.\n\n\n\n\n\n\n\n\nAbbreviated Name\n\n\nFull Name\n\n\n\n\n\n\n\n\n\n\nAGD66\n\n\nAustralian Geodetic Datum of 1966\n\n\n\n\n\n\nAGD84\n\n\nAustralian Geodetic Datum of 1984\n\n\n\n\n\n\nGDA94\n\n\nGeocentric Datum of Australia, 1994\n\n\n\n\n\n\nNZGD49\n\n\nNew Zealand Geodetic Datum of 1949\n\n\n\n\n\n\nNZGD2K\n\n\nNew Zealand Geocentric Datum of 2000\n\n\n\n\n\n\nATS77\n\n\nAverage Terrestrial System of 1977\n\n\n\n\n\n\nCSRS\n\n\nCanadian Spatial Reference System\n\n\n\n\n\n\n\n\nFour lower level functions can be used to convert coordinates from AGD66 to GDA94. Use \nCSagd66Init\n to initialize the system, and \nCSagd66Cls\n to release all resources absorbed by \nCSagd66Init\n.\n\n\nOnce \nCSagd66Init\n has been successfully called, \nCSagd66ToGda94\n can be used to convert geographic coordinates from AGD66 to GDA94. Similarly, \nCSgda94ToAgd66\n can be used to convert geographic coordinates from GDA94 to AGD66.\n\n\nGeneral Utility Functions\n\n\nSupporting the generalized coordinate conversions described in the previous sections, are several functions which perform calculations which are quite useful to the GIS/GPS/Mapping application programmer. Several (but probably not all) of these are described in the following sub-sections.\n\n\nGEOID Height Functions\n\n\nThis facility enables applications to calculate and use, as appropriate, the geoid height (or geoid separation if you prefer) at locations for which data is available. Record the data files available, and desired to be used, in the Geodetic Data Catalog file named \nGeoidHeight.gdc\n.\n\n\nThis implementation emulates C++, but is written in ANSI compliant C. The functions are named: \nCSnewGeoidHeight\n, \nCSdeleteGeoidHeight\n, and \nCScalcGeoidHeight\n; and are defined in the module named \ncs_GeoidHeight.c\n. Code specific to geoid height file formats can be found in modules named: \nCS_geoid96.c\n, \nCS_geoid99.c\n, \nCS_bynFile.c\n, and \nCS_osgm91.c\n. Low level applications may wish to access the functions defined in these modules directly.\n\n\nNote there is no inverse function, as it is unnecessary. To obtain orthometric height at a given location, add the geoid height returned by \nCScalcGeoidHeight\n to the ellipsoid height. To calculate the ellipsoid height, subtract the geoid height returned by \nCScalcGeoidHeight\n from the orthometric height.\n\n\nGeocentric Coordinates\n\n\nConverting between geographic and geocentric coordinates has been inside of CS-MAP for many years. However, this capability has been hidden inside of the datum conversion functions. In this release, this capability is now explicitly available in functions named \nCS_llhToXyz\n and \nCS_xyzToLlh\n which are defined in the \nCS_dtCalc.c\n module.\n\n\nNote that each of these functions requires the definition of the ellipsoid in use, expressed as two separate double arguments: equatorial radius and eccentricity squared.\n\n\nMGRS Implementation\n\n\nRelease 11.01 includes a series of new functions that provide the ability to generate MGRS designations from geographic coordinates, and vice versa. This implementation consists of 6 functions designed for application programmer use, and two supporting functions. The support functions may be of interest as they provide the ability to convert between geographic and UTM coordinates/zone number where the rather strange stuff which goes on in northern Europe (i.e. southern Norway and the Svaldberg Islands) is appropriately accounted for.\n\n\nWhile written in 'C' to be consistent with the rest of CS-MAP, the implementation of the MGRS capability has a definite C++ structure to it. That is, there exists a structure definition, three constructors, a destructor, two public functions and two private functions (i.e. the supporting functions).\n\n\nMGRS Constructors\n\n\nConstruction of a \ncs_Mgrs_\n object (i.e. allocation and initialization of a a \ncs_Mgrs_\n structure) requires knowledge of the ellipsoid definition to be used and if the alternative lettering sequence (i.e. Bessel) is to be used. Thus, the three constructors simply provide three different ways of specifying the ellipsoid which is to be used:\n\n\n struct cs_Mgrs_ *CSnewMgrs (double e_rad,double e_sq,short bessel);\n struct cs_Mgrs_ *CSnewMgrsE (const char *elKeyName,short bessel);\n struct cs_Mgrs_ *CSnewMgrsD (const char *dtKeyName,short bessel);\n\n\n\n\nwhere the \nelKeyname\n argument can be used to specify the ellipsoid by key name. Alternatively, application programmers can specify a datum name (the \ndtKeyName\n argument) and the calculations will be based on the ellipsoid upon which the datum is referenced. Of course, the application programmer can use the \ne_rad\n and \ne_sq\n version to specify the equatorial radius and square of eccentricity directly. In all cases, the \nbessel\n argument is zero to indicate the normal lettering scheme. +1 to indicate the alternative lettering scheme.\n\n\nAll constructors return the null pointer in the event of an error. Use \nCS_errmsg\n to obtain a string that describes the nature of the error.\n\n\nMGRS Destructor\n\n\nUse \nCSdeleteMgrs\n to delete a \ncs_Mgrs_\n object constructed by one of the constructors. Currently, a call of \nCS_free\n will accomplish the same thing, but maybe not in the future.\n\n\nvoid CSdeleteMgsr (struct cs_Mgrs_ * __This);\n\n\n\n\nLike it's C++ equivalent, this function is smart enough not to attempt to free a null pointer.\n\n\nMGRS Public Functions\n\n\nNaturally enough, two conversion functions exists. Given a properly initialized \ncs_Mgrs_\n object (i.e. structure) and a geographic coordinate, \nCScalcMgrsFromLl\n will return the appropriate MGRS designation. \nCScalcLlFromMgrs\n reverses the process. In both cases, a return value of zero indicates success, non-zero indicates failure. Use \nCS_errmsg\n to obtain a description of the cause of failure.\n\n\nint CScalcMgrsFromLl (struct cs_Mgrs_ *__This, char *result, int size, double latLng [2], int prec);\nint CScalcLlFromMgrs (struct cs_Mgrs_ *__This,double latLng [2], Const char *mgrsString);\n\n\n\n\nIn these prototypes, the first argument is a pointer to an initialized \ncs_Mgrs_\n object obtained from one of the constructors described above. The \nlatLng\n argument refers to an array of at least two doubles which contain the longitude and latitude (in that order) in degrees. The \nprec\n argument indicates the number of digits to be included in the resulting MGRS designation. Valid values range from 0 to 5. Note, that a value of 5 indicates that 5 easting, and 5 northing digits will be included in the resulting string. Of course, \nCScalcMgrsFromLl\n will never write more than \nsize\n characters to the result array, and (assuming \nsize\n is greater than zero) will cause result to be null terminated.\n\n\nMGRS Private Functions\n\n\nTwo \"private\" functions, i.e. internal support functions, exist which convert geographic coordinates to UTM/UPS coordinates and zone number. These functions are aware of the missing/widened zones in the northern Europe region. They are also capable of switching between UTM and UPS (Universal Polar Stereographic) coordinates as appropriate. These functions use a \nutmZone\n variable which carries the UTM zone number where: 1) northern UTM zones are positive numbers between 1 and 60 inclusive, 2) southern UTM zones are negative numbers between \u20131 and \u201360 inclusive, 3) +61 refers to the North Pole UPS zone, 4) \u201361 refers to the South Pole UPS Zone,, and 5) the value zero is invalid and used to indicate an error condition.\n\n\nint CScalcUtmUps (struct cs_Mgrs_ *__This,double utmUps [2], const double latLng [2]);\nint CScalcLatLng (struct cs_Mgrs_ *__This,double latLng [2], const double utmUps [2], int utmZone);\n\n\n\n\nGiven a geographic coordinate, \nCScalcUtmUps\n calculates the appropriate UTM/UPS coordinates and returns the appropriate \nutmZone\n value. Given a UTM/UPS coordinate and \nutmZone\n value, \nCScalcLatLng\n returns the appropriate geographic coordinate. \nCScalcLatLng\n returns zero on success, non-zero on failure. In all cases, the calculation is based on the ellipsoid used to construct the \ncs_Mgrs_\n argument to the function.\n\n\nForward/Inverse Functions\n\n\nThe term Forward/Inverse is a common way of referring to what is also known as the basic geodesy problem. That is, given a geodetic latitude/longitude, calculate the a new position given an azimuth and distance. This may sound pretty simple, but the calculation must be carried out on the ellipsoid. Thus the calculation is rather complex.\n\n\nForward refers to the calculation of a new geodetic position given an azimuth and a distance. Inverse refers to the calculation of an azimuth and distance given two geodetic positions.\n\n\nCS_llazdd\n performs the forward calculation, and \nCS_azddll\n performs the inverse calculation.\n\n\nError Handling\n\n\nHaving it origins in the 'C' language, error reporting in the CS-MAP library is implemented using the return status methodology. That is, functions which can detect abnormal situations will return an integer status value to indicate the success of the operation intended, Status returns are of two types.\n\n\nWith the exceptions described below, all CS-MAP functions which can detect an abnormal situation will return a zero for success. A negative value will be returned for a failure which is considered fatal, and a non-zero positive value is returned for a warning or providing information about a remarkable condition.\n\n\nWhile fatal errors can and do occur during the setup phase of a conversion/transformation combination, it is an important part of the design of CS-MAP that fatal errors cannot occur with conversion and transformation functions. Thus, any function involved in the creation and/or initialization of a conversion or transformation can be expected to return a negative status value. Functions which actually perform the conversion and/or transformation calculations can be expected to never return a negative status.\n\n\nIn the event of a negative status return, applications should immediately call the CS_errmsg function which will return an (8 bit character, English only) textual description of the cause of the problem. This description will often include, when appropriate, contextual information such as file names etc.\n\n\nStatus return values from calculation functions are always positive and non-zero values usually indicate that the coordinate to be converted is:\n\n\n\n\nOutside the useful range of the coordinate system being used,\n\n\nOutside the coverage area of a grid shift data file,\n\n\nWould have produced a domain error (i.e. log (-1))\n\n\nOr the coordinate is at either pole (which means any longitude is equivalent to any other).\n\n\n\n\nIn any case, the calculation function will indeed return a rational value. In many cases, this rational value will be produced by what is called a fallback technique.\n\n\nIn the experience of the developers of CS-MAP, once a conversion/transformation operation has been successfully constructed (i.e. setup), applications should at most simply count the number of non-zero positive status values returned by the calculation functions and report this number to the user (assuming it is non-zero) upon completion of the conversion. That is, a non-zero status return from any and all calculation functions should be considered as information only. Otherwise, your application will be bogged down and end user's can easily come to the conclusion that your application has crashed.\n\n\nAlso note, that to keep performance levels high, a non-zero positive status return value does not cause the generation of a descriptive error message and calling CS_errmsg after encountering a positive status return will produce misleading information, is anything at all.\n\n\nException\n\n\nThere are several functions in CS-MAP whose function in life is to enumerate a list of entries in internal lists or dictionaries. These functions tend to return a positive 1 value to indicate success. A zero is returned to indicate that the end of the sequence has been encounters. (Of course, a negative return value indicates a fatal error of some sort. This convention was chosen so as to make obtaining such a list or enumeration rather easy to code in a robust manner:\n\n\nint index;\nchar elpName [cs_KEEN_DEC};\n.\n.\n.\nindex = 0;\nwhile (CS_elEnum (index++,eleVate) \n 0)\n{\n  /* Do something with this name */\n  .\n  .\n  .\n}\n\n\n\n\nData Structures\n\n\nDiscussions which follow refer to the primary data structures of CS-MAP. Twelve such data structures are described. These structure provide the basis for the operation of the Coordinate System Mapping Package. All structure definitions are found in the \ncs_map.h\n header file.\n\n\nEllipsoid Definition Structure\n\n\nThe Ellipsoid Definition structure, \ncs_Eldef_\n, carries the two principal data elements (among others) which define an ellipsoid for our purposes. These are the equatorial radius and the eccentricity of the ellipsoid. Among the other items contained in the structure is a key name, which is used to distinguish one ellipsoid definition from another.\n\n\nDatum Definition Structure\n\n\nThe Datum Definition structure, \ncs_Dtdef_\n, carries the eight principal data elements (among others) which define a datum for our purposes. These are the key name of the ellipsoid definition upon which the datum is based, the X, Y, and Z components of the vector from the geocenter of the datum being defined to the geocenter of the WGS84 ellipsoid, the three rotation components of the transformation, and the scale component of the transformation. Among the other elements contained in this structure is a datum key name which is used to distinguish one datum definition from another.\n\n\nDatum Composite Structure\n\n\nThe Datum Composite structure, \ncs_Datum_\n, carries the contents of both the Datum Definition structure and the Ellipsoid Definition structure in an composite form. This structure is never written to disk and is used internally as a programming convenience.\n\n\nCoordinate System Definition Structure\n\n\nThe Coordinate System Definition structure, \ncs_Csdef_\n, carries all the elements required to define a coordinate system. Twenty four of these elements are referred to as projection parameters as their use depends upon the projection in use (which is one of the other data elements). Therefore, it is difficult to describe their use without delving into the specifics of each projection.\n\n\nFor our purposes here, let it be said that the \ncs_Csdef_\n structure is capable of carrying the definition of any coordinate system based on any one of the thirty eight projections supported by CS-MAP and (hopefully) any others which may be added in the future. This includes the parameters specific to the projection, the projection origin, the coordinate system units, the coordinate system scale, the false easting, the false northing, etc.\n\n\nPreprocessed Projection Structures\n\n\nThere exists one structure for each of the thirty eight projections which carry the definition of a coordinate system based on the respective projection in a preprocessed form. That is, once the specific projection parameters applicable to a specific coordinate system are established, there are many calculations which can be performed independent of the specific coordinates to be converted. The results of these calculations are stored in these structures. The thirty five structure names are shown in Table III. It is the content of these structures which actually control the conversion of cartesian coordinates to and from latitudes and longitudes.\n\n\nCoordinate System Parameter Structure\n\n\nThe Coordinate System Parameter Structure, \ncs_Csprm_\n, is used to carry a complete definition of a coordinate system and is the single structure used throughout the development of a coordinate conversion. It contains a copy of the \ncs_Csdef_\n structure of the coordinate system being used, a copy of the \ncs_Datum_\n structure which the coordinate system definition references, and the coordinate system in its pre-processed form as a union of the thirty eight pre-processed parameter structures described above. It also contains pointers to the functions which are capable of performing the forward and inverse coordinate conversions. Pointers are also included for grid scale and convergence angle functions. \ncs_Csprm_\n also includes information about the specific projection in use, as well as the limits of the coordinate system, both in cartesian and geographic form. While CS-MAP is designed such that the application should not need to know anything about the projection, there are instances (such as our own test program) where some knowledge of the projection in use, or its specific features, is helpful.\n\n\nAs a result, this single structure represents a complete definition of a coordinate system which can be easily passed around by pointer. Through the use of pointers to the appropriate coordinate conversion functions contain in this structure, modules which receive a pointer to this structure do not ever have to know exactly which projection is in use in order to perform coordinate conversions.\n\n\nProjection Name Table Structure\n\n\nThe Projection Name Table Structure, \ncs_Prjtab_\n, is used solely to create a table of the projections known to the system. It primarily associates a name with a projection code and a setup function. To add new projections to the system, one need only create an entry in this table and reference the code which, of course, must also be written. You can also add additional names for existing projections by simply making additions to this table.\n\n\nMore importantly, to remove a projection from the system (in order to reduce the size of the text space within an executable, for example), one need simply remove (or comment out) the projection's entry in this table.\n\n\nIn developing a coordinate system parameter structure, the name of the projection is extracted from the coordinate system definition. This name is located in the projection table. The projection setup function associated with the selected named entry is then called and given a pointer to the union of pre- processed structures. The setup function initializes the union as if it were the pre-processed structure associated with the projection under construction. Of course, CS-MAP does all of this, mostly in the function named \nCS_csloc\n.\n\n\nThe Projection Name Table includes a fully descriptive name of each projection as well as a bit map of the features of the projection. Refer to \nCSdataPJ\n.\n\n\nDatum Shift Definition Structure\n\n\nThe Datum Shift Definition structure, \ncs_Dtcprm_\n, carries all of the information necessary to perform a datum shift on geographic coordinates (i.e. latitude and longitude). The information contained in this structure includes the definition of the source and target datums and a road map of the various conversions necessary to get, in the most accurate form, from the source datum to the target datum. This structure is allocated upon request given the definitions of the source and target coordinate systems. Once properly allocated, a pointer to this structure is all that the datum shift function needs in order to calculate datum shifts.\n\n\nThus, applications do not need to have any knowledge of what datums or how many different conversions are necessary to get from one datum to the next. In fact, quite often the conversion is the null conversion which implies that the source latitude and longitude are simply copied to the target array. Again, in this case, the application has no need to know of this situation.\n\n\nThe above is possible only because CS-MAP (to a large extent) requires that all datum definitions define how to convert a specific datum to/from WGS84. Thus, by \"going through\" WGS84 CS-MAP can convert any coordinate system/datum to any other. There are certain exceptions to this basic theme.\n\n\nThe Data Dictionaries\n\n\nThe Coordinate System Mapping Package includes the definition of more than 1,000 commonly used coordinate systems, more than 130 datum definitions, and 37 commonly referenced ellipsoids. These definitions are carried in the Coordinate System Dictionary (a file usually named \nCoordsys\n), the Datum Dictionary (a file usually named Datums), and the Ellipsoid Dictionary (a file usually named \nElipsoid\n) respectively. These files are normally expected to reside in the \nC:\\MAPPING\n directory (\n/usr/MAPPING\n under UNIX). The location of these files can be modified to suit your requirements at compile time (see \nCSdata\n) or at run time (see \nCS_altdr\n). The names of these files can be changed either at run time (see \nCS_csfnm\n, \nCS_dtfnm\n, and \nCS_elfnm\n) or compile time (see \ncs_map.h\n).\n\n\nThe Coordinate System Dictionary\n\n\nThe Coordinate System Dictionary is a fixed length record file of \ncs_Csdef_\n structures, maintained in sorted order by the key_nm element, i.e. the coordinate system key name. Entries in this file are located through the use of the binary search technique, therefore it is important that this file remain in sorted order. The file has a magic number in the first four bytes. This is a sequence of bytes which identify the file as being a Coordinate System Dictionary file and is defined by the \ncs_CSDEF_MAGIC\n manifest constant in \ncs_map.h\n. This value is checked each time the file is opened to make sure that the file is indeed a Coordinate System Dictionary and that it has not been seriously corrupted. The specific value of the magic number is changed each time the format of the \ncs_Csdef_\n structure is changed.\n\n\nFunctions are provided to access and maintain this file as a Coordinate System Dictionary. \nCS_csopn\n will open the file, verify its magic number, and return a file descriptor (or handle). \nCS_csrd\n and \nCS_cswr\n will perform sequential reads from and writes to a file of this type, handling encryption appropriately. \nCS_cscmp\n compares records in the file for sorting and searching purposes. \nCS_csdef\n will extract a particular record from the dictionary for you. \nCS_csupd\n will update an existing entry or add a new entry to the Coordinate System Dictionary, assuring that the file remains in sorted order. Finally, \nCS_csdel\n can be used to delete a record from the dictionary.\n\n\nCoordinate system definitions are verified for validity before they are written to the Coordinate System Dictionary through the use of the \nCS_cschk\n function. \nCS_csloc\n (described below) also checks each definition before it is actually used to create the active form of a coordinate system.\n\n\nThe Datum Dictionary\n\n\nThe Datum Dictionary is a fixed length record file of \ncs_Dtdef_\n structures, maintained in sorted order by the \nkey_nm\n element, i.e. the datum key name. Entries in this file are located through the use of the binary search technique, therefore it is important that this file remain in sorted order. The file has a magic number in the first four bytes of the file and is defined by the \ncs_DTDEF_MAGIC\n manifest constant in \ncs_map.h\n. This is a sequence of bytes which identify the file as being a Datum Dictionary file. This value is checked each time the file is opened to make sure that the file is indeed a Datum Dictionary and that it has not been seriously corrupted. The specific value of the magic number is changed each time the format of the \ncs_Dtdef_\n structure is changed.\n\n\nFunctions are provided to access and maintain this file as a Datum Dictionary. \nCS_dtopn\n will open the file, verify its magic number, and return a file descriptor (or handle). \nCS_dtrd\n and \nCS_dtwr\n will perform sequential reads from and writes to a file of this type, handling encryption appropriately. \nCS_dtcmp\n compares Datum Dictionary entries for sorting and searching purposes. \nCS_dtdef\n will extract a particular record from the dictionary for you. \nCS_dtupd\n will update an existing entry or add a new entry to the Datum Dictionary, assuring that the file remains in sorted order. Finally, \nCS_dtdel\n can be used to delete a record from the dictionary.\n\n\nThe Ellipsoid Dictionary\n\n\nThe Ellipsoid Dictionary is a fixed length record file of \ncs_Eldef_\n structures, maintained in sorted order by the key_nm element, i.e. the ellipsoid name. Entries in this file are located through the use of the binary search technique, therefore it is important that this file remain in sorted order. The file has a magic number in the first four bytes of the file and is defined by the \ncs_ELDEF_MAGIC\n manifest constant in \ncs_map.h\n. This is a sequence of bytes which identify the file as being a Ellipsoid Dictionary file. This value is checked each time the file is opened to make sure that the file is indeed an Ellipsoid Dictionary and that it has not been seriously corrupted. The specific value of the magic number is changed each time the format of the \ncs_Eldef_\n structure is changed.\n\n\nFunctions are provided to access and maintain this file as a Ellipsoid Dictionary. \nCS_elopn\n will open the file, verify its magic number, and return a file descriptor (or handle). \nCS_elrd\n and \nCS_elwr\n will perform sequential reads from and writes to a file of this type, handling encryption appropriately. \nCS_elcmp\n compares Ellipsoid Dictionary entries for sorting and searching purposes. \nCS_eldef\n will extract a particular record from the dictionary for you. \nCS_elupd\n will update an existing entry or add a new entry to the Ellipsoid Dictionary, assuring that the file remains in sorted order. Finally, \nCS_eldel\n can be used to delete a record from the dictionary.\n\n\nDictionary Encryption\n\n\nThe definitions of coordinate systems, datums, and ellipsoids can represent a significant investment on the part of the application developer. Under certain circumstances, a demonstration disk for example, the application developer may not wish to provide this information in a form from which this valuable data can be easily extracted. As a result, CS-MAP fully supports a means by which dictionary data can be encrypted. All CS-MAP functions will work equally as well with encrypted dictionaries as with normal versions. Dictionary compilers normally produce dictionaries in encrypted form. An option is provided to produce unencrypted dictionaries.\n\n\nDictionary Definition Protection\n\n\nDictionary entries are normally protected. That is, changes to coordinate system, datum, and ellipsoid definitions are controlled. This reduces technical support calls significantly. Application programmers can control the extent of protection, or turn it off altogether. How this system works is described below.\n\n\nIn normal operation, CS-MAP will not allow end users to change definitions distributed with the application. More specifically, definitions created by the Dictionary Compiler are marked as to be protected. End users can, and often do, create new coordinate system definitions. Therefore, rather than change a coordinate system as distributed with the application, users would typically create a new definition which is modified as necessary to achieve the desired results.\n\n\nDefinitions created by end users, and which remain unchanged for 60 days, are also protected. This is done under the assumption that a definition which remains unchanged for 60 days will have been used and judged satisfactory, and therefore should be preserved as a means of recording the actual definition used to produce the results.\n\n\nFinally, CS-MAP normally requires that the key names for all user defined definitions contain the colon character. By adopting this convention, application updates can include coordinate system updates without the possibility of the update overwriting a valid and valuable user defined definition. (This, of course, assumes that the distribution will never contain a coordinate system definition with a key name containing a colon character.)\n\n\nApplication programmers can control to what degree the protection system is active by simply setting the value of either, or both, of two global variables, either at compile time (see \nCSdata.c\n) or at run time.\n\n\nchar cs_Unique\n; In the CS-MAP distribution, the value of this global variable is set to the colon. Set the value of this variable to the null character to turn the user definition key name protection feature described above off. You can select a character other than the colon by simply setting this variable to the desired character.\n\n\nshort cs_Protect\n; Use this variable to control the protect applied to dictionary definitions. A positive, non-zero value is the number of days associated with the user defined definition protection described above. For example, in the CS-MAP distribution, this value is set to 60, indicating that after a user defined definition remains unchanged for 60 days, it automatically becomes protected. Set \ncs_Protect\n to zero to maintain distribution coordinate system protection, but disable all user defined definition protection. Set \ncs_Protect\n to a negative value to disable all dictionary definition protection.\n\n\nProgrammer Note\n: Dictionary definitions include a short which controls the protection of the definition. If this value is set to zero, the dictionary entry is permanently unprotected. If this value is set to one, the entry is permanently protected. Otherwise, this value is set to the date at which the definition was last modified expressed as the number of days since January 1, 1990. Thus, changing the value of \ncs_Protect\n will change the protection of user defined definitions in a dynamic manner\n\n\nByte Ordering\n\n\nAll three dictionary files described in this section contain data in binary form, thus byte ordering becomes a serious issue when using CS-MAP on different platforms. Beginning with Release 6.0 of CS-MAP, dictionaries are expected to be in little endian byte order regardless of the platform in use. A byte swapping function, \nCS_bswap\n, is called immediately after each read from any of these dictionaries, and immediately before the write of any data to any of the dictionaries. \nCS_bswap\n is programmed to automatically determine if byte swapping is required based on a compile time constant. Thus, a single copy of these dictionaries can be distributed for use on all platforms.\n\n\nThe term \"all platforms\" is perhaps misleading. \nCS_bswap\n will only swap between little endian and big endian byte orders. The rather odd byte orderings of some older DEC machines is not supported at the current time.\n\n\nThe automatic byte ordering feature is easy to disable if so desired. Refer to \nCS_bswap\n for more information.\n\n\nThe automatic byte ordering feature also applies to all other binary data files upon which CS-MAP relies. That is, automatic byte swapping is applied to all reads from NADCON database files, Multiple Regression data files, Canadian National Transformation files, and all HPGN database files. The choice of using little endian byte ordering was natural as these files are generally distributed by their sources in this form.\n\n\nDictionary Compiler\n\n\nASCII versions of the three dictionaries are provided in the distribution. The names of these files are \nCOORDSYS.ASC\n, \nDATUMS.ASC\n, and \nELIPSOID.ASC\n. Binary versions of the dictionary files can be produced by using the dictionary compiler program \nCS_COMP\n. This enables the definition files to be committed to version control procedures and the dictionaries remade as part of your product manufacturing process.\n\n\nOriginally, the ASCII files and the compilers were provided as a means of overcoming the byte order problem on different platforms. Now that CS-MAP has been modified to process little endian files on all platforms, this purpose is now obsolete. The version control purpose of these files remains valid.\n\n\nMultiple Regression Datum Transformation Files\n\n\nThe compiler referred to above will also compile a fourth ASCII source file named \nMREG.ASC\n which is also supplied in the distribution. \nMREG.ASC\n contains in an ASCII, version controllable form, the definition of all multiple regression transformations known to the system. Compiling this file produces the \n.MRT\n files which CS-MAP accesses, as necessary, when performing datum conversions. Your application distribution should include the \n.MRT\n files produced by compiling the \nMREG.ASC\n file.\n\n\nDefault Datums, Ellipsoids, and Units\n\n\nCS-MAP supports the concept of default datums, ellipsoids, and/or units. Defaults represent a convenient way to switch a coordinate system definition between different datums, ellipsoids, and/or units without having to change the Coordinate System Dictionary. How this feature applies to datums is described first; and this description is then extended to ellipsoids and units.\n\n\nA datum reference in a coordinate system definition may be marked as \"defaultable\" by enclosing the name in square brackets. The actual datum name provided must be a valid datum reference as this reference will be used whenever the default feature is not active. This also implies that the default feature need not be active for the coordinate system definition to be valid and usable.\n\n\nUpon activation of a coordinate system, regardless of the interface used, CS-MAP will check to see if the datum specified is \"defaultable\". If so, it examines the current default datum setting. If a valid default datum has been specified, the \"defaultable\" datum reference is replaced by the current default setting and coordinate system setup continues. If there is no current default setting, the \"defaultable\" datum is used as is. Thus, in the absence of a default specification, the coordinate system definition operates as defined. Whenever a default replacement is performed, the replaced datum name in the \ncs_Csdef_\n element of the \ncs_Csprm_\n structure will be enclosed in parenthesis to indicate that a default replacement has occurred.\n\n\nUse the \nCS_dtdflt\n function to define a default datum. It will return the status and the name of any previous default. It will not allow an invalid default setting to be made. Calling \nCS_dtdflt\n with the \nNULL\n pointer as its argument can be used to determine if the datum default feature is active and, if so, what the current default setting is. Call \nCS_dtdflt\n with a pointer to the null string to disable the datum default feature. Until \nCS_dtdflt\n is called with a valid datum reference, the datum default feature remains disabled.\n\n\nCartographically referenced coordinate systems, and datum definitions, can contain \"defaultable\" ellipsoid references. Use \nCS_eldflt\n to enable and disable the \"defaultable\" ellipsoid feature.\n\n\nCoordinate system unit specifications can also be \"defaultable\". Separate default values are maintained for linear and angular units. Use \nCS_ludflt\n to control the state of linear unit defaults, and \nCS_audflt\n to control the state of angular unit defaults.\n\n\nYou can completely ignore this concept of default datums, ellipsoids, and units by simply not calling (or even referencing) any of the default functions mentioned above. Default processing is off by default, and by never calling any of these functions, it never gets turned on. This is how most users deal with the default feature.\n\n\nHigh Performance Interface\n\n\nThe High Performance Interface to the Coordinate System Mapping Package consists of thirteen functions. By virtue of the data structures described above, use of these functions is independent of the actual coordinate systems, projections, or datums in use. This represents the most efficient means to use CS-MAP to convert coordinates from one coordinate system to another. It also insulates your applications from most changes which could be made to the CS-MAP in the future. This basic API has not changed since 1992. This interface requires the use of structure pointers and, therefore, may not be appropriate for use with some languages. Therefore, use this interface wherever high performance is a top priority and the application is written in a language which can handle pointers such as C, C++, or Pascal.\n\n\nThese functions make use of the Coordinate System Dictionary, the Datum Dictionary, the Ellipsoid Dictionary, and the functions which access them. This need not be of concern to the application programmer using the High Performance Interface as it all goes on \"behind the scenes\".\n\n\nIn this section, our intent is to associate function names with capabilities and features.\n\n\nThe Functions\n\n\nThe thirteen functions which comprise the High Performance Interface are \nCS_csloc\n, \nCS_dtcsu\n, \nCS_ll2cs\n, \nCS_dtcvt\n, \nCS_cs2ll\n, \nCS_dtcls\n, \nCS_csscl\n, \nCS_cnvrg\n, \nCS_cssch\n, \nCS_cssck\n, \nCS_llchk\n, \nCS_xychk\n, and \nCS_free\n. The typical coordinate conversion application uses only seven of these function.\n\n\nRefer to the major sections following this to see how the use of these functions is combined to produced generalized coordinate conversion capabilities.\n\n\nCoordinate System Locate\n\n\nGiven the key name of a coordinate system defined in the Coordinate System Dictionary, \nCS_csloc\n returns a pointer to a fully initialized \ncs_Csprm_\n structure. This initialization includes all of the \"one- time\" calculations and the establishment of pointers to the appropriate coordinate conversion functions. This structure is \nmalloc\n'ed from dynamic memory. Therefore, you may have several such definitions active at any given time. Also, you should release these structures when your application no longer has need of them; use \nCS_free\n.\n\n\nDatum Conversion Setup\n\n\nGiven pointers to the both the source and target coordinate systems as returned by \nCS_csloc\n, \nCS_dtcsu\n returns a pointer to a \nmalloc\n'ed \ncs_Dtcprm_\n structure which is a required argument to the \nCS_dtcvt\n function which actually calculates datum shifts. As its name implies, \nCS_dtcsu\n \"sets up\" a datum conversion by allocating and initializing a \ncs_Dtcprm_\n structure. Since datum conversions often require the use of file descriptors, grid cell caches, and the like, do not use \nfree\n or \nCS_free\n to release the \ncs_Dtcprm_\n structure returned by \nCS_dtcsu\n. The sixth function of this interface, \nCS_dtcls\n must be used instead to prevent memory and file descriptor leaks in your application. Note, when appropriate, \nCS_dtcsu\n returns a pointer to a null datum conversion; a conversion which does nothing successfully and rapidly.\n\n\nCoordinate System to Lat/Long Conversion\n\n\nGiven a pointer to an initialized \ncs_Csprm_\n structure which describes the coordinate system in use, the \nCS_cs2ll\n function will convert a cartesian coordinate to geographic form in terms of latitude and longitude in internal form. The resulting geographic coordinate will be based on the same datum as the coordinate system defined in the provided \ncs_Csprm_\n structure.\n\n\nThe conversion function pointers inserted into the \ncs_Csprm_\n structure by \nCS_csloc\n are used to select the proper code for the conversion. The application has no need to know what projection is in use or, for that matter, anything else about the coordinate system in use\n\n\nDatum Conversion\n\n\nGiven a pointer to an initialized datum conversion parameter structure, \ncs_Dtcprm_\n, as returned by \nCS_dtcsu\n, the \nCS_dtcvt\n function will convert the supplied geographic coordinates from the source datum to the target datum.\n\n\nLat/Long to Coordinate System Conversion\n\n\nGiven a pointer to an initialized \ncs_Csprm_\n structure, the \nCS_ll2cs\n function will convert a geographic coordinate specified in terms of latitude and longitude (in degrees) to the coordinates of the coordinate system defined by the \ncs_Csprm_\n structure.\n\n\nThe conversion function pointers inserted into the \ncs_Csprm_\n structure by \nCS_csloc\n are used to select the proper code for the conversion. The application has no need to know what projection is in use or, for that matter, anything else about the coordinate system in use.\n\n\nClose Datum Conversion\n\n\nGiven a pointer to an initialized datum conversion parameter structure, as returned by the \nCS_dtcsu\n function, \nCS_dtcls\n will release all system resources allocated for the specific datum conversion. Note, that since several datum conversions may be initialized and operative at any given time, \nCS_dtcls\n does not necessarily release all resources associated with certain datum transformations until such time as the last datum conversion parameter block referencing such resources is closed.\n\n\nGrid Scale Factor\n\n\nGiven a pointer to an initialized \ncs_Csprm_\n structure as returned by the \nCS_csloc\n function, \nCS_csscl\n will return the grid scale factor for the coordinate system at a location indicated by a geographic coordinate. It is important to note that the concept of Grid Scale as a single number applies only to coordinate systems based on conformal projections such as the Transverse Mercator, Lambert Conformal Conic, and the Oblique Mercator. Other projections, such as equal area projections, will have two such scale factors. In the case of equidistant projections, there are two such scale factors but one of them will usually be one. In the case on non-conformal projections, \nCS_csscl\n will return what the designers of CS-MAP consider the more interesting of the two scale factors for the specific projection involved.\n\n\nScale Along a Parallel\n\n\nThe two scale factors mentioned above consist of the scale along a parallel, often referred to as 'k', and the scale along a meridian, referred to as 'h'. Given a pointer to an initialized \ncs_Csprm_\n structure as returned by \nCS_csloc\n, \nCS_cssck\n will always return the scale factor along a parallel at the location provided.\n\n\nThe nomenclature referred to here is that used by J. P. Snyder in \nMap Projections - A Working Manual\n. Other authors use different symbology. In his later work, \nMap Projections - A Reference Manual\n, Snyder uses the more common notation. CS-MAP, whose origins date back to 1987, uses the original Snyder notation.\n\n\nScale Along a Meridian\n\n\nGiven a pointer to an initialized \ncs_Csprm_\n structure, \nCS_cssch\n returns the scale along a meridian, often referred to as 'h', at the location given by its second argument which must be a geographic coordinate.\n\n\nConvergence Angle\n\n\nGiven a pointer to an initialized \ncs_Csprm_\n structure as returned by \nCS_csloc\n, \nCS_cnvrg\n returns the convergence angle of the coordinate system, at the location indicated by the second argument which must be a geographic coordinate. The return value is in degrees; positive is east of north.\n\n\nCheck Limits, Geographic\n\n\nGiven a pointer to an initialized \ncs_Csprm_\n structure as returned by \nCS_csloc\n, \nCS_llchk\n will determine if all coordinates in the list provided are within the mathematical domain of the coordinate system and/or with the useful range of the coordinate system. In the case where the provided list contains two or more points, the determination applies to each coordinate on each great circle arc formed by consecutive geographic coordinates. In those cases where the provided coordinate list consists of four or more geographic coordinates which define a closed region, the determination applies to all coordinates enclosed within the region, or which reside the provided boundary.\n\n\nCheck Limits, Cartesian\n\n\nGiven a pointer to an initialized \ncs_Csprm_\n structure as returned by \nCS_csloc\n, \nCS_xychk\n will determine if all coordinates in the list provided are within the mathematical domain of the coordinate system and/or with the useful range of the coordinate system. In the case where the provided list contains two or more points, the determination applies to each coordinate on each line segment formed by consecutive cartesian coordinates. In those cases where the provided coordinate list consists of four or more cartesian coordinates which define a closed region, the determination applies to all coordinates enclosed within the region, or which reside on the provided boundary.\n\n\nFree Coordinate System Parameters\n\n\nUse \nCS_free\n to free memory allocated by the any CS-MAP functions. This function is to be used, for example, to free the coordinate system parameter block returned by \nCS_csloc\n. It is important that CS_free be used as in certain environments (a Windows DLL for example), the heap used by the library is not necessarily the same as the heap used by the application. Thus, if CS-MAP allocated the memory, it is best if CS-MAP releases it also.\n\n\nCoordinate System to Coordinate System\n\n\nIn order to convert from one coordinate system to another, one simply obtains, from the \nCS_csloc\n function, a definition of the two coordinate systems of concern. The inverse function, \nCS_cs2ll\n, is used to convert the source coordinates to latitude and longitude and the forward function, \nCS_ll2cs\n, is used to convert to the target coordinate system. The sample code segment shown is, for example, all the code necessary to convert a file of NAD27 based UTM Zone 13 (UTM27-13) coordinates to NAD27 based Colorado State Plane, Southern Zone (CO-S). To change the conversion to use other coordinate systems, only the names provided to the \nCS_csloc\n function need be changed. Of course, these strings are rarely hard coded as has been done in this example.\n\n\nint input, output;\ndouble xy [2], ll [2];\nstruct cs_Csprm_ *utm, *co_s;\nutm = CS_csloc (\nUTM27-13\n);\nco_s = CS_csloc (\nCO-S\n);\nwhile (read (input, xy, sizeof (xy)) != 0)\n{\n   CS_cs2ll (utm,ll,xy);\n   CS_ll2cs (co_s,xy,ll);\n   write (output,xy,sizeof (xy));\n}\nCS_free (utm);\nCS_free (co_s);\n\n\n\n\nThe LL Coordinate System\n\n\nMany products will use the above scheme to provide the ability to convert from any coordinate system to any another. This scheme is completely general, supporting any combination of coordinate systems. Sometimes, however, it is desirable to convert from or to geographic coordinates. The \nLL\n coordinate system and the Unity projection accommodate this within the general scheme of things described above. That is, the \nLL\n coordinate system is simply a coordinate system in which the coordinates are latitudes and longitudes, and the Unity projection is simply a set of conversion functions which do little other than possible units and prime meridian conversion.\n\n\nTherefore, supplying a coordinate system name of \nLL\n, for example, for either the input or output coordinate system will produce the desired results without the application program having to know about this specific situation. (Please note that \nLL\n is a cartographically referenced coordinate system. Coordinate systems \nLL27\n and \nLL83\n are usually used in practice.)\n\n\nLatitude and longitude coordinates in different units or referenced to a prime meridian other than Greenwich are possible by defining different \nLL\n type coordinate systems. These definitions, all based on the Unity pseudo-projection, can include a units specification and a specification of a prime meridian other than zero (i.e. Greenwich).\n\n\nMultiple Conversions\n\n\nPlease note, that since coordinate system definitions (as returned by \nCS_csloc\n) reside in \"heap\" memory, there is no practical limit as to the number of definitions which can be active at any given time. Therefore, using the three functions described above, several different coordinate conversions can be active at the same time.\n\n\nAdding Datum Conversions to the Interface\n\n\nDatum conversions can be added to the basic scheme described above by adding calls to the datum conversion functions. Refer to the code given below for an example, paying special attention to the emphasized code. Once the two coordinate system definitions have been initialized, they are passed to \nCS_dtcsu\n. By examining both the source and target coordinate system definitions, \nCS_dtcsu\n is able to determine which, if any, datum transformation techniques need to be applied to accomplish the desired conversion. \nCS_dtcsu\n will select one or more datum conversions as necessary to accomplish the desired conversion. For example, to convert from NAD27 to WGS72, three conversions are actually setup:\n\n\n\n\nfrom NAD27 to NAD83 via the NADCON technique\n\n\nNAD83 to WGS84 (which is currently a null conversion), and finally\n\n\nWGS84 to WGS72 using a hard coded formula.\n\n\n\n\nCS_dtcsu\n assures that all preparations necessary for these conversions are initialized, and saves the results in the \ncs_Dtcprm_\n structure to which it returns a pointer.\n\n\nIn the actual coordinate conversion loop, \nCS_dtcvt\n is called for each coordinate once its geographic form has been obtained from \nCS_cs2ll\n. Note that if \nCS_dtcsu\n determined that no datum conversion was required, the information contained in the \ncs_Dtcprm_\n structure which it returns causes \nCS_dtcvt\n to simply copy the source geographic coordinates to the target array. Finally, when the conversion process is complete, \nCS_dtcls\n is used to release any system resources which were allocated for the datum conversion and which are no longer needed.\n\n\nint input, output;\ndouble xy [2], ll [2];\nstruct cs_Csprm_ *utm, *co83_s;\nstruct cs_Dtcprm_ *dtc_ptr;\n.\n.\nutm = CS_csloc (\nUTM27-13\n);\nco83_s = CS_csloc (\nCO83-S\n);\ndtc_prm = CS_dtcsu (utm,co83_s,dat_err,blk_err);\n\nwhile (read (input,xy,sizeof (xy)) != 0)\n{\n   CS_cs2ll (utm,ll,xy);\n   CS_dtcvt (dtc_prm,ll,ll);\n   CS_ll2cs (co83_s,xy,ll);\n   write (output,xy,sizeof (xy));\n}\n\nCS_dtcls (dtc_prm);\nCS_free (utm);\nCS_free (co_s);\n\n\n\n\nGeodetically Referenced Coordinate Systems\n\n\nIn the normal case, CS-MAP converts from one geodetically referenced system to another. In the sample code segment in the previous topic, for example, \nUTM27-13\n is referenced to \nNAD27\n and \nCO83-C\n is referenced to \nNAD83\n. The need for NAD27 to NAD83 conversion is unambiguous and performed automatically by CS-MAP's High Performance Interface without the application having to know of this situation. However, there are circumstances where a coordinate system cannot be referenced to a specific datum. For example, what datum should UTM zone 25 (middle of the Atlantic Ocean) be referenced to?\n\n\nFor various reasons, it is not always possible or convenient to reference a coordinate system to a specific datum. To handle such cases, CS-MAP supports the concept of a cartographically referenced coordinate system.\n\n\nCartographically Referenced Coordinate Systems\n\n\nThe \ncs_Csdef_\n structure, which carries the definition of all coordinate systems, has an ellipsoid key name element as well as a datum key name element. If the datum key name element is not the null string, the coordinate system is said to be geodetically referenced. If the datum key name element is the null string, the ellipsoid key name element must then carry the key name of an ellipsoid definition in the ellipsoid dictionary. In this case, the coordinate system is said to be cartographically referenced. (If both elements are not the null string, the ellipsoid key name field is ignored.)\n\n\nThe example shown previously in this section showed how conversions are performed between two geodetically referenced systems. If either of the two coordinate systems involved is cartographically referenced, or if both are cartographically referenced, \nCS_dtcsu\n simply returns the null datum conversion. Thus, for example, when the target coordinate system is cartographically referenced, the resulting coordinates are based on the source datum, whatever it may happen to be. Similarly, if the source is cartographically referenced and the target is geodetically referenced, there is an implied assumption that the source coordinates are based on the datum of the target. If both coordinate systems are cartographically referenced, we have no knowledge of the datums in either case and the conversion is strictly cartographic, hence the semantic convention adopted here.\n\n\nExamination of the \nCOORDSYS.ASC\n file will produce several cartographically referenced coordinate systems. Many of these are UTM zones in areas other than the US and Canada. (In the US and Canada, UTM zones can be reliably said to be based on either NAD27 or NAD83.) Perhaps the most important cartographically referenced coordinate system is that which is named LL. This enables us to use the LL coordinate system to convert generic Lat/Long's to any coordinate system, or convert any coordinate system to Lat/Long's based on the same datum as the source, what ever it might be.\n\n\nCartographic Projections\n\n\nFor each projection supported, there exist eight, possibly nine, functions which comprise the full implementation of a projection. The brief description of these functions is given below. These descriptions will be important to those adding a new projection as well.\n\n\nThose adding projections to the system only need to add an entry to the projection table \ncs_Prjtab\n. Doing so, you will need to add a pointer to the Definition Check and the Setup functions. To activate the proper parameter settings in the MFC dialog, you will also need to add the projection to the \ncs_PrjprmMap\n table. It is unlikely, but if your new projection uses a new type of parameter, you may need to add a new entry to the \ncs_Prjprm\n table. All of these tables are defined in the \nCSdataPJ.c\n module.\n\n\nProgram Environments\n\n\nPortability to a large variety of program environments is a major feature of CS-MAP. Thus, programmers accustomed to a single environment may consider some of the code and design of CS- MAP rather awkward or old fashioned. Nevertheless, by keeping things very basic and simple (e.g. binary searching a sorted fixed length record file), CS-MAP ports to just about any other environment without change and without requiring any additional software beyond the contents of a normal C runtime library.\n\n\nHowever, simplicity is insufficient to cover the entire range of issues. In this section we discuss features and aspects of CS-MAP which are specifically intended for differing program environments.\n\n\nMulti-Threaded Programming\n\n\nBeginning with release 8.0, CS-MAP is fully compatible with multi-threaded Windows environments. Threads are different from processes in that not only do they share their parents code space, the data space is also shared. Since CS-MAP uses several global variables, this presents a problem.\n\n\nThis problem is addressed by declaring each of the several dynamically used (i.e. non-constant) global variables to be (using the Microsoft vernacular) \n__declspec\n (thread). (In the Borland vernacular, its \n__thread\n.) This causes each new thread to have it's own copy of these variables; but the initialization of these variables upon starting a new thread is unclear. In any case, we do count on the operating system being able to give us a separate copy of all of these variables for each new thread instance which is started.\n\n\nIn order to insure that each of these variables is properly initialized, we have provided the function named \nCS_init\n. It should be called in each new thread just once, prior to any other CS-MAP function call in the thread. If the parent thread's value of the global \ncs_Dir\n and \ncs_DirP\n variables are valid, these values are preserved. If not they are initialized. In the case of several other variables, such as defaults, the application programmer may specify if these are to be inherited from the parent thread. Variables dealing with NAD27 to NAD83 datum conversions and the like are always initialized to the NULL state.\n\n\nThus, each thread will have its own set of NADCON data file buffers. In certain applications, this may be wasteful, but in most cases this provides the highest performance. Otherwise, we would be wasting considerable resources with resource locks etc.\n\n\nUNIX users need not fear. All declarations and definitions in the CS-MAP code where the \n__declspec\n (thread) or \n__thread\n are appropriate are accomplished using the manifest constant \nThread\n defined in the CS-MAP header file. This constant is defined to be nothing in most cases. Only in the event that compiler pre-defined constants indicate a multi-thread environment (i.e. \n_MT\n), is \nThread\n defined to be something other than nothing. None of this applies if you are building a DLL. In a DLL, there is a single data segment, and multi-threading has no effect.\n\n\nGUI Considerations\n\n\nCS-MAP supports a graphic user interface based on Microsoft's MFC library. This is, admittedly, non portable but does provide useful product capability for a large percentage of our clients. Use of these functions requires that you include the \ncsmap.rc\n file into your projects resources. This can be accomplished by adding an include \ncsmap.rc\n statement to your project's \n.rc2\n file. Please note that the use of these functions implies that your application activates the basic infrastructure of the MFC library. Accessing the functions in an isolated application does not work without special effort. Also note, that MFC is a multi-threaded environment. You will need to compile the CS-MAP library using the multi-threaded options to eliminate frustrations generated by the Microsoft linker.\n\n\nThe \nCS_csEditor\n function causes activation of the coordinate system editor. Similarly, the \nCS_dtEditor\n and \nCS_ellEditor\n functions cause the activation of the datum and ellipsoid editors respectively. In all three cases, the functions require a single input and return a single result. The input is the key name of the definition which is to be initially displayed. The result is the key name that was displayed when the user caused the dialog to exit. All other user activity is recorded in the appropriate dictionary.\n\n\nThe \nCS_csBrowser\n function activates a coordinate system browser and can be used to obtain a coordinate system key name from the user. The \nCS_csDataDr\n function displays a dialog which enables the user to specify the directory in which the mapping data files reside.\n\n\nCustomization\n\n\nSome users will, no doubt, require modification to the basic capabilities of the Coordinate System Mapping Library as provided by OSGeo. The following sections describe how some of the more common requirements can be accomplished with a minimum of effort.\n\n\nTuning the Protection System\n\n\nAs distributed, CS-MAP will not allow users to modify or delete a dictionary definition which is produced by the dictionary compiler; i.e. a distribution definition. Further, CS-MAP will not permit modification or deletion of a user defined coordinate system after such definition has remained unaltered for 60 days. The behavior of this feature is controlled by the \ncs_Protect\n global variable, an int defined in the \nCSdata\n module. You can change the value of this variable in \nCSdata\n and recompile, or at run time.\n\n\nSetting \ncs_Protect\n to a negative value disables all of the above described protection features. Setting \ncs_Protect\n to zero enables distribution coordinate system protection, but disables the user defined protection system. Setting \ncs_Protect\n to a positive value enables the user definition protection feature, and also specifies the number of days which must elapse from the last modification before the definition is protected.\n\n\nTurning of Unique Names\n\n\nAs distributed, CS-MAP requires that a colon appear in all dictionary definition key names. By doing so, CS-MAP guarantees that the names of all user definitions will be different from any definition which may be contained in a future distribution of CS-MAP. You can disable this feature of CS-MAP by setting the global char variable named \ncs_Unique\n to the null character (i.e. \n'\\0'\n). Alternatively, you can enable this feature using a different character by setting the value of \ncs_Unique\n to that character. \ncs_Unique\n is defined in the \nCSdata\n module and be set at compile time or run time.\n\n\nEliminating a Projection\n\n\nIf you do not have a need for all thirty eight supported projections, you can simply remove from the projection table (defined in \nCSdataPJ\n) the entry which references any projection which you do not need. Doing so will eliminate all references to the code for a specific projection and reduce the code size of your executable.\n\n\nData Dictionary Directory\n\n\nThe directory in which \nCS_csdef\n, \nCS_dtdef\n, and \nCS_eldef\n look for their respective dictionary files is defined in the \nCSdata.c\n module. You must use the \nCS_altdr\n function to initialize this variable to point to the directory which contains all data files. \nCS_altdr\n will use the value of an environmental variable when called with a \nNULL\n pointer as an argument. The name of this environmental variable, \nCS_MAP_DIR\n by default, is established in \ncs_map.h\n as a manifest constant.\n\n\nDictionary File Names\n\n\nThe names assigned to the three dictionary files are defined as manifest constants in the \ncs_map.h\n header file, declared and initialized in the \nCSdata\n module. They can also be modified at run time by using the \nCS_csfnm\n, \nCS_dtfnm\n, and \nCS_elfnm\n function.\n\n\nAdding Units\n\n\nThe units which are recognized by the Coordinate System Mapping Package are defined in the \nCSdataU\n module. You can add or delete as necessary. Note that this table has provisions for an abbreviation in addition to the full name. Use the code as provided as an example of how to incorporate a new unit. Also note that the factor is the multiplier required to change the new unit to meters, or degrees, by multiplication depending upon the type of unit.\n\n\nLanguage Translation\n\n\nTextual descriptions of all error conditions are provided in the \nCSerpt\n module. All language oriented text is located either in the \ncs_map.h\n header file, one of the three data modules: \nCSdata\n, \nCSdataU\n, \nCSdataPJ\n, or in the ASCII form of the dictionary files (\nCOORDSYS.ASC\n, \nDATUMS.ASC\n, and \nELIPSOID.ASC\n). Language translations efforts need only address these eight files (MFC dialogs excepted).", 
            "title": "Descriptions/Discussions"
        }, 
        {
            "location": "/userguide/desc/#cs-map-overview", 
            "text": "As one programmer to another, I present this Overview Section as the manual for people who, like\nmyself, don't read the manual (until something doesn't work).  This section contains all of the\ninformation you'll need to get started quickly, and the specific information you'll need to stay out of\ntrouble.  Please read this section before attempting to use CS-MAP.  Refer to the remainder of the\nguide as necessary.  Deferring the details to subsequent sections, it is helpful to consider CS-MAP as consisting of a\nCoordinate System Dictionary and a set of functions which use the information in the dictionary to\naccomplish the desired task.  All coordinate systems used by CS-MAP reside in the dictionary and are\ngiven a name, which we refer to as a key name, much like we give names to files.  CS-MAP, then,\nperforms coordinate system conversion based on the names of the coordinate systems provided.  This\ntechnique eliminates the need to have your users process through a long list of parameters which they\n(usually) don't understand whenever a conversion is necessary.  All they need provide are the names of\nthe appropriate coordinate systems.", 
            "title": "CS-Map Overview"
        }, 
        {
            "location": "/userguide/desc/#initialization", 
            "text": "CS-MAP needs to be initialized.  Initialization consists of providing CS-MAP with the directory in\nwhich the dictionary files reside.  This is accomplished by calling the  CS_altdr  function.  This function\ntakes a single argument, a character string which is the path to the appropriate directory.  Calling CS_altdr  with a  NULL  pointer as an argument will cause the value of the environmental variable named CS_MAP_DIR  to be used as the data directory.   CS_altdr  returns and integer zero if the initialization was\nsuccessful, -1 if not.  This was not a requirement in the past, thus the rather strange name for this initialization function.  Important Note 1 : Whenever CS-MAP needs to go to disk to find something, that something often needs\nto reside in the directory specified by this function call.  Important Note 2 : Failing to call this function successfully prior to using CS-MAP almost always results\nin an memory addressing fault.", 
            "title": "Initialization"
        }, 
        {
            "location": "/userguide/desc/#high-level-interface", 
            "text": "Given the name of the source and target coordinate systems, conversion of coordinate data from one to\nthe other is as simple as a single function call.  The following example would cause the coordinate in\nthe array of three doubles named coordinate to be converted from NAD27 based UTM Zone 13\ncoordinates to NAD83 based Colorado State Plane, Central Zone, coordinates:  status = CS_cnvrt( UTM27-13 , CO83-C , coordinate);  It's that simple.  The simplicity of this hides several important features.  First, note that the datum shift\nimplied by the coordinate systems, NAD27 to NAD83 in this case, is automatically applied.  Second,\nyou would hardly ever code an application with hard coded coordinate system names as was done in\nthis example.  Simple character arrays that are passed by argument, providing data entered by the user\nfrom a choice list, or providing data obtained from a database, whatever, all work just fine.  These are\njust very simple, case insensitive, null terminated strings.  Third, the application programmer has no\nneed to know which projections, datums, and/or ellipsoids are involved.  Fourth, the source and/or\ntarget coordinate systems could just as easily be Latitude and Longitude coordinates, based on any of\nseveral units, and referenced to any prime meridian.  Similarly, should your application need to know the grid scale factor at a specific point, all you need\ncode is a function call similar to the following:  grid_scale = CS_scale( CO83-C , coordinate);  Coordinate in this case must be geographic, i.e. the latitude and longitude of the point at which the grid\nscale is to be determined.  Again, it is unlikely that the name of the coordinate system would be hard\ncoded as was done in this example.  Need the convergence angle?  You have probably figured it out\nalready:  convergence = CS_cnvrg( CO83-C , coordinate);  Concerned about performance?  Originally, the above interface was designed as a means by which\napplications written in languages other than 'C' could access CS-MAP; i.e. no pointers required.\nHowever, due to its design and the high speed processors with on-board caches which are common\ntoday, this interface provides amazing levels of performance.  It is now the interface which we\nrecommend for all simple applications.  Several other features are made available in what we call the High Level Interface; that is features\nwhich are available without the use of pointers.  The details of all such features are provided in the\ntopic named High Level Interface.", 
            "title": "High Level Interface"
        }, 
        {
            "location": "/userguide/desc/#coordinate-system-dictionary", 
            "text": "The coordinate system is the heart of the CS-MAP package.  The CS-MAP distribution includes the\ndefinition of more than 5,000 coordinate systems.  Each definition includes the projection to be used,\nthe projection parameters, the datum or ellipsoid to which the coordinate system is referenced, and the\nunit to be used.  Admittedly, many of the coordinate system definitions provided are very similar to\nothers, differing only in the system unit or datum referenced. However, we believe your users will\nappreciate the simplicity of having only to remember and enter an easy to remember name or two to\nget what they need.  The default feature described elsewhere in this manual can be used in those cases\nwhere this design becomes inconvenient.  Coordinate system definitions are stored in a file we refer to as the Coordinate System Dictionary.\nThis file is a simple fixed length record file containing binary data.  It is maintained in sorted order by\ncoordinate system name and is accessed using a binary search technique.  This provides portability to\nalmost any environment without having to license any other software.  Your application will need to\nprovide the CS-MAP functions with the location of the directory in which the Coordinate System\nDictionary resides (see  CS_altdr ).  Once CS-MAP locates the Coordinate System Dictionary, it expects\nto find all most other data files in the same directory.  CS-MAP distributions include an ASCII file which defines all of the coordinate systems included in\nthe distribution. This file is usually committed to version control and treated has a highly valuable\nsource file.  A compiler included with CS-MAP can convert this ASCII file into the binary form used\nby the system.  Important Note : The first four bytes of a binary coordinate system dictionary file is a \"magic number\".\nThis sequence of bytes are used to identify that the file is indeed a coordinate system dictionary file.\nThe revision level of the dictionary format is also encoded into this \"magic number\".", 
            "title": "Coordinate System Dictionary"
        }, 
        {
            "location": "/userguide/desc/#other-interfaces", 
            "text": "It is probably obvious to you that the interface described above can not be the most efficient interface\npossible. Applications which require the absolute highest performance, may want to use the High\nPerformance Interface.  This interface requires the knowledge of as many as ten functions.  It also\nrequires the use of pointers to structures and, therefore, is usable only from languages such as C, C++,\nor Pascal which can handle pointers appropriately.  It does, however, provide the application\nprogrammer with the highest performance level possible, while still insulating your application from\nchanges to the internals of CS-MAP.  Using this interface, performance levels of 1,000,000 non-trivial\nconversions per second are routinely observed.  Applications which are hard coded around specific projections can use the Low Level Interface to\nobtain high performance solutions which do not require a Coordinate System Dictionary or, for that\nmatter, any other supporting data.  That is, at this level, the application programmer has access to the\nspecific code for each projection.  Similarly, applications can use the low level interface to access any\nof the 12 or so datum shift techniques supported by the library.  The High Performance and Low Level Interfaces are described in detail in the remaining chapters of\nthis guide.", 
            "title": "Other Interfaces"
        }, 
        {
            "location": "/userguide/desc/#other-dictionaries", 
            "text": "Like coordinate systems, datums are many and varied.  (The term datum is widely used to refer to a\nHorizontal Geodetic Reference System.  Although this usage is not technically incorrect, we will go\nalong with the crowd and use the simpler term.)  While several datum conversion techniques are hard\ncoded into CS-MAP, the actual definitions are not.  As you might suspect, there exists a Datum\nDictionary which contains the definition of all datums known to the system and provides a name by\nwhich they can be accessed (i.e. key name).  Coordinate systems are referenced to a datum by\nincluding the datum key name in the coordinate system definition.  Thus, when converting from one\ncoordinate system to another, CS-MAP can automatically activate the appropriate datum shifts\nnecessary by examining the datum references in the coordinate system definitions.  While full support\nis provided, application programmers rarely, if ever, access the Datum Dictionary directly.  All datum definitions  must  include a reference to an ellipsoid; coordinate system definitions can\ninclude a reference to an ellipsoid.  Again, there are many ellipsoid definitions and these are not hard\ncoded into CS-MAP.  You guessed it!  There is an Ellipsoid Dictionary:   that carries the definitions of all ellipsoids,  that assigns each ellipsoid definition a name (i.e. a key name),  to which CS-MAP provides a full set of access functions; and  that the application programmer rarely, if ever, accesses directly.   Important Note : Datum and Ellipsoid dictionaries include a \"magic number\" as the first four bytes of\nthe binary file.  These \"magic numbers\" identify the type of the file in addition to the file format\nrevision level.", 
            "title": "Other Dictionaries"
        }, 
        {
            "location": "/userguide/desc/#cartographic-vs-geodetic-referencing-of-coordinate-systems", 
            "text": "While coordinate system definitions can be referenced to a datum, they can also be referenced directly\nto an ellipsoid. In this manual, we will use the term  geodetically referenced  coordinate system to refer\nto the former case, and  cartographically referenced  coordinate system to refer to the latter.  When both\nthe source and target coordinate systems involved in a conversion are geodetically referenced, CS-\nMAP can automatically perform the necessary datum shift without any additional information required\nfrom the user, or any additional code required by the application programmer.  When either or both\ncoordinate system definitions are cartographically referenced, the datum shift feature is effectively\ndisabled.  That is, CS-MAP cannot calculate a datum shift it does not know both the source and target\ndatums.  In many cases, the datums upon which coordinates are based are known.  In these cases, coordinate\nsystem definitions are usually geodetically referenced and CS-MAP can, therefore, include the\nappropriate datum shift automatically whenever appropriate.  In other cases, the datum upon which a\ncoordinate system is based is not known and the coordinate system should be cartographically\nreferenced to an ellipsoid.  CS-MAP's automatic datum shift feature is then disabled whenever this\ncoordinate system is involved in a coordinate conversion.  Therefore, while the individual maintaining\nthe coordinate system definitions may need to understand the distinctions between geodetic and\ncartographic references, the typical end user is not usually concerned.  Cartographically referenced coordinate systems can be a great convenience to both user and application\nprogrammer.  For example, the LL coordinate system which you will find in the CS-MAP distribution is\ncartographically referenced to the WGS84  ellipsoid (not the WGS84 datum) .  This means that using the\nLL coordinate system as the target in any conversion produces geographic coordinates which are always\nbased on the same datum as the source coordinate system.  This is often very convenient indeed.", 
            "title": "Cartographic vs. Geodetic Referencing of Coordinate Systems"
        }, 
        {
            "location": "/userguide/desc/#latitudes-and-longitudes", 
            "text": "Coordinate systems can be defined to be geographic, i.e. consist of latitude and longitude coordinates.\nThis is achieved through the use of a pseudo projection we call the Unity projection.  The Unity\nProjection is simply a projection which does nothing, the results being geographic coordinates.  Since\nthe definitions of a latitude and longitude coordinate systems are included in the Coordinate System\nDictionary, they can, and indeed do, have datum references, origin longitudes, and units specifications.\nThus, several latitude and longitude definitions appear in the coordinate system dictionary.  As with\nany other coordinate system definition, these definitions are either geodetically or cartographically\nreferenced, have a unit specification, and have an origin longitude.  In this context, the units are the\nangular units of measure to be used (e.g. degrees, minutes, seconds, grads, etc.) and the origin\nlongitude is the prime meridian (i.e. Greenwich, Meridian of Paris, etc.).  Thus, latitude and longitude\ncoordinates are fully supported by the system, and the application programmer is not required to write\nany special code to process them.  The distribution Coordinate System Dictionary contains a geographic coordinate system simply named LL .  This is a cartographically referenced latitude and longitude coordinate system which is referenced\nto the Greenwich Prime Meridian, using units of degrees.  Thus,  LL  should be considered to be the\ngeneric latitude and longitude coordinate system, and can be used as such.  For example, to obtain the\ngrid scale factor of a coordinate system using cartesian coordinates (as opposed to the geographic\ncoordinates required by the CS_scale function) one could simply write as follows:  status = CS_cnvrt( CO83-C ,  LL , coordinate);\ngrid_scale = CS_scale( CO83-C , coordinate);  Note, that due to the generic nature of the  LL  coordinate system (i.e. cartographically referenced,\nthereby disabling datum shifts), the intermediary latitude and longitude results will be always be based\non the same datum as that of the source coordinate system.  Also, the  LL  coordinate system is defined\nto match the specific definition of latitude and longitude used internally within CS-MAP.  That is, in\nthose few cases where CS-MAP specifically requires a coordinate in terms of latitude and longitude:   the coordinates must be in degrees,  referenced to the Greenwich Prime Meridian, and  west longitude and south latitude must be negative values.", 
            "title": "Latitudes and Longitudes"
        }, 
        {
            "location": "/userguide/desc/#coordinate-arrays", 
            "text": "As is common in the industry, cartesian coordinates are passed in arrays of doubles.  The X coordinate\nis always the first element in the array, the Y coordinate being the second element, and the Z\ncoordinate being the third element.  When performing a two dimensional conversion, CS-MAP often\nignores the Z coordinate.  Obviously, when performing a three dimensional conversion, a valid Z\ncoordinate is required.  To simplify use of the library, all coordinate arrays should be dimensioned at\nthree.  Typically, a Z value of zero is provided when performing a two dimensional conversion.  In the case of cartesian coordinates, coordinates must be ordered as described above; specifically X, Y,\nand then Z.  While it is common usage to refer to geographic coordinates as latitude and longitude, and\nit is also common to give the latitude first and the longitude second, CS-MAP requires that the first\nelement of a geographic coordinate be the longitude, the second element be the latitude, and the third\nelement the height.  While negative values are usually used to indicate west longitude and south\nlatitude, geographic coordinate systems can be defined where the opposite sign convention is used.  It is important to note that there is a significant difference between coordinates returned to the user\nwhich may just happen to be geographic, and the geographic coordinates required by certain CS-MAP\nfunctions.  The conventions used in \"user\" coordinates are determined by the coordinate system\ndefinition.  Thus, in a \"user\" geographic coordinate, as returned by CS_cs2ll for example, the prime\nmeridian may be other than Greenwich and the unit other than degrees.  Users can also define\ngeographic coordinate systems where west longitude is positive and/or the order of the coordinates is\nswapped.  However, wherever a CS-MAP function specifically requires a geographic coordinate, the values\nprovided  must :   be given in degrees,  be referenced to the Greenwich Prime Meridian, and  west longitude and south latitude be given as negative values.", 
            "title": "Coordinate Arrays"
        }, 
        {
            "location": "/userguide/desc/#selected-source-code", 
            "text": "For historical reasons, most all global data definitions are coded in distinct modules.  This has been\nvery convenient over the years.  Many of the features of CS-MAP can be adjusted to better fit into your\napplication by tweaking one of these source modules.  Four of these modules are worth mention in this\noverview:  CSdata ,  CSdataU ,  CSdataPJ , and  CS_error .  In  CSdata  you will find the definition of many\nglobal constants used throughout CS-MAP.  While you obviously don't want to change the definition\nof \u03c0, there are several other aspects of CS-MAP which are controlled by global variables defined in\nthis module.  Make the modifications which you need, recompile, and re-link your application.  CSdataU  contains the unit table which CS-MAP uses.  To add (or remove) a unit, simply modify the\ntable and recompile.  CSdataPJ  contains CS-MAP's projection table.  To remove a projection (to reduce the size of your\nexecutable, for example), simply remove the projection's entry in the table an all object code references\nto the projection will be removed.  CS_error  contains the text of all error messages.  All data which may be language related is contained in these four modules.  To translate the entire\nsystem to another language, only these four modules, and perhaps the help file, need attention.", 
            "title": "Selected Source Code"
        }, 
        {
            "location": "/userguide/desc/#naming-conventions", 
            "text": "Originally, the names of global variables, manifest constants (i.e. defines), structures, and functions\nused in CS-MAP adhered to a very definitive naming convention.  Much of the library still adheres to\nthis convention.  This convention was developed with three purposes in mind.  First, and foremost, it is\nnecessary to insure that the probability of a name collision with existing application code is kept to a\nminimum.  Second, to enable programmers to quickly determine the type of entity being referenced by\na name and to quickly determine where the definition of such can be found.  Third, provide an efficient\nmeans by which the libraries and other components of CS-MAP can be efficiently maintained and\nmanufactured.  In later developments of the library, such as the inclusion of some C++ elements and the planned\nporting of the entire library to C++, there are several modules no longer adhere to the original naming\nconvention.", 
            "title": "Naming Conventions"
        }, 
        {
            "location": "/userguide/desc/#name-collisions", 
            "text": "All names whose scope extends outside the specific file in which is it is defined will start with the two\ncharacter sequence  CS .  As described below, this initial sequence may be in upper or lower case.\nAdditionally, every such name will contain at least one upper case character and at least one lower case\ncharacter.  In this way, the possibility of a CS-MAP global name being the same as a name already\nused in your application is virtually nil.", 
            "title": "Name Collisions"
        }, 
        {
            "location": "/userguide/desc/#function-names", 
            "text": "All function names begin with an upper case  CS  sequence.  If the function is expected to be accessed\nby modules outside of the CS-MAP library in normal use, the initial CS sequence is followed by an\nunderscore character.  The remainder of the function name follows, the first of which will be lower\ncase if it is an alphabetic character.", 
            "title": "Function Names"
        }, 
        {
            "location": "/userguide/desc/#structure-tags", 
            "text": "Structure tags begin with a lower case cs sequence.  If the structure is expected to be accessed by\nmodules outside of the CS-MAP library in normal use, the initial sequence is followed by an\nunderscore character.  The remainder of the structure tag follows, the first character of which will\nalways be uppercase.  Finally, the last character of all structure tags will be the underscore character.", 
            "title": "Structure Tags"
        }, 
        {
            "location": "/userguide/desc/#global-variable-names", 
            "text": "Global variable names begin with a lower case cs sequence.  If the global variable is expected to be\naccessed by modules outside of the CS-MAP library in normal use, the initial sequence is followed by\nan underscore character.  The remainder of the global variable name follows, the first character of\nwhich will always be an upper case letter.  A global variable name will never end with the underscore\ncharacter.  A global variable which is a definition of a structure, or a pointer to same, will usually have\nthe same name as the structure tag, sans the trailing underscore.", 
            "title": "Global Variable Names"
        }, 
        {
            "location": "/userguide/desc/#manifest-contents", 
            "text": "Manifest constant names, e.g. include file define's, begin with a lower case cs sequence.  If the constant\nbeing defined is expected to be used by modules outside of the CS-MAP library, the initial sequence is\nfollowed by an underscore character.  The remainder of the constant name follows and will be all upper\ncase.", 
            "title": "Manifest contents"
        }, 
        {
            "location": "/userguide/desc/#naming-convention-examples", 
            "text": "The table below shows several examples of the naming convention;     Name  Type  Comment      CS_csloc  Function, external  Name of a function expected to be called from outside of the CS-MAP library.    CSnad283  Function, internal  Name of a function not expected to be called from outside of the CS-MAP library.    cs_Csdef_  Structure tag, external  Structure tag name for a structure expected to be referenced by modules outside of the CS-MAP library.    csNaddir_  Structure tag, internal  Structure tag name for a structure not expected to be accessed outside of the CS-MAP library.    cs_Dir  Global Variable, external  Global variable name expected to be accessed outside of the CS-MAP library    csErrlng  Global Variable, internal  Global variable name not expected to be accessed outside of the CS-MAP library.    cs_NO_MEM  Manifest Constant, external  Manifest constant expected to be referenced by modules outside of the CS-MAP library.    csGRF_MAX_ACTIVE  Manifest Constant, internal  Manifest constant not expected to be referenced by modules outside of the CS-MAP library.", 
            "title": "Naming Convention Examples"
        }, 
        {
            "location": "/userguide/desc/#projection-code-names", 
            "text": "Each of the thirty eight projections has a five character code name which is used in all structure tags\nand function names associated with the specific projection.  The table below lists each projection, the five\ncharacter code value, the structure tag name, and setup function name associated with each as examples\nof how this code value is used to identify the projection each is associated with.  All code elements\nwhich are specifically related to specific projection are named in a similar manner.     Projection  Code  Structure Tag  Setup Function      Transverse Mercator  trmer  cs_Trmer_  CStrmerS    Lambert Conformal Conic  lmbrt  cs_Lmbrt_  CSlmbrtS    Hotine Oblique Mercator  oblqm  cs_Oblqm_  CSoblqmS    Alber's Equal Area  alber  cs_Alber_  CSalberS    Mercator  mrcat  cs_Mrcat_  CSmrcatS    Miller Cylindrical  millr  cs_Millr_  CSmillrS    Lambert Equidistant Azimuthal  azmed  cs_Azmed_  CSazmedS    Lambert Equal Area Azimuthal  azmea  cs_Azmea_  CSazmeaS    Polar Stereographic  pstro  cs_Pstro_  CSpstroS    Oblique Stereographic  ostro  cs_Ostro_  CSostroS    Snyder's Oblique Stereographic  sstro  cs_Sstro_  CSsstroS    Equidistant Conic  edcnc  cs_Edcnc_  CsedcncS    Sinusoidal  sinus  cs_Sinus_  CSsinusS    American Polyconic  plycn  cs_Plycn_  CSplycnS    Modified Polyconic  modpc  cs_Modpc_  CsmodpcS    Lambert Tangential  lmtan  cs_Lmtan_  CSlmtanS    Van der Grinten  vdgrn  cs_Vdgrn_  CSvdgrnS    Orthographic  ortho  cs_Ortho_  CSorthoS    Gnomonic  gnomc  cs_Gnomc_  CsgnomcS    Equidistant Cylindrical  edcyl  cs_Edcyl_  CSedcylS    Cassini  csini  cs_Csini_  CScsiniS    Modified Stereographic  mstro  cs_Mstro_  CSmstroS    New Zealand National Grid  nzlnd  cs_Nzlnd_  CSnzlndS    Robinson Cylindrical  robin  cs_Robin_  CSrobinS    Bonne  bonne  cs_Bonne_  CsbonneS    Equal Area (Authalic) Cylindrical, Normal Aspect  nacyl  cs_Nacyl_  CSnacylS    Equal Area (Authalic) Cylindrical, Transverse Aspect  tacyl  cs_Tacyl_  CStacylS    Mollweide  molwd  cs_Molwd_  CsmolwdS    Eckert IV  ekrt4  cs_Ekrt4_  CSekrt4S    Eckert VI  ekrt6  cs_Ekrt6_  CSekrt6S    Goode Homolosine  hmlsn  cs_Hmlsn_  CShmlsnS    Bipolar Oblique Conformal Conic  bpcnc  cs_Bpcnc_  CSbpcncS    Oblique Cylindrical  swiss  cs_Swiss_  CSswissS    Snyder Transverse Mercator  trmrs  cs_Trmrs_  CStrmrsS    Krovak Oblique Conformal Conic  krovk  cs_Krovk_  CSkrovkS    Non-georeferenced Coordinates  nerth  cs_Nerth_  CSnerthS    Danish System 34  sys34  cs_Sys34_  CSsys34S    Unity Pseudo Projection  unity  cs_Unity_  CSunityS", 
            "title": "Projection Code Names"
        }, 
        {
            "location": "/userguide/desc/#high-level-interface_1", 
            "text": "Functions are provided which can convert a coordinate from one coordinate system to another with a single function call. This set of functions was originally developed specifically for the application programmer who is coding in  BASIC ,  FORTRAN ,  APL , or other language (other than C or Pascal) which can make simple function calls. It does not use structure pointers of any sort. Since the affect on performance is small (about a 20% reduction), it is now the recommended interface for most applications.\nMost of the functions described in this section use  CSbcclu  and  CSbdclu  to cache coordinate system and datum conversion definitions. Therefore the performance penalty of these functions is reduced to a search of a linked list for the coordinate system names involved. These cache functions are smart enough to keep the most recently accessed items at the front of the list to further minimize the performance penalty.\nThe information presented in this section is intended only to associate a function name with a specific capability.", 
            "title": "High Level Interface"
        }, 
        {
            "location": "/userguide/desc/#basic-coordinate-conversion-cs_cnvrt", 
            "text": "Given a coordinate as an array of three doubles, and the names of two coordinate systems as two character arrays,  CS_cnvrt  converts the coordinate from one system to another. It's that simple. Where cartesian coordinates are provided and returned, the X coordinate is the first element of the array, the Y coordinate is the second, and the Z is the third element of the array. Where geographic coordinates are provided, the first element in the array must contain the longitude, the second the latitude, and the third element must contain the height. In either case, the manner in which the values are interpreted depends upon the coordinate systems involved. For example, if the source coordinate system definition specifies the unit to be meters, the X, Y, and Z coordinates are considered to be in meters. Similarly, if the target coordinate system is defined as a latitude and longitude system with an angular unit of grads, the returned latitude and longitude coordinates will be in units of grads.  The status value returned by  CS_cnvrt  informs the calling application of the validity of the results. A zero return value indicates that the requested conversion was completed without complication and the results now occupy the coordinate array. A negative status return value indicates a hard error occurred and that the contents of the coordinate array remain unchanged. A positive, non-zero return status indicates that the conversion was performed, but an abnormality was encountered during the conversion. In this case, the results returned in the coordinate array may not be exactly what the user expects.  In all cases of a negative status return, the values in the provided coordinate array will remain unchanged. Taking the absolute value of the returned status value will often produce the CS-MAP error code for the specific condition causing the hard error. The numeric error code which defines the specific cause of the problem will also be stored in the  cs_Error  global variable, and a textual description of the error condition can be obtained by calling the  CS_errmsg  function before calling any other CS-MAP function. Typically, when applications detect a negative status return, the application informs the user using the textual description obtained from  CS_errmsg  and terminates the current operation.  CS_cnvrt  returns a positive non-zero status value whenever it encounters something suspicious, but not something that precludes a conversion. Positive non-zero return values are usually caused by coordinate systems and coordinates which are incompatible, or specific values which are singularity points for the projection(s) involved. A common cause of a positive non-zero return value is the conversion of a point at either pole. CS-MAP will return a positive non-zero value in these cases as longitude is undefined at the poles, and reversing the calculation is unlikely to reproduce the initial value. Another common cause of a positive non-zero status return is providing, say, UTM coordinates when the source coordinate system is given as \"LL\". UTM coordinates, usually, will not be in the normal range of geographic coordinates and CS-MAP will consider this to be suspicious. A positive return value will also be returned if, for example, it is requested to convert a geographic coordinate in Europe from NAD27 to NAD83.  When a positive non-zero return value from  CS_cnvrt  is encountered, the typical application issues a warning message to the user and continues. These abnormal, but not necessarily fatal, conditions are often the result the user desires. It should be left the user to decide. For performance reasons, CS- MAP does not automatically generate a textual message for these conditions. However, application programs can analyze the returned status value in order to present a more specific warning message to the end user.", 
            "title": "Basic Coordinate Conversion -- CS_cnvrt"
        }, 
        {
            "location": "/userguide/desc/#grid-scale-factor-cs_scale", 
            "text": "Given a coordinate system name and a location in the form of a geographic coordinate,  CS_scale  will return the grid scale factor of the coordinate system at the specified location.  CS_scale  returns a negative one in the event of an error condition. In such cases, the cause of the error can be determined by examining  cs_Error  which will contain the CS-MAP numeric error code of the condition which caused the error.  CS_errmsg  can be used to obtain a textual description of the error condition. An error caused by the location being outside of the domain of the coordinate system will be indicated by a  cs_Error  value of zero. In this case, no textual description will be available.  Note that the coordinate provided as the second argument must be a geographic coordinate, i.e. latitude and longitude in degrees referenced to the Greenwich prime meridian. Longitude is the first element in the array, latitude is the second. (The third element is not currently used for grid scale calculations, but may be in the future.) As always for internal geographic coordinates, use negative values for west longitude and south latitude.", 
            "title": "Grid Scale Factor -- CS_scale"
        }, 
        {
            "location": "/userguide/desc/#convergence-angle-cs_cnvrg", 
            "text": "Given a coordinate system name and a location in the form of a geographic coordinate,  CS_cnvrg  will return the convergence angle of the coordinate system at the specified location, in degrees east of north.  CS_cnvrg  returns a negative 360 (i.e. -360) value in the event of an error condition. In such cases, the cause of the error can be determined by examining  cs_Error  which will contain the CS- MAP numeric error code of the condition which caused the error.  CS_errmsg  can then be used to obtain a textual description of the error condition. An error caused by the location being outside of the domain of the coordinate system will be indicated by a  cs_Error  value of zero. In this case, no textual description will be available.  Note that the coordinate provided as the second argument must be a geographic coordinate, i.e. latitude and longitude in degrees referenced to the Greenwich prime meridian. Longitude is the first element in the array, latitude is the second. (The third element is not used for convergence calculations.) As always, use negative values for west longitude and south latitude.", 
            "title": "Convergence Angle -- CS_cnvrg"
        }, 
        {
            "location": "/userguide/desc/#data-directory-cs_altdr", 
            "text": "In order to operate correctly, CS-MAP needs to access to several data files, the most important of which is the Coordinate System Dictionary.  CS_altdr  can be used to provide CS-MAP with the path to the directory it should look in for all of its data files. The single argument should contain the full path to the directory containing all of CS-MAP's supporting data files. You can instruct  CS_altdr  to use the value of the  CS_MAP_DIR  environmental variable by setting the argument to the NULL pointer. Should the argument point to the null string, CS-MAP will consider the current directory on the current drive as the directory in which to search for data file.  In all cases,  CS_altdr  will return a -1 if a valid Coordinate System Dictionary file could not be located in the indicated directory, for whatever reason.  Important Note:  Failure to successfully call this function prior to calling any other CS-MAP function is likely to cause a fatal addressing error and the host application to crash.", 
            "title": "Data Directory -- CS_altdr"
        }, 
        {
            "location": "/userguide/desc/#recover-system-resources-cs_recvr", 
            "text": "Use this function to recover any and all system resources, such as file descriptors and heap memory, which CS-MAP may have allocated due to calls to  CS_cnvrt ,  CS_scale , and  CS_cnvrg  functions.", 
            "title": "Recover System Resources -- CS_recvr"
        }, 
        {
            "location": "/userguide/desc/#get-error-message-text-cs_errmsg", 
            "text": "CS_errmsg  returns in the buffer supplied by the calling module a null terminated string which is suitable for reporting the last error condition detected by CS-MAP. This function should be used only after any CS-MAP function returns a negative status. It should be called prior to any other CS-MAP function call.", 
            "title": "Get Error Message Text -- CS_errmsg"
        }, 
        {
            "location": "/userguide/desc/#compute-azimuth-and-distance-cs_llazdd", 
            "text": "CS_llazdd  is a utility function which is a part of the High Level Interface. Use this function to compute the azimuth from one geographic coordinate to another. It also returns the distance between the two points. These calculations take full account of the ellipsoid, and ellipsoid parameters are part of the calling sequence.", 
            "title": "Compute Azimuth and Distance -- CS_llazdd"
        }, 
        {
            "location": "/userguide/desc/#unit-lookup-cs_unitlu", 
            "text": "Use  CS_unitlu  function to obtain the conversion constant for any of the unit systems understood by CS- MAP.  CS_unitlu  will return a zero if the supplied unit name is not valid.", 
            "title": "Unit Lookup -- CS_unitlu"
        }, 
        {
            "location": "/userguide/desc/#coordinate-system-name-verification-cs_csisvalid", 
            "text": "Use the  CS_csIsValid  function to determine if a coordinate system key name is that of an existing coordinate system defined in the currently active Coordinate System Dictionary without any side affects.", 
            "title": "Coordinate System Name Verification \u2013 CS_csIsValid"
        }, 
        {
            "location": "/userguide/desc/#datum-name-verification-cs_dtisvalid", 
            "text": "Use the  CS_dtIsValid  function to determine if a datum key name is that of an existing datum defined in the currently active Datum Dictionary without any side affects.", 
            "title": "Datum Name Verification \u2013 CS_dtIsValid"
        }, 
        {
            "location": "/userguide/desc/#ellipsoid-name-verification-cs_elisvalid", 
            "text": "Use the  CS_elIsValid  function to determine if a ellipsoid key name is that of an existing ellipsoid defined in the currently active Ellipsoid Dictionary without any side affects.", 
            "title": "Ellipsoid Name Verification \u2013 CS_elIsValid"
        }, 
        {
            "location": "/userguide/desc/#low-level-functions", 
            "text": "While the use of the High Level or the High Performance Interfaces described above is highly recommended, certain applications may require the use of the lower level functions. The sub-sections of this section organize these functions into three major groups:   cartographic projection functions,  geodetic datum shift functions, and  general mapping/geodetic functions.", 
            "title": "Low Level Functions"
        }, 
        {
            "location": "/userguide/desc/#cartographic-projections", 
            "text": "For each projection supported, there exist eight, possibly nine, functions which comprise the full implementation of a projection. The brief description of these functions is given below. These descriptions will be important to those adding a new projection as well.  Those adding projections to the system only need to add an entry to the projection table  cs_Prjtab . Doing so, you will need to add a pointer to the Definition Check and the Setup functions. To activate the proper parameter settings in the MFC dialog, you will also need to add the projection to the  cs_PrjprmMap  table. It is unlikely, but if your new projection uses a new type of parameter, you may need to add a new entry to the  cs_Prjprm  table. All of these tables are defined in the  CSdataPJ.c  module.", 
            "title": "Cartographic Projections"
        }, 
        {
            "location": "/userguide/desc/#definition-check-functions", 
            "text": "For each projection there exists a function which verifies that a coordinate system definition adheres to the requirements of the projection. These functions are named in a manner similar to all other projection functions, but the distinguishing final character is Q. To prevent large scale duplication of code, each Q function checks only those elements of a coordinate system definition which are specific to the projection. The generalized check function,  CS_cschk , checks those elements which are common to all coordinate systems (e.g. datum, ellipsoid, and units).  CS_csloc  calls this function prior to calling the setup function, thus providing the setup function with data known to be valid for the given projection. This also implies that the pointer to the Q function for each projection must reside in the projection table.", 
            "title": "Definition Check Functions"
        }, 
        {
            "location": "/userguide/desc/#setup-function", 
            "text": "The setup function for each projection has two basic responsibilities. It should perform all of the one- time calculations which can be performed independent of the specific coordinates which are to be converted and insert in the  cs_Csprm_  structure pointers to the nine functions required for coordinate conversion. It is the setup function which is the primary repository for all knowledge about a specific projection. Therefore, it is one of the five elements required in the projection table other than the name of the projection. (C++ users would use the term constructor for the setup function. The design of CS- MAP predates the availability of C++ compilers on personal computers.)  This function is always supplied with a pointer to a  cs_Csprm_  structure. This single argument supplies the setup function with the information required to perform the setup via the csdef and datum elements and the repository for the results of the setup by way of the  ll2cs ,  cs2ll ,  cs_csscl ,  cs_cscnv ,  cs_cssck ,  cs_cssch ,  llchk ,  xychk , and  prj_prmselements . Note that the  prj_prms  element of the  cs_Csprm_  structure is a union of all the pre-processed projection parameter structures, thus providing a repository for setup parameters regardless of the projection in use.  Also note that in order to reduce the amount of duplicated code necessary to support the large number of projection variations now supported, the  prj_code  element of the  cs_Csprm_ structure must be filled in as well prior to calling the setup function.", 
            "title": "Setup Function"
        }, 
        {
            "location": "/userguide/desc/#forward-functions", 
            "text": "For each supported projection, there exists a forward function. It is responsible for converting latitudes and longitudes to the appropriate coordinates given a pointer to the projection parameters for the specific projection. A pointer to such function is inserted into the  ll2cs  element of the  cs_Csprm_  structure by the setup function. These functions require that they be given a pointer to the projection parameters calculated by the setup function, e.g. a pointer to a element of the  prj_prms  union in the  cs_Csprm_  structure.     Setup Function  Forward Function  Inverse Function  Projection      CstrmerS  CStrmerF  CStrmerI  Transverse Mercator    CSlmbrtS  CSlmbrtF  CSlmbrtI  Lambert Conformal Conic    CsoblqmS  CSoblqmF  CSoblqmI  Hotine Oblique Mercator    CSalberS  CSalberF  CSalberI  Alber\u2019s Equal Area Conic    CSmrcatS  CSmrcatF  CSmrcatI  Mercator    CSmillrS  CSmillrF  CSmillrI  Miller Cylindrical    CsazmedS  CSazmedF  CSazmedI  Lambert Equidistant Azimuthal    CsazmeaS  CSazmeaF  CSazmeaI  Lambert Equal Area Azimuthal    CSpstroS  CSpstroF  CSpstroI  Polar Stereographic    CSostroS  CSostroF  CsostroI  Oblique Stereographic    CSsstroS  CSsstroF  CSsstroI  Snyder\u2019s Oblique Stereographic    CsedcncS  CSedcncF  CSedcncI  Equidistant Conic    CSsinusS  CSsinusF  CSsinusI  Sinusoidal    CSplycnS  CSplycnF  CSplycnI  American Polyconic    CsmodpcS  CSmodpcF  CSmodpcI  Modified Polyconic    CSlmtanS  CSlmtanF  CSlmtanI  Lambert Tangential    CSvdgrnS  CSvdgrnF  CSvdgrnI  Van der Grinten    CSorthoS  CSorthoF  CSorthoI  Orthographic    CsgnomcS  CSgnomcF  CSgnomcI  Gnomonic    CSedcylS  CSedcylF  CSedcylI  Equidistant Cylindrical    CScsiniS  CScsiniF  CScsiniI  Cassini    CSmstroS  CSmstroF  CSmstroI  Modified Stereographic    CSnzlndS  CSnzlndF  CSnzlndI  New Zealand National Grid    CSrobinS  CSrobinF  CSrobinI  Robinson    CSbonneS  CSbonneF  CSbonneI  Bonne    CSnacylS  CSnacylF  CSnacylI  Normal Aspect, Equal Area (Authalic) Cylindrical    CStacylS  CStacylF  CSnacylI  Transverse Aspect, Equal Area (Authalic) Cylindrical    CsmolwdS  CSmolwdF  CSmolwdI  Mollweide    CSekrt4S  CSekrt4F  CSekrt4I  Eckert IV    CSekrt6S  CSekrt6F  CSekrt6I  Eckert VII    CShmlsnS  CShmlsnF  CShmlsnI  Goode Homolosine    CSbpcncS  CSbpcncF  CSbpcncI  Bipolar Oblique Conformal Conic    CSswissS  CSswissF  CSswissI  Oblique Cylindrical    CStrmrsS  CStrmrsF  CStrmrsI  Transverse Mercator ala Snyder    CSkrovkS  CSkrovkF  CSkrovkI  Krovak Oblique Conformal Conic    CSnerthS  CSnerthF  CSnerthI  Non-georeferenced coordinate system    CSsys34S  CSsys34F  CSsys34I  Danish System 34    CSunityS  CSunityF  CSunityI  Unity (pseudo projection)", 
            "title": "Forward Functions"
        }, 
        {
            "location": "/userguide/desc/#inverse-functions", 
            "text": "Similarly, there exists for each projection an inverse function, responsible for converting coordinate system coordinates to latitudes and longitudes. A pointer to such function is inserted into the  cs2ll  element of the  cs_Csprm_  structure by the setup function, and these functions require a pointer to the setup parameters calculated by the setup function.", 
            "title": "Inverse Functions"
        }, 
        {
            "location": "/userguide/desc/#scale-funcions", 
            "text": "The Coordinate System Mapping Package also includes the ability to determine the grid scale factor of a coordinate system at any point. In many cases there is an analytical formula which produces the desired results. Since analytical formulas for the grid scale factor for all thirty eight projections could not be found, the grid scale factor is determined empirically for some projections using the latitude/longitude azimuth and distance calculation function  CS_llazdd .     K Scale Function  H Scale Function  Convergence Function  Projection      CStrmerK  none  CStrmerC  Transverse Mercator    CSlmbrtK  none  CSlmbrtC  Lambert Conformal Conic    CSoblqmK  none  CSoblqmC  Hotine Oblique Mercator    CSalberK  CSalberH  CSalberC  Alber's Equal Area Conic    CSmrcatK  none  CSmrcatC  Mercator    CSmillrK  CSmillrH  CSmillrC  Miller Cylindrical    CSazmedK  CSazmedH  CSazmedC  Lambert Equidistant Azimuthal    CSazmeaK  CSazmeaH  CSazmeaC  Lambert Equal Area Azimuthal    CSpstroK  none  CSpstroC  Polar Stereographic    CSostroK  none  CSostroC  Oblique Stereographic    CSsstroK  none  CSsstroC  Snyder's Oblique Stereographic    CsedcncK  CSedcncH  CSedcncC  Equidistant Conic    CSsinusK  CSsinusH  CSsinusC  Sinusoidal    CSplycnK  CSplycnH  CSplycnC  American Polyconic    CsmodpcK  CSmodpcH  CSmodpcC  Modified Polyconic    CSlmtanK  CSlmtanH  CSlmtanC  Lambert Tangential    CSvdgrnK  CSvdgrnH  CSvdgrnC  Van der Grinten    CSorthoK  CSorthoH  CSorthoC  Orthographic    CsgnomcK  CSgnomcH  CSgnomcC  Gnomonic    CSedcylK  CSedcylH  CSedcylC  Equidistant Cylindrical    CScsiniK  CScsiniH  CScsiniC  Cassini    CSmstroK  none  CSmstroC  Modified Stereographic    CSnzlndK  none  CSnzlndC  New Zealand National Grid    CSrobinK  CSrobinH  CSrobinC  Robinson    CsbonneK  CSbonneH  CSbonneC  Bonne    CSnacylK  CSnacylH  CSnacylC  Normal Aspect, Equal Area (Authalic) Cylindrical    CStacylK  CStacylH  CSnacylC  Transverse Aspect, Equal Area (Authalic) Cylindrical    CsmolwdK  CSmolwdH  CSmolwdC  Mollweide    CSekrt4K  CSekrt4H  CSekrt4C  Eckert IV    CSekrt6K  CSekrt6H  CSekrt6C  Eckert VII    CShmlsnK  CShmlsnH  CShmlsnC  Goode Homolosine    CSbpcncK  none  CSbpcncC  Bipolar Oblique Conformal Conic    CSswissK  none  CSswissC  Swiss Oblique Cylindrical    CStrmrsK  none  CStrmrsC  Transverse Mercator ala Snyder    CSkrovkK  none  CSkrovkC  Krovak Oblique Conformal Conic    CSnerthK  none  CSnerthC  Non-georeferenced coordinate system; scale is always 1.0, convergence is always zero.    CSsys34K  none  CSsys34C  Danish System 34 (believed to be conformal, but this is not a sure thing)    CSunityK  none  CSunityC  Unity     As mentioned above, for non-conformal projections, there are two scale factors, K and H. Therefore, for all thirty eight projections, there exists a K function, and for all non-conformal projections there exists an H function. A pointer to the appropriate function is inserted into the cs_Csprm_ structure by the setup function and, as you might expect, each of these functions requires a pointer to the projection parameters as calculated by the setup function.  Refer to the table above for the names of the K scale functions, i.e. grid scale factor along a parallel, and the H scale functions (i.e. scale along a meridian) for all thirty five projections currently supported. The name of the H function is given as   for conformal projections. In these cases, the H scale factor is the same as the K scale factor.", 
            "title": "Scale Funcions"
        }, 
        {
            "location": "/userguide/desc/#convergence-functions", 
            "text": "For each projection there exists a function which computes the convergence angle for any point given a coordinate system definition. Refer to the table above for the names of the convergence angle functions for all thirty one projections currently supported. Again, analytical formulas for the convergence angle have not been located for all projections. Therefore, for some projections the convergence angle is determined empirically using the  CS_llazdd  function.", 
            "title": "Convergence Functions"
        }, 
        {
            "location": "/userguide/desc/#geographic-limits-check-functions", 
            "text": "For each projection, there exists a function which determines if a given geographic coordinate, great circle, or region is entirely within the mathematical domain of a coordinate system. These functions are named in a manner similar to all other projection functions, but the distinguishing final character is L.  For performance reasons, the actual conversion functions of CS-MAP check the coordinate data they are provided only to the extent necessary to prevent floating point exceptions. The geographic limits function of each projection can be used prior to a conversion to determine if a specific geographic coordinate, great circle defined by two geographic coordinates, or a closed region defined by four or more geographic coordinates is entirely within the mathematical domain of the projection. It is not unusual for applications to know the extents of the data set which is to be converted, and thus the extents only, not each individual coordinate, need be checked. This can provide significant performance advantages.", 
            "title": "Geographic Limits Check Functions"
        }, 
        {
            "location": "/userguide/desc/#cartographic-limits-check-functions", 
            "text": "For each projection, there exists a function which determines if a given cartesian coordinate, line segment, or region is entirely within the mathematical domain of a coordinate system. These functions are named in a manner similar to all other projection functions, but the distinguishing final character is X.  For performance reasons, the actual conversion functions of CS-MAP check the coordinate data they are provided only to the extent necessary to prevent floating point exceptions. The cartesian limits function of each projection can be used prior to a conversion to determine if a specific cartesian coordinate, line defined by two cartesian coordinates, or a closed region defined by four or more cartesian coordinates are entirely within the mathematical domain of the projection. It is not unusual for applications to know the extents of the data set which is to be converted, and thus the extents only, not each individual coordinate, need be checked. This can provide significant performance advantages.", 
            "title": "Cartographic Limits Check Functions"
        }, 
        {
            "location": "/userguide/desc/#geodetic-datum-shift-functions", 
            "text": "The methods/functions associated with geodetic datum shifts are not nearly as well organized as those of cartographic projections. This is the result of many different governmental agencies solving the problem independently and relying on different data sets and calculation techniques. However, the basic functions involved in the most generalized techniques are described in the following sub- sections.", 
            "title": "Geodetic Datum Shift Functions"
        }, 
        {
            "location": "/userguide/desc/#nadcon-emulation-functions", 
            "text": "Four lower level functions can be used to perform NAD27 to NAD83 conversions. Use  CSnadInit  to initialize the system, and  CSnadCls  to release all resources absorbed by  CS_nadinit .  Once  CSnadInit  has been called,  CSnad27ToNad83  can be called to convert geographic coordinates from NAD27 to NAD83.  CSnad83ToNad27  can be used to convert NAD83 to NAD27. Its that simple.", 
            "title": "NADCON Emulation Functions"
        }, 
        {
            "location": "/userguide/desc/#datum-conversion-functions", 
            "text": "The basic technique used for NAD83 and HARN described in previous sections is used for several other datums now defined worldwide. In the descriptions given below, you will see how this technique applies to AGD66; the Geodetic Datum of Australia of 1966. A similar pattern exists for the following datums and descriptions of these inidividual sets of functions will not be repeated in this section of the manual. In the future, there are likely to be a lot more of these.     Abbreviated Name  Full Name      AGD66  Australian Geodetic Datum of 1966    AGD84  Australian Geodetic Datum of 1984    GDA94  Geocentric Datum of Australia, 1994    NZGD49  New Zealand Geodetic Datum of 1949    NZGD2K  New Zealand Geocentric Datum of 2000    ATS77  Average Terrestrial System of 1977    CSRS  Canadian Spatial Reference System     Four lower level functions can be used to convert coordinates from AGD66 to GDA94. Use  CSagd66Init  to initialize the system, and  CSagd66Cls  to release all resources absorbed by  CSagd66Init .  Once  CSagd66Init  has been successfully called,  CSagd66ToGda94  can be used to convert geographic coordinates from AGD66 to GDA94. Similarly,  CSgda94ToAgd66  can be used to convert geographic coordinates from GDA94 to AGD66.", 
            "title": "Datum Conversion Functions"
        }, 
        {
            "location": "/userguide/desc/#general-utility-functions", 
            "text": "Supporting the generalized coordinate conversions described in the previous sections, are several functions which perform calculations which are quite useful to the GIS/GPS/Mapping application programmer. Several (but probably not all) of these are described in the following sub-sections.", 
            "title": "General Utility Functions"
        }, 
        {
            "location": "/userguide/desc/#geoid-height-functions", 
            "text": "This facility enables applications to calculate and use, as appropriate, the geoid height (or geoid separation if you prefer) at locations for which data is available. Record the data files available, and desired to be used, in the Geodetic Data Catalog file named  GeoidHeight.gdc .  This implementation emulates C++, but is written in ANSI compliant C. The functions are named:  CSnewGeoidHeight ,  CSdeleteGeoidHeight , and  CScalcGeoidHeight ; and are defined in the module named  cs_GeoidHeight.c . Code specific to geoid height file formats can be found in modules named:  CS_geoid96.c ,  CS_geoid99.c ,  CS_bynFile.c , and  CS_osgm91.c . Low level applications may wish to access the functions defined in these modules directly.  Note there is no inverse function, as it is unnecessary. To obtain orthometric height at a given location, add the geoid height returned by  CScalcGeoidHeight  to the ellipsoid height. To calculate the ellipsoid height, subtract the geoid height returned by  CScalcGeoidHeight  from the orthometric height.", 
            "title": "GEOID Height Functions"
        }, 
        {
            "location": "/userguide/desc/#geocentric-coordinates", 
            "text": "Converting between geographic and geocentric coordinates has been inside of CS-MAP for many years. However, this capability has been hidden inside of the datum conversion functions. In this release, this capability is now explicitly available in functions named  CS_llhToXyz  and  CS_xyzToLlh  which are defined in the  CS_dtCalc.c  module.  Note that each of these functions requires the definition of the ellipsoid in use, expressed as two separate double arguments: equatorial radius and eccentricity squared.", 
            "title": "Geocentric Coordinates"
        }, 
        {
            "location": "/userguide/desc/#mgrs-implementation", 
            "text": "Release 11.01 includes a series of new functions that provide the ability to generate MGRS designations from geographic coordinates, and vice versa. This implementation consists of 6 functions designed for application programmer use, and two supporting functions. The support functions may be of interest as they provide the ability to convert between geographic and UTM coordinates/zone number where the rather strange stuff which goes on in northern Europe (i.e. southern Norway and the Svaldberg Islands) is appropriately accounted for.  While written in 'C' to be consistent with the rest of CS-MAP, the implementation of the MGRS capability has a definite C++ structure to it. That is, there exists a structure definition, three constructors, a destructor, two public functions and two private functions (i.e. the supporting functions).", 
            "title": "MGRS Implementation"
        }, 
        {
            "location": "/userguide/desc/#mgrs-constructors", 
            "text": "Construction of a  cs_Mgrs_  object (i.e. allocation and initialization of a a  cs_Mgrs_  structure) requires knowledge of the ellipsoid definition to be used and if the alternative lettering sequence (i.e. Bessel) is to be used. Thus, the three constructors simply provide three different ways of specifying the ellipsoid which is to be used:   struct cs_Mgrs_ *CSnewMgrs (double e_rad,double e_sq,short bessel);\n struct cs_Mgrs_ *CSnewMgrsE (const char *elKeyName,short bessel);\n struct cs_Mgrs_ *CSnewMgrsD (const char *dtKeyName,short bessel);  where the  elKeyname  argument can be used to specify the ellipsoid by key name. Alternatively, application programmers can specify a datum name (the  dtKeyName  argument) and the calculations will be based on the ellipsoid upon which the datum is referenced. Of course, the application programmer can use the  e_rad  and  e_sq  version to specify the equatorial radius and square of eccentricity directly. In all cases, the  bessel  argument is zero to indicate the normal lettering scheme. +1 to indicate the alternative lettering scheme.  All constructors return the null pointer in the event of an error. Use  CS_errmsg  to obtain a string that describes the nature of the error.", 
            "title": "MGRS Constructors"
        }, 
        {
            "location": "/userguide/desc/#mgrs-destructor", 
            "text": "Use  CSdeleteMgrs  to delete a  cs_Mgrs_  object constructed by one of the constructors. Currently, a call of  CS_free  will accomplish the same thing, but maybe not in the future.  void CSdeleteMgsr (struct cs_Mgrs_ * __This);  Like it's C++ equivalent, this function is smart enough not to attempt to free a null pointer.", 
            "title": "MGRS Destructor"
        }, 
        {
            "location": "/userguide/desc/#mgrs-public-functions", 
            "text": "Naturally enough, two conversion functions exists. Given a properly initialized  cs_Mgrs_  object (i.e. structure) and a geographic coordinate,  CScalcMgrsFromLl  will return the appropriate MGRS designation.  CScalcLlFromMgrs  reverses the process. In both cases, a return value of zero indicates success, non-zero indicates failure. Use  CS_errmsg  to obtain a description of the cause of failure.  int CScalcMgrsFromLl (struct cs_Mgrs_ *__This, char *result, int size, double latLng [2], int prec);\nint CScalcLlFromMgrs (struct cs_Mgrs_ *__This,double latLng [2], Const char *mgrsString);  In these prototypes, the first argument is a pointer to an initialized  cs_Mgrs_  object obtained from one of the constructors described above. The  latLng  argument refers to an array of at least two doubles which contain the longitude and latitude (in that order) in degrees. The  prec  argument indicates the number of digits to be included in the resulting MGRS designation. Valid values range from 0 to 5. Note, that a value of 5 indicates that 5 easting, and 5 northing digits will be included in the resulting string. Of course,  CScalcMgrsFromLl  will never write more than  size  characters to the result array, and (assuming  size  is greater than zero) will cause result to be null terminated.", 
            "title": "MGRS Public Functions"
        }, 
        {
            "location": "/userguide/desc/#mgrs-private-functions", 
            "text": "Two \"private\" functions, i.e. internal support functions, exist which convert geographic coordinates to UTM/UPS coordinates and zone number. These functions are aware of the missing/widened zones in the northern Europe region. They are also capable of switching between UTM and UPS (Universal Polar Stereographic) coordinates as appropriate. These functions use a  utmZone  variable which carries the UTM zone number where: 1) northern UTM zones are positive numbers between 1 and 60 inclusive, 2) southern UTM zones are negative numbers between \u20131 and \u201360 inclusive, 3) +61 refers to the North Pole UPS zone, 4) \u201361 refers to the South Pole UPS Zone,, and 5) the value zero is invalid and used to indicate an error condition.  int CScalcUtmUps (struct cs_Mgrs_ *__This,double utmUps [2], const double latLng [2]);\nint CScalcLatLng (struct cs_Mgrs_ *__This,double latLng [2], const double utmUps [2], int utmZone);  Given a geographic coordinate,  CScalcUtmUps  calculates the appropriate UTM/UPS coordinates and returns the appropriate  utmZone  value. Given a UTM/UPS coordinate and  utmZone  value,  CScalcLatLng  returns the appropriate geographic coordinate.  CScalcLatLng  returns zero on success, non-zero on failure. In all cases, the calculation is based on the ellipsoid used to construct the  cs_Mgrs_  argument to the function.", 
            "title": "MGRS Private Functions"
        }, 
        {
            "location": "/userguide/desc/#forwardinverse-functions", 
            "text": "The term Forward/Inverse is a common way of referring to what is also known as the basic geodesy problem. That is, given a geodetic latitude/longitude, calculate the a new position given an azimuth and distance. This may sound pretty simple, but the calculation must be carried out on the ellipsoid. Thus the calculation is rather complex.  Forward refers to the calculation of a new geodetic position given an azimuth and a distance. Inverse refers to the calculation of an azimuth and distance given two geodetic positions.  CS_llazdd  performs the forward calculation, and  CS_azddll  performs the inverse calculation.", 
            "title": "Forward/Inverse Functions"
        }, 
        {
            "location": "/userguide/desc/#error-handling", 
            "text": "Having it origins in the 'C' language, error reporting in the CS-MAP library is implemented using the return status methodology. That is, functions which can detect abnormal situations will return an integer status value to indicate the success of the operation intended, Status returns are of two types.  With the exceptions described below, all CS-MAP functions which can detect an abnormal situation will return a zero for success. A negative value will be returned for a failure which is considered fatal, and a non-zero positive value is returned for a warning or providing information about a remarkable condition.  While fatal errors can and do occur during the setup phase of a conversion/transformation combination, it is an important part of the design of CS-MAP that fatal errors cannot occur with conversion and transformation functions. Thus, any function involved in the creation and/or initialization of a conversion or transformation can be expected to return a negative status value. Functions which actually perform the conversion and/or transformation calculations can be expected to never return a negative status.  In the event of a negative status return, applications should immediately call the CS_errmsg function which will return an (8 bit character, English only) textual description of the cause of the problem. This description will often include, when appropriate, contextual information such as file names etc.  Status return values from calculation functions are always positive and non-zero values usually indicate that the coordinate to be converted is:   Outside the useful range of the coordinate system being used,  Outside the coverage area of a grid shift data file,  Would have produced a domain error (i.e. log (-1))  Or the coordinate is at either pole (which means any longitude is equivalent to any other).   In any case, the calculation function will indeed return a rational value. In many cases, this rational value will be produced by what is called a fallback technique.  In the experience of the developers of CS-MAP, once a conversion/transformation operation has been successfully constructed (i.e. setup), applications should at most simply count the number of non-zero positive status values returned by the calculation functions and report this number to the user (assuming it is non-zero) upon completion of the conversion. That is, a non-zero status return from any and all calculation functions should be considered as information only. Otherwise, your application will be bogged down and end user's can easily come to the conclusion that your application has crashed.  Also note, that to keep performance levels high, a non-zero positive status return value does not cause the generation of a descriptive error message and calling CS_errmsg after encountering a positive status return will produce misleading information, is anything at all.", 
            "title": "Error Handling"
        }, 
        {
            "location": "/userguide/desc/#exception", 
            "text": "There are several functions in CS-MAP whose function in life is to enumerate a list of entries in internal lists or dictionaries. These functions tend to return a positive 1 value to indicate success. A zero is returned to indicate that the end of the sequence has been encounters. (Of course, a negative return value indicates a fatal error of some sort. This convention was chosen so as to make obtaining such a list or enumeration rather easy to code in a robust manner:  int index;\nchar elpName [cs_KEEN_DEC};\n.\n.\n.\nindex = 0;\nwhile (CS_elEnum (index++,eleVate)   0)\n{\n  /* Do something with this name */\n  .\n  .\n  .\n}", 
            "title": "Exception"
        }, 
        {
            "location": "/userguide/desc/#data-structures", 
            "text": "Discussions which follow refer to the primary data structures of CS-MAP. Twelve such data structures are described. These structure provide the basis for the operation of the Coordinate System Mapping Package. All structure definitions are found in the  cs_map.h  header file.", 
            "title": "Data Structures"
        }, 
        {
            "location": "/userguide/desc/#ellipsoid-definition-structure", 
            "text": "The Ellipsoid Definition structure,  cs_Eldef_ , carries the two principal data elements (among others) which define an ellipsoid for our purposes. These are the equatorial radius and the eccentricity of the ellipsoid. Among the other items contained in the structure is a key name, which is used to distinguish one ellipsoid definition from another.", 
            "title": "Ellipsoid Definition Structure"
        }, 
        {
            "location": "/userguide/desc/#datum-definition-structure", 
            "text": "The Datum Definition structure,  cs_Dtdef_ , carries the eight principal data elements (among others) which define a datum for our purposes. These are the key name of the ellipsoid definition upon which the datum is based, the X, Y, and Z components of the vector from the geocenter of the datum being defined to the geocenter of the WGS84 ellipsoid, the three rotation components of the transformation, and the scale component of the transformation. Among the other elements contained in this structure is a datum key name which is used to distinguish one datum definition from another.", 
            "title": "Datum Definition Structure"
        }, 
        {
            "location": "/userguide/desc/#datum-composite-structure", 
            "text": "The Datum Composite structure,  cs_Datum_ , carries the contents of both the Datum Definition structure and the Ellipsoid Definition structure in an composite form. This structure is never written to disk and is used internally as a programming convenience.", 
            "title": "Datum Composite Structure"
        }, 
        {
            "location": "/userguide/desc/#coordinate-system-definition-structure", 
            "text": "The Coordinate System Definition structure,  cs_Csdef_ , carries all the elements required to define a coordinate system. Twenty four of these elements are referred to as projection parameters as their use depends upon the projection in use (which is one of the other data elements). Therefore, it is difficult to describe their use without delving into the specifics of each projection.  For our purposes here, let it be said that the  cs_Csdef_  structure is capable of carrying the definition of any coordinate system based on any one of the thirty eight projections supported by CS-MAP and (hopefully) any others which may be added in the future. This includes the parameters specific to the projection, the projection origin, the coordinate system units, the coordinate system scale, the false easting, the false northing, etc.", 
            "title": "Coordinate System Definition Structure"
        }, 
        {
            "location": "/userguide/desc/#preprocessed-projection-structures", 
            "text": "There exists one structure for each of the thirty eight projections which carry the definition of a coordinate system based on the respective projection in a preprocessed form. That is, once the specific projection parameters applicable to a specific coordinate system are established, there are many calculations which can be performed independent of the specific coordinates to be converted. The results of these calculations are stored in these structures. The thirty five structure names are shown in Table III. It is the content of these structures which actually control the conversion of cartesian coordinates to and from latitudes and longitudes.", 
            "title": "Preprocessed Projection Structures"
        }, 
        {
            "location": "/userguide/desc/#coordinate-system-parameter-structure", 
            "text": "The Coordinate System Parameter Structure,  cs_Csprm_ , is used to carry a complete definition of a coordinate system and is the single structure used throughout the development of a coordinate conversion. It contains a copy of the  cs_Csdef_  structure of the coordinate system being used, a copy of the  cs_Datum_  structure which the coordinate system definition references, and the coordinate system in its pre-processed form as a union of the thirty eight pre-processed parameter structures described above. It also contains pointers to the functions which are capable of performing the forward and inverse coordinate conversions. Pointers are also included for grid scale and convergence angle functions.  cs_Csprm_  also includes information about the specific projection in use, as well as the limits of the coordinate system, both in cartesian and geographic form. While CS-MAP is designed such that the application should not need to know anything about the projection, there are instances (such as our own test program) where some knowledge of the projection in use, or its specific features, is helpful.  As a result, this single structure represents a complete definition of a coordinate system which can be easily passed around by pointer. Through the use of pointers to the appropriate coordinate conversion functions contain in this structure, modules which receive a pointer to this structure do not ever have to know exactly which projection is in use in order to perform coordinate conversions.", 
            "title": "Coordinate System Parameter Structure"
        }, 
        {
            "location": "/userguide/desc/#projection-name-table-structure", 
            "text": "The Projection Name Table Structure,  cs_Prjtab_ , is used solely to create a table of the projections known to the system. It primarily associates a name with a projection code and a setup function. To add new projections to the system, one need only create an entry in this table and reference the code which, of course, must also be written. You can also add additional names for existing projections by simply making additions to this table.  More importantly, to remove a projection from the system (in order to reduce the size of the text space within an executable, for example), one need simply remove (or comment out) the projection's entry in this table.  In developing a coordinate system parameter structure, the name of the projection is extracted from the coordinate system definition. This name is located in the projection table. The projection setup function associated with the selected named entry is then called and given a pointer to the union of pre- processed structures. The setup function initializes the union as if it were the pre-processed structure associated with the projection under construction. Of course, CS-MAP does all of this, mostly in the function named  CS_csloc .  The Projection Name Table includes a fully descriptive name of each projection as well as a bit map of the features of the projection. Refer to  CSdataPJ .", 
            "title": "Projection Name Table Structure"
        }, 
        {
            "location": "/userguide/desc/#datum-shift-definition-structure", 
            "text": "The Datum Shift Definition structure,  cs_Dtcprm_ , carries all of the information necessary to perform a datum shift on geographic coordinates (i.e. latitude and longitude). The information contained in this structure includes the definition of the source and target datums and a road map of the various conversions necessary to get, in the most accurate form, from the source datum to the target datum. This structure is allocated upon request given the definitions of the source and target coordinate systems. Once properly allocated, a pointer to this structure is all that the datum shift function needs in order to calculate datum shifts.  Thus, applications do not need to have any knowledge of what datums or how many different conversions are necessary to get from one datum to the next. In fact, quite often the conversion is the null conversion which implies that the source latitude and longitude are simply copied to the target array. Again, in this case, the application has no need to know of this situation.  The above is possible only because CS-MAP (to a large extent) requires that all datum definitions define how to convert a specific datum to/from WGS84. Thus, by \"going through\" WGS84 CS-MAP can convert any coordinate system/datum to any other. There are certain exceptions to this basic theme.", 
            "title": "Datum Shift Definition Structure"
        }, 
        {
            "location": "/userguide/desc/#the-data-dictionaries", 
            "text": "The Coordinate System Mapping Package includes the definition of more than 1,000 commonly used coordinate systems, more than 130 datum definitions, and 37 commonly referenced ellipsoids. These definitions are carried in the Coordinate System Dictionary (a file usually named  Coordsys ), the Datum Dictionary (a file usually named Datums), and the Ellipsoid Dictionary (a file usually named  Elipsoid ) respectively. These files are normally expected to reside in the  C:\\MAPPING  directory ( /usr/MAPPING  under UNIX). The location of these files can be modified to suit your requirements at compile time (see  CSdata ) or at run time (see  CS_altdr ). The names of these files can be changed either at run time (see  CS_csfnm ,  CS_dtfnm , and  CS_elfnm ) or compile time (see  cs_map.h ).", 
            "title": "The Data Dictionaries"
        }, 
        {
            "location": "/userguide/desc/#the-coordinate-system-dictionary", 
            "text": "The Coordinate System Dictionary is a fixed length record file of  cs_Csdef_  structures, maintained in sorted order by the key_nm element, i.e. the coordinate system key name. Entries in this file are located through the use of the binary search technique, therefore it is important that this file remain in sorted order. The file has a magic number in the first four bytes. This is a sequence of bytes which identify the file as being a Coordinate System Dictionary file and is defined by the  cs_CSDEF_MAGIC  manifest constant in  cs_map.h . This value is checked each time the file is opened to make sure that the file is indeed a Coordinate System Dictionary and that it has not been seriously corrupted. The specific value of the magic number is changed each time the format of the  cs_Csdef_  structure is changed.  Functions are provided to access and maintain this file as a Coordinate System Dictionary.  CS_csopn  will open the file, verify its magic number, and return a file descriptor (or handle).  CS_csrd  and  CS_cswr  will perform sequential reads from and writes to a file of this type, handling encryption appropriately.  CS_cscmp  compares records in the file for sorting and searching purposes.  CS_csdef  will extract a particular record from the dictionary for you.  CS_csupd  will update an existing entry or add a new entry to the Coordinate System Dictionary, assuring that the file remains in sorted order. Finally,  CS_csdel  can be used to delete a record from the dictionary.  Coordinate system definitions are verified for validity before they are written to the Coordinate System Dictionary through the use of the  CS_cschk  function.  CS_csloc  (described below) also checks each definition before it is actually used to create the active form of a coordinate system.", 
            "title": "The Coordinate System Dictionary"
        }, 
        {
            "location": "/userguide/desc/#the-datum-dictionary", 
            "text": "The Datum Dictionary is a fixed length record file of  cs_Dtdef_  structures, maintained in sorted order by the  key_nm  element, i.e. the datum key name. Entries in this file are located through the use of the binary search technique, therefore it is important that this file remain in sorted order. The file has a magic number in the first four bytes of the file and is defined by the  cs_DTDEF_MAGIC  manifest constant in  cs_map.h . This is a sequence of bytes which identify the file as being a Datum Dictionary file. This value is checked each time the file is opened to make sure that the file is indeed a Datum Dictionary and that it has not been seriously corrupted. The specific value of the magic number is changed each time the format of the  cs_Dtdef_  structure is changed.  Functions are provided to access and maintain this file as a Datum Dictionary.  CS_dtopn  will open the file, verify its magic number, and return a file descriptor (or handle).  CS_dtrd  and  CS_dtwr  will perform sequential reads from and writes to a file of this type, handling encryption appropriately.  CS_dtcmp  compares Datum Dictionary entries for sorting and searching purposes.  CS_dtdef  will extract a particular record from the dictionary for you.  CS_dtupd  will update an existing entry or add a new entry to the Datum Dictionary, assuring that the file remains in sorted order. Finally,  CS_dtdel  can be used to delete a record from the dictionary.", 
            "title": "The Datum Dictionary"
        }, 
        {
            "location": "/userguide/desc/#the-ellipsoid-dictionary", 
            "text": "The Ellipsoid Dictionary is a fixed length record file of  cs_Eldef_  structures, maintained in sorted order by the key_nm element, i.e. the ellipsoid name. Entries in this file are located through the use of the binary search technique, therefore it is important that this file remain in sorted order. The file has a magic number in the first four bytes of the file and is defined by the  cs_ELDEF_MAGIC  manifest constant in  cs_map.h . This is a sequence of bytes which identify the file as being a Ellipsoid Dictionary file. This value is checked each time the file is opened to make sure that the file is indeed an Ellipsoid Dictionary and that it has not been seriously corrupted. The specific value of the magic number is changed each time the format of the  cs_Eldef_  structure is changed.  Functions are provided to access and maintain this file as a Ellipsoid Dictionary.  CS_elopn  will open the file, verify its magic number, and return a file descriptor (or handle).  CS_elrd  and  CS_elwr  will perform sequential reads from and writes to a file of this type, handling encryption appropriately.  CS_elcmp  compares Ellipsoid Dictionary entries for sorting and searching purposes.  CS_eldef  will extract a particular record from the dictionary for you.  CS_elupd  will update an existing entry or add a new entry to the Ellipsoid Dictionary, assuring that the file remains in sorted order. Finally,  CS_eldel  can be used to delete a record from the dictionary.", 
            "title": "The Ellipsoid Dictionary"
        }, 
        {
            "location": "/userguide/desc/#dictionary-encryption", 
            "text": "The definitions of coordinate systems, datums, and ellipsoids can represent a significant investment on the part of the application developer. Under certain circumstances, a demonstration disk for example, the application developer may not wish to provide this information in a form from which this valuable data can be easily extracted. As a result, CS-MAP fully supports a means by which dictionary data can be encrypted. All CS-MAP functions will work equally as well with encrypted dictionaries as with normal versions. Dictionary compilers normally produce dictionaries in encrypted form. An option is provided to produce unencrypted dictionaries.", 
            "title": "Dictionary Encryption"
        }, 
        {
            "location": "/userguide/desc/#dictionary-definition-protection", 
            "text": "Dictionary entries are normally protected. That is, changes to coordinate system, datum, and ellipsoid definitions are controlled. This reduces technical support calls significantly. Application programmers can control the extent of protection, or turn it off altogether. How this system works is described below.  In normal operation, CS-MAP will not allow end users to change definitions distributed with the application. More specifically, definitions created by the Dictionary Compiler are marked as to be protected. End users can, and often do, create new coordinate system definitions. Therefore, rather than change a coordinate system as distributed with the application, users would typically create a new definition which is modified as necessary to achieve the desired results.  Definitions created by end users, and which remain unchanged for 60 days, are also protected. This is done under the assumption that a definition which remains unchanged for 60 days will have been used and judged satisfactory, and therefore should be preserved as a means of recording the actual definition used to produce the results.  Finally, CS-MAP normally requires that the key names for all user defined definitions contain the colon character. By adopting this convention, application updates can include coordinate system updates without the possibility of the update overwriting a valid and valuable user defined definition. (This, of course, assumes that the distribution will never contain a coordinate system definition with a key name containing a colon character.)  Application programmers can control to what degree the protection system is active by simply setting the value of either, or both, of two global variables, either at compile time (see  CSdata.c ) or at run time.  char cs_Unique ; In the CS-MAP distribution, the value of this global variable is set to the colon. Set the value of this variable to the null character to turn the user definition key name protection feature described above off. You can select a character other than the colon by simply setting this variable to the desired character.  short cs_Protect ; Use this variable to control the protect applied to dictionary definitions. A positive, non-zero value is the number of days associated with the user defined definition protection described above. For example, in the CS-MAP distribution, this value is set to 60, indicating that after a user defined definition remains unchanged for 60 days, it automatically becomes protected. Set  cs_Protect  to zero to maintain distribution coordinate system protection, but disable all user defined definition protection. Set  cs_Protect  to a negative value to disable all dictionary definition protection.  Programmer Note : Dictionary definitions include a short which controls the protection of the definition. If this value is set to zero, the dictionary entry is permanently unprotected. If this value is set to one, the entry is permanently protected. Otherwise, this value is set to the date at which the definition was last modified expressed as the number of days since January 1, 1990. Thus, changing the value of  cs_Protect  will change the protection of user defined definitions in a dynamic manner", 
            "title": "Dictionary Definition Protection"
        }, 
        {
            "location": "/userguide/desc/#byte-ordering", 
            "text": "All three dictionary files described in this section contain data in binary form, thus byte ordering becomes a serious issue when using CS-MAP on different platforms. Beginning with Release 6.0 of CS-MAP, dictionaries are expected to be in little endian byte order regardless of the platform in use. A byte swapping function,  CS_bswap , is called immediately after each read from any of these dictionaries, and immediately before the write of any data to any of the dictionaries.  CS_bswap  is programmed to automatically determine if byte swapping is required based on a compile time constant. Thus, a single copy of these dictionaries can be distributed for use on all platforms.  The term \"all platforms\" is perhaps misleading.  CS_bswap  will only swap between little endian and big endian byte orders. The rather odd byte orderings of some older DEC machines is not supported at the current time.  The automatic byte ordering feature is easy to disable if so desired. Refer to  CS_bswap  for more information.  The automatic byte ordering feature also applies to all other binary data files upon which CS-MAP relies. That is, automatic byte swapping is applied to all reads from NADCON database files, Multiple Regression data files, Canadian National Transformation files, and all HPGN database files. The choice of using little endian byte ordering was natural as these files are generally distributed by their sources in this form.", 
            "title": "Byte Ordering"
        }, 
        {
            "location": "/userguide/desc/#dictionary-compiler", 
            "text": "ASCII versions of the three dictionaries are provided in the distribution. The names of these files are  COORDSYS.ASC ,  DATUMS.ASC , and  ELIPSOID.ASC . Binary versions of the dictionary files can be produced by using the dictionary compiler program  CS_COMP . This enables the definition files to be committed to version control procedures and the dictionaries remade as part of your product manufacturing process.  Originally, the ASCII files and the compilers were provided as a means of overcoming the byte order problem on different platforms. Now that CS-MAP has been modified to process little endian files on all platforms, this purpose is now obsolete. The version control purpose of these files remains valid.", 
            "title": "Dictionary Compiler"
        }, 
        {
            "location": "/userguide/desc/#multiple-regression-datum-transformation-files", 
            "text": "The compiler referred to above will also compile a fourth ASCII source file named  MREG.ASC  which is also supplied in the distribution.  MREG.ASC  contains in an ASCII, version controllable form, the definition of all multiple regression transformations known to the system. Compiling this file produces the  .MRT  files which CS-MAP accesses, as necessary, when performing datum conversions. Your application distribution should include the  .MRT  files produced by compiling the  MREG.ASC  file.", 
            "title": "Multiple Regression Datum Transformation Files"
        }, 
        {
            "location": "/userguide/desc/#default-datums-ellipsoids-and-units", 
            "text": "CS-MAP supports the concept of default datums, ellipsoids, and/or units. Defaults represent a convenient way to switch a coordinate system definition between different datums, ellipsoids, and/or units without having to change the Coordinate System Dictionary. How this feature applies to datums is described first; and this description is then extended to ellipsoids and units.  A datum reference in a coordinate system definition may be marked as \"defaultable\" by enclosing the name in square brackets. The actual datum name provided must be a valid datum reference as this reference will be used whenever the default feature is not active. This also implies that the default feature need not be active for the coordinate system definition to be valid and usable.  Upon activation of a coordinate system, regardless of the interface used, CS-MAP will check to see if the datum specified is \"defaultable\". If so, it examines the current default datum setting. If a valid default datum has been specified, the \"defaultable\" datum reference is replaced by the current default setting and coordinate system setup continues. If there is no current default setting, the \"defaultable\" datum is used as is. Thus, in the absence of a default specification, the coordinate system definition operates as defined. Whenever a default replacement is performed, the replaced datum name in the  cs_Csdef_  element of the  cs_Csprm_  structure will be enclosed in parenthesis to indicate that a default replacement has occurred.  Use the  CS_dtdflt  function to define a default datum. It will return the status and the name of any previous default. It will not allow an invalid default setting to be made. Calling  CS_dtdflt  with the  NULL  pointer as its argument can be used to determine if the datum default feature is active and, if so, what the current default setting is. Call  CS_dtdflt  with a pointer to the null string to disable the datum default feature. Until  CS_dtdflt  is called with a valid datum reference, the datum default feature remains disabled.  Cartographically referenced coordinate systems, and datum definitions, can contain \"defaultable\" ellipsoid references. Use  CS_eldflt  to enable and disable the \"defaultable\" ellipsoid feature.  Coordinate system unit specifications can also be \"defaultable\". Separate default values are maintained for linear and angular units. Use  CS_ludflt  to control the state of linear unit defaults, and  CS_audflt  to control the state of angular unit defaults.  You can completely ignore this concept of default datums, ellipsoids, and units by simply not calling (or even referencing) any of the default functions mentioned above. Default processing is off by default, and by never calling any of these functions, it never gets turned on. This is how most users deal with the default feature.", 
            "title": "Default Datums, Ellipsoids, and Units"
        }, 
        {
            "location": "/userguide/desc/#high-performance-interface", 
            "text": "The High Performance Interface to the Coordinate System Mapping Package consists of thirteen functions. By virtue of the data structures described above, use of these functions is independent of the actual coordinate systems, projections, or datums in use. This represents the most efficient means to use CS-MAP to convert coordinates from one coordinate system to another. It also insulates your applications from most changes which could be made to the CS-MAP in the future. This basic API has not changed since 1992. This interface requires the use of structure pointers and, therefore, may not be appropriate for use with some languages. Therefore, use this interface wherever high performance is a top priority and the application is written in a language which can handle pointers such as C, C++, or Pascal.  These functions make use of the Coordinate System Dictionary, the Datum Dictionary, the Ellipsoid Dictionary, and the functions which access them. This need not be of concern to the application programmer using the High Performance Interface as it all goes on \"behind the scenes\".  In this section, our intent is to associate function names with capabilities and features.", 
            "title": "High Performance Interface"
        }, 
        {
            "location": "/userguide/desc/#the-functions", 
            "text": "The thirteen functions which comprise the High Performance Interface are  CS_csloc ,  CS_dtcsu ,  CS_ll2cs ,  CS_dtcvt ,  CS_cs2ll ,  CS_dtcls ,  CS_csscl ,  CS_cnvrg ,  CS_cssch ,  CS_cssck ,  CS_llchk ,  CS_xychk , and  CS_free . The typical coordinate conversion application uses only seven of these function.  Refer to the major sections following this to see how the use of these functions is combined to produced generalized coordinate conversion capabilities.", 
            "title": "The Functions"
        }, 
        {
            "location": "/userguide/desc/#coordinate-system-locate", 
            "text": "Given the key name of a coordinate system defined in the Coordinate System Dictionary,  CS_csloc  returns a pointer to a fully initialized  cs_Csprm_  structure. This initialization includes all of the \"one- time\" calculations and the establishment of pointers to the appropriate coordinate conversion functions. This structure is  malloc 'ed from dynamic memory. Therefore, you may have several such definitions active at any given time. Also, you should release these structures when your application no longer has need of them; use  CS_free .", 
            "title": "Coordinate System Locate"
        }, 
        {
            "location": "/userguide/desc/#datum-conversion-setup", 
            "text": "Given pointers to the both the source and target coordinate systems as returned by  CS_csloc ,  CS_dtcsu  returns a pointer to a  malloc 'ed  cs_Dtcprm_  structure which is a required argument to the  CS_dtcvt  function which actually calculates datum shifts. As its name implies,  CS_dtcsu  \"sets up\" a datum conversion by allocating and initializing a  cs_Dtcprm_  structure. Since datum conversions often require the use of file descriptors, grid cell caches, and the like, do not use  free  or  CS_free  to release the  cs_Dtcprm_  structure returned by  CS_dtcsu . The sixth function of this interface,  CS_dtcls  must be used instead to prevent memory and file descriptor leaks in your application. Note, when appropriate,  CS_dtcsu  returns a pointer to a null datum conversion; a conversion which does nothing successfully and rapidly.", 
            "title": "Datum Conversion Setup"
        }, 
        {
            "location": "/userguide/desc/#coordinate-system-to-latlong-conversion", 
            "text": "Given a pointer to an initialized  cs_Csprm_  structure which describes the coordinate system in use, the  CS_cs2ll  function will convert a cartesian coordinate to geographic form in terms of latitude and longitude in internal form. The resulting geographic coordinate will be based on the same datum as the coordinate system defined in the provided  cs_Csprm_  structure.  The conversion function pointers inserted into the  cs_Csprm_  structure by  CS_csloc  are used to select the proper code for the conversion. The application has no need to know what projection is in use or, for that matter, anything else about the coordinate system in use", 
            "title": "Coordinate System to Lat/Long Conversion"
        }, 
        {
            "location": "/userguide/desc/#datum-conversion", 
            "text": "Given a pointer to an initialized datum conversion parameter structure,  cs_Dtcprm_ , as returned by  CS_dtcsu , the  CS_dtcvt  function will convert the supplied geographic coordinates from the source datum to the target datum.", 
            "title": "Datum Conversion"
        }, 
        {
            "location": "/userguide/desc/#latlong-to-coordinate-system-conversion", 
            "text": "Given a pointer to an initialized  cs_Csprm_  structure, the  CS_ll2cs  function will convert a geographic coordinate specified in terms of latitude and longitude (in degrees) to the coordinates of the coordinate system defined by the  cs_Csprm_  structure.  The conversion function pointers inserted into the  cs_Csprm_  structure by  CS_csloc  are used to select the proper code for the conversion. The application has no need to know what projection is in use or, for that matter, anything else about the coordinate system in use.", 
            "title": "Lat/Long to Coordinate System Conversion"
        }, 
        {
            "location": "/userguide/desc/#close-datum-conversion", 
            "text": "Given a pointer to an initialized datum conversion parameter structure, as returned by the  CS_dtcsu  function,  CS_dtcls  will release all system resources allocated for the specific datum conversion. Note, that since several datum conversions may be initialized and operative at any given time,  CS_dtcls  does not necessarily release all resources associated with certain datum transformations until such time as the last datum conversion parameter block referencing such resources is closed.", 
            "title": "Close Datum Conversion"
        }, 
        {
            "location": "/userguide/desc/#grid-scale-factor", 
            "text": "Given a pointer to an initialized  cs_Csprm_  structure as returned by the  CS_csloc  function,  CS_csscl  will return the grid scale factor for the coordinate system at a location indicated by a geographic coordinate. It is important to note that the concept of Grid Scale as a single number applies only to coordinate systems based on conformal projections such as the Transverse Mercator, Lambert Conformal Conic, and the Oblique Mercator. Other projections, such as equal area projections, will have two such scale factors. In the case of equidistant projections, there are two such scale factors but one of them will usually be one. In the case on non-conformal projections,  CS_csscl  will return what the designers of CS-MAP consider the more interesting of the two scale factors for the specific projection involved.", 
            "title": "Grid Scale Factor"
        }, 
        {
            "location": "/userguide/desc/#scale-along-a-parallel", 
            "text": "The two scale factors mentioned above consist of the scale along a parallel, often referred to as 'k', and the scale along a meridian, referred to as 'h'. Given a pointer to an initialized  cs_Csprm_  structure as returned by  CS_csloc ,  CS_cssck  will always return the scale factor along a parallel at the location provided.  The nomenclature referred to here is that used by J. P. Snyder in  Map Projections - A Working Manual . Other authors use different symbology. In his later work,  Map Projections - A Reference Manual , Snyder uses the more common notation. CS-MAP, whose origins date back to 1987, uses the original Snyder notation.", 
            "title": "Scale Along a Parallel"
        }, 
        {
            "location": "/userguide/desc/#scale-along-a-meridian", 
            "text": "Given a pointer to an initialized  cs_Csprm_  structure,  CS_cssch  returns the scale along a meridian, often referred to as 'h', at the location given by its second argument which must be a geographic coordinate.", 
            "title": "Scale Along a Meridian"
        }, 
        {
            "location": "/userguide/desc/#convergence-angle", 
            "text": "Given a pointer to an initialized  cs_Csprm_  structure as returned by  CS_csloc ,  CS_cnvrg  returns the convergence angle of the coordinate system, at the location indicated by the second argument which must be a geographic coordinate. The return value is in degrees; positive is east of north.", 
            "title": "Convergence Angle"
        }, 
        {
            "location": "/userguide/desc/#check-limits-geographic", 
            "text": "Given a pointer to an initialized  cs_Csprm_  structure as returned by  CS_csloc ,  CS_llchk  will determine if all coordinates in the list provided are within the mathematical domain of the coordinate system and/or with the useful range of the coordinate system. In the case where the provided list contains two or more points, the determination applies to each coordinate on each great circle arc formed by consecutive geographic coordinates. In those cases where the provided coordinate list consists of four or more geographic coordinates which define a closed region, the determination applies to all coordinates enclosed within the region, or which reside the provided boundary.", 
            "title": "Check Limits, Geographic"
        }, 
        {
            "location": "/userguide/desc/#check-limits-cartesian", 
            "text": "Given a pointer to an initialized  cs_Csprm_  structure as returned by  CS_csloc ,  CS_xychk  will determine if all coordinates in the list provided are within the mathematical domain of the coordinate system and/or with the useful range of the coordinate system. In the case where the provided list contains two or more points, the determination applies to each coordinate on each line segment formed by consecutive cartesian coordinates. In those cases where the provided coordinate list consists of four or more cartesian coordinates which define a closed region, the determination applies to all coordinates enclosed within the region, or which reside on the provided boundary.", 
            "title": "Check Limits, Cartesian"
        }, 
        {
            "location": "/userguide/desc/#free-coordinate-system-parameters", 
            "text": "Use  CS_free  to free memory allocated by the any CS-MAP functions. This function is to be used, for example, to free the coordinate system parameter block returned by  CS_csloc . It is important that CS_free be used as in certain environments (a Windows DLL for example), the heap used by the library is not necessarily the same as the heap used by the application. Thus, if CS-MAP allocated the memory, it is best if CS-MAP releases it also.", 
            "title": "Free Coordinate System Parameters"
        }, 
        {
            "location": "/userguide/desc/#coordinate-system-to-coordinate-system", 
            "text": "In order to convert from one coordinate system to another, one simply obtains, from the  CS_csloc  function, a definition of the two coordinate systems of concern. The inverse function,  CS_cs2ll , is used to convert the source coordinates to latitude and longitude and the forward function,  CS_ll2cs , is used to convert to the target coordinate system. The sample code segment shown is, for example, all the code necessary to convert a file of NAD27 based UTM Zone 13 (UTM27-13) coordinates to NAD27 based Colorado State Plane, Southern Zone (CO-S). To change the conversion to use other coordinate systems, only the names provided to the  CS_csloc  function need be changed. Of course, these strings are rarely hard coded as has been done in this example.  int input, output;\ndouble xy [2], ll [2];\nstruct cs_Csprm_ *utm, *co_s;\nutm = CS_csloc ( UTM27-13 );\nco_s = CS_csloc ( CO-S );\nwhile (read (input, xy, sizeof (xy)) != 0)\n{\n   CS_cs2ll (utm,ll,xy);\n   CS_ll2cs (co_s,xy,ll);\n   write (output,xy,sizeof (xy));\n}\nCS_free (utm);\nCS_free (co_s);", 
            "title": "Coordinate System to Coordinate System"
        }, 
        {
            "location": "/userguide/desc/#the-ll-coordinate-system", 
            "text": "Many products will use the above scheme to provide the ability to convert from any coordinate system to any another. This scheme is completely general, supporting any combination of coordinate systems. Sometimes, however, it is desirable to convert from or to geographic coordinates. The  LL  coordinate system and the Unity projection accommodate this within the general scheme of things described above. That is, the  LL  coordinate system is simply a coordinate system in which the coordinates are latitudes and longitudes, and the Unity projection is simply a set of conversion functions which do little other than possible units and prime meridian conversion.  Therefore, supplying a coordinate system name of  LL , for example, for either the input or output coordinate system will produce the desired results without the application program having to know about this specific situation. (Please note that  LL  is a cartographically referenced coordinate system. Coordinate systems  LL27  and  LL83  are usually used in practice.)  Latitude and longitude coordinates in different units or referenced to a prime meridian other than Greenwich are possible by defining different  LL  type coordinate systems. These definitions, all based on the Unity pseudo-projection, can include a units specification and a specification of a prime meridian other than zero (i.e. Greenwich).", 
            "title": "The LL Coordinate System"
        }, 
        {
            "location": "/userguide/desc/#multiple-conversions", 
            "text": "Please note, that since coordinate system definitions (as returned by  CS_csloc ) reside in \"heap\" memory, there is no practical limit as to the number of definitions which can be active at any given time. Therefore, using the three functions described above, several different coordinate conversions can be active at the same time.", 
            "title": "Multiple Conversions"
        }, 
        {
            "location": "/userguide/desc/#adding-datum-conversions-to-the-interface", 
            "text": "Datum conversions can be added to the basic scheme described above by adding calls to the datum conversion functions. Refer to the code given below for an example, paying special attention to the emphasized code. Once the two coordinate system definitions have been initialized, they are passed to  CS_dtcsu . By examining both the source and target coordinate system definitions,  CS_dtcsu  is able to determine which, if any, datum transformation techniques need to be applied to accomplish the desired conversion.  CS_dtcsu  will select one or more datum conversions as necessary to accomplish the desired conversion. For example, to convert from NAD27 to WGS72, three conversions are actually setup:   from NAD27 to NAD83 via the NADCON technique  NAD83 to WGS84 (which is currently a null conversion), and finally  WGS84 to WGS72 using a hard coded formula.   CS_dtcsu  assures that all preparations necessary for these conversions are initialized, and saves the results in the  cs_Dtcprm_  structure to which it returns a pointer.  In the actual coordinate conversion loop,  CS_dtcvt  is called for each coordinate once its geographic form has been obtained from  CS_cs2ll . Note that if  CS_dtcsu  determined that no datum conversion was required, the information contained in the  cs_Dtcprm_  structure which it returns causes  CS_dtcvt  to simply copy the source geographic coordinates to the target array. Finally, when the conversion process is complete,  CS_dtcls  is used to release any system resources which were allocated for the datum conversion and which are no longer needed.  int input, output;\ndouble xy [2], ll [2];\nstruct cs_Csprm_ *utm, *co83_s;\nstruct cs_Dtcprm_ *dtc_ptr;\n.\n.\nutm = CS_csloc ( UTM27-13 );\nco83_s = CS_csloc ( CO83-S );\ndtc_prm = CS_dtcsu (utm,co83_s,dat_err,blk_err);\n\nwhile (read (input,xy,sizeof (xy)) != 0)\n{\n   CS_cs2ll (utm,ll,xy);\n   CS_dtcvt (dtc_prm,ll,ll);\n   CS_ll2cs (co83_s,xy,ll);\n   write (output,xy,sizeof (xy));\n}\n\nCS_dtcls (dtc_prm);\nCS_free (utm);\nCS_free (co_s);", 
            "title": "Adding Datum Conversions to the Interface"
        }, 
        {
            "location": "/userguide/desc/#geodetically-referenced-coordinate-systems", 
            "text": "In the normal case, CS-MAP converts from one geodetically referenced system to another. In the sample code segment in the previous topic, for example,  UTM27-13  is referenced to  NAD27  and  CO83-C  is referenced to  NAD83 . The need for NAD27 to NAD83 conversion is unambiguous and performed automatically by CS-MAP's High Performance Interface without the application having to know of this situation. However, there are circumstances where a coordinate system cannot be referenced to a specific datum. For example, what datum should UTM zone 25 (middle of the Atlantic Ocean) be referenced to?  For various reasons, it is not always possible or convenient to reference a coordinate system to a specific datum. To handle such cases, CS-MAP supports the concept of a cartographically referenced coordinate system.", 
            "title": "Geodetically Referenced Coordinate Systems"
        }, 
        {
            "location": "/userguide/desc/#cartographically-referenced-coordinate-systems", 
            "text": "The  cs_Csdef_  structure, which carries the definition of all coordinate systems, has an ellipsoid key name element as well as a datum key name element. If the datum key name element is not the null string, the coordinate system is said to be geodetically referenced. If the datum key name element is the null string, the ellipsoid key name element must then carry the key name of an ellipsoid definition in the ellipsoid dictionary. In this case, the coordinate system is said to be cartographically referenced. (If both elements are not the null string, the ellipsoid key name field is ignored.)  The example shown previously in this section showed how conversions are performed between two geodetically referenced systems. If either of the two coordinate systems involved is cartographically referenced, or if both are cartographically referenced,  CS_dtcsu  simply returns the null datum conversion. Thus, for example, when the target coordinate system is cartographically referenced, the resulting coordinates are based on the source datum, whatever it may happen to be. Similarly, if the source is cartographically referenced and the target is geodetically referenced, there is an implied assumption that the source coordinates are based on the datum of the target. If both coordinate systems are cartographically referenced, we have no knowledge of the datums in either case and the conversion is strictly cartographic, hence the semantic convention adopted here.  Examination of the  COORDSYS.ASC  file will produce several cartographically referenced coordinate systems. Many of these are UTM zones in areas other than the US and Canada. (In the US and Canada, UTM zones can be reliably said to be based on either NAD27 or NAD83.) Perhaps the most important cartographically referenced coordinate system is that which is named LL. This enables us to use the LL coordinate system to convert generic Lat/Long's to any coordinate system, or convert any coordinate system to Lat/Long's based on the same datum as the source, what ever it might be.", 
            "title": "Cartographically Referenced Coordinate Systems"
        }, 
        {
            "location": "/userguide/desc/#cartographic-projections_1", 
            "text": "For each projection supported, there exist eight, possibly nine, functions which comprise the full implementation of a projection. The brief description of these functions is given below. These descriptions will be important to those adding a new projection as well.  Those adding projections to the system only need to add an entry to the projection table  cs_Prjtab . Doing so, you will need to add a pointer to the Definition Check and the Setup functions. To activate the proper parameter settings in the MFC dialog, you will also need to add the projection to the  cs_PrjprmMap  table. It is unlikely, but if your new projection uses a new type of parameter, you may need to add a new entry to the  cs_Prjprm  table. All of these tables are defined in the  CSdataPJ.c  module.", 
            "title": "Cartographic Projections"
        }, 
        {
            "location": "/userguide/desc/#program-environments", 
            "text": "Portability to a large variety of program environments is a major feature of CS-MAP. Thus, programmers accustomed to a single environment may consider some of the code and design of CS- MAP rather awkward or old fashioned. Nevertheless, by keeping things very basic and simple (e.g. binary searching a sorted fixed length record file), CS-MAP ports to just about any other environment without change and without requiring any additional software beyond the contents of a normal C runtime library.  However, simplicity is insufficient to cover the entire range of issues. In this section we discuss features and aspects of CS-MAP which are specifically intended for differing program environments.", 
            "title": "Program Environments"
        }, 
        {
            "location": "/userguide/desc/#multi-threaded-programming", 
            "text": "Beginning with release 8.0, CS-MAP is fully compatible with multi-threaded Windows environments. Threads are different from processes in that not only do they share their parents code space, the data space is also shared. Since CS-MAP uses several global variables, this presents a problem.  This problem is addressed by declaring each of the several dynamically used (i.e. non-constant) global variables to be (using the Microsoft vernacular)  __declspec  (thread). (In the Borland vernacular, its  __thread .) This causes each new thread to have it's own copy of these variables; but the initialization of these variables upon starting a new thread is unclear. In any case, we do count on the operating system being able to give us a separate copy of all of these variables for each new thread instance which is started.  In order to insure that each of these variables is properly initialized, we have provided the function named  CS_init . It should be called in each new thread just once, prior to any other CS-MAP function call in the thread. If the parent thread's value of the global  cs_Dir  and  cs_DirP  variables are valid, these values are preserved. If not they are initialized. In the case of several other variables, such as defaults, the application programmer may specify if these are to be inherited from the parent thread. Variables dealing with NAD27 to NAD83 datum conversions and the like are always initialized to the NULL state.  Thus, each thread will have its own set of NADCON data file buffers. In certain applications, this may be wasteful, but in most cases this provides the highest performance. Otherwise, we would be wasting considerable resources with resource locks etc.  UNIX users need not fear. All declarations and definitions in the CS-MAP code where the  __declspec  (thread) or  __thread  are appropriate are accomplished using the manifest constant  Thread  defined in the CS-MAP header file. This constant is defined to be nothing in most cases. Only in the event that compiler pre-defined constants indicate a multi-thread environment (i.e.  _MT ), is  Thread  defined to be something other than nothing. None of this applies if you are building a DLL. In a DLL, there is a single data segment, and multi-threading has no effect.", 
            "title": "Multi-Threaded Programming"
        }, 
        {
            "location": "/userguide/desc/#gui-considerations", 
            "text": "CS-MAP supports a graphic user interface based on Microsoft's MFC library. This is, admittedly, non portable but does provide useful product capability for a large percentage of our clients. Use of these functions requires that you include the  csmap.rc  file into your projects resources. This can be accomplished by adding an include  csmap.rc  statement to your project's  .rc2  file. Please note that the use of these functions implies that your application activates the basic infrastructure of the MFC library. Accessing the functions in an isolated application does not work without special effort. Also note, that MFC is a multi-threaded environment. You will need to compile the CS-MAP library using the multi-threaded options to eliminate frustrations generated by the Microsoft linker.  The  CS_csEditor  function causes activation of the coordinate system editor. Similarly, the  CS_dtEditor  and  CS_ellEditor  functions cause the activation of the datum and ellipsoid editors respectively. In all three cases, the functions require a single input and return a single result. The input is the key name of the definition which is to be initially displayed. The result is the key name that was displayed when the user caused the dialog to exit. All other user activity is recorded in the appropriate dictionary.  The  CS_csBrowser  function activates a coordinate system browser and can be used to obtain a coordinate system key name from the user. The  CS_csDataDr  function displays a dialog which enables the user to specify the directory in which the mapping data files reside.", 
            "title": "GUI Considerations"
        }, 
        {
            "location": "/userguide/desc/#customization", 
            "text": "Some users will, no doubt, require modification to the basic capabilities of the Coordinate System Mapping Library as provided by OSGeo. The following sections describe how some of the more common requirements can be accomplished with a minimum of effort.", 
            "title": "Customization"
        }, 
        {
            "location": "/userguide/desc/#tuning-the-protection-system", 
            "text": "As distributed, CS-MAP will not allow users to modify or delete a dictionary definition which is produced by the dictionary compiler; i.e. a distribution definition. Further, CS-MAP will not permit modification or deletion of a user defined coordinate system after such definition has remained unaltered for 60 days. The behavior of this feature is controlled by the  cs_Protect  global variable, an int defined in the  CSdata  module. You can change the value of this variable in  CSdata  and recompile, or at run time.  Setting  cs_Protect  to a negative value disables all of the above described protection features. Setting  cs_Protect  to zero enables distribution coordinate system protection, but disables the user defined protection system. Setting  cs_Protect  to a positive value enables the user definition protection feature, and also specifies the number of days which must elapse from the last modification before the definition is protected.", 
            "title": "Tuning the Protection System"
        }, 
        {
            "location": "/userguide/desc/#turning-of-unique-names", 
            "text": "As distributed, CS-MAP requires that a colon appear in all dictionary definition key names. By doing so, CS-MAP guarantees that the names of all user definitions will be different from any definition which may be contained in a future distribution of CS-MAP. You can disable this feature of CS-MAP by setting the global char variable named  cs_Unique  to the null character (i.e.  '\\0' ). Alternatively, you can enable this feature using a different character by setting the value of  cs_Unique  to that character.  cs_Unique  is defined in the  CSdata  module and be set at compile time or run time.", 
            "title": "Turning of Unique Names"
        }, 
        {
            "location": "/userguide/desc/#eliminating-a-projection", 
            "text": "If you do not have a need for all thirty eight supported projections, you can simply remove from the projection table (defined in  CSdataPJ ) the entry which references any projection which you do not need. Doing so will eliminate all references to the code for a specific projection and reduce the code size of your executable.", 
            "title": "Eliminating a Projection"
        }, 
        {
            "location": "/userguide/desc/#data-dictionary-directory", 
            "text": "The directory in which  CS_csdef ,  CS_dtdef , and  CS_eldef  look for their respective dictionary files is defined in the  CSdata.c  module. You must use the  CS_altdr  function to initialize this variable to point to the directory which contains all data files.  CS_altdr  will use the value of an environmental variable when called with a  NULL  pointer as an argument. The name of this environmental variable,  CS_MAP_DIR  by default, is established in  cs_map.h  as a manifest constant.", 
            "title": "Data Dictionary Directory"
        }, 
        {
            "location": "/userguide/desc/#dictionary-file-names", 
            "text": "The names assigned to the three dictionary files are defined as manifest constants in the  cs_map.h  header file, declared and initialized in the  CSdata  module. They can also be modified at run time by using the  CS_csfnm ,  CS_dtfnm , and  CS_elfnm  function.", 
            "title": "Dictionary File Names"
        }, 
        {
            "location": "/userguide/desc/#adding-units", 
            "text": "The units which are recognized by the Coordinate System Mapping Package are defined in the  CSdataU  module. You can add or delete as necessary. Note that this table has provisions for an abbreviation in addition to the full name. Use the code as provided as an example of how to incorporate a new unit. Also note that the factor is the multiplier required to change the new unit to meters, or degrees, by multiplication depending upon the type of unit.", 
            "title": "Adding Units"
        }, 
        {
            "location": "/userguide/desc/#language-translation", 
            "text": "Textual descriptions of all error conditions are provided in the  CSerpt  module. All language oriented text is located either in the  cs_map.h  header file, one of the three data modules:  CSdata ,  CSdataU ,  CSdataPJ , or in the ASCII form of the dictionary files ( COORDSYS.ASC ,  DATUMS.ASC , and  ELIPSOID.ASC ). Language translations efforts need only address these eight files (MFC dialogs excepted).", 
            "title": "Language Translation"
        }, 
        {
            "location": "/userguide/executables/", 
            "text": "Executables\n\n\nThis section describes the use and function of the three executable modules which are a part of the CS- MAP distribution. Note that the executables modules themselves are not provided. Source code which can be used to create the executable modules on your platform are included.\n\n\nCS_COMP\u2014Coordinate System COMPiler\n\n\nCS_COMP [/c] [/b] [/s] [/t] [/w] source_file_dir output_dir\n\n\nCS_COMP\n creates binary dictionary files from the ASCII source files provided with the CS-MAP distribution. This feature has been added to\n\n\n\n\neliminate problems with the byte order of binary data on platforms other than Intel and\n\n\nprovide a means by which coordinate system definitions can be committed to source control procedures. Release 6 (and later) of CS-MAP precludes, to a large extent, the first need described above. See Byte Ordering below.\n\n\n\n\nOn UNIX systems, you will need to use the UNIX option character (i.e. the dash) when specifying options.\n\n\nSource code to \nCS_COMP\n and its components is provided to all licensees, and has been tested as a console application under Windows XP and Linux 3.2.2. As CS-MAP is intended for use in a large variety of systems, and for compilation and linking by users who may not have access to lex and yacc, the user interface and source file formats are very simple and basic.\n\n\nBy compiling all four source files at the same time, \nCS_COMP\n can now perform consistency checks between all four files. To simplify use, the actual file names are hard coded into the program. Thus, the source files are required to be named \nCoordsys.asc\n, \nDatums.asc\n, \nElipsoid.asc\n, and \nMreg.asc\n for the Coordinate System, Datum, Ellipsoid, and Multiple Regression Transformation data files respectively. \nCS_COMP\n expects these files to reside in the directory specified as the first positional argument on the command line.\n\n\nSimilarly, the names of the output files are fixed by the program, being the names specified in the \nCSdata\n module. These are the same names that the library in general searches for. The directory in which these files are written is specified as the second positional parameter on the command line.\n\n\nSince \nCS_COMP\n performs a consistency check between all files, it expects to compile all four files. It is not possible to compile the files individually.\n\n\nCS_COMP\n is coded for possible compilation as a Windows XP console application. Therefore, it requires an acknowledgment before it exits, enabling the operator to verify successful completion before the window disappears. For use in make files and/or batch files, you may wish to use the \n/b\n option to suppress the requirement for acknowledgment before exit.\n\n\nCS_COMP\n normally produces encrypted output files. Use the \n/c\n option to cause unencrypted versions of the dictionaries to be produced for testing and/or debugging purposes.\n\n\nPresence of the \n/t\n option instructs \nCS_COMP\n to include coordinates systems, datums, and ellipsoids in the Test group. Normally, these are neither compiled or distributed with your application.\n\n\nUse the \n/w\n option to instruct \nCS_COMP\n to report any inconsistency in the data which may only be suspicious.\n\n\nIn the UNIX environment, the dash must be used as the option character.\n\n\nUse the \n/s\n option to instruct \nCS_COMP\n to produce dictionary files in big endian byte order regardless of the system on which the program has been compiled. This forces a byte swap before output on little endian processors (e.g. Intel) and omits the byte swap on big endian processors (e.g. Sun).\n\n\nByte Ordering\n\n\nCS_COMP\n calls \nCS_bswap\n immediately prior to writing any data to the dictionary file in order to effect, as necessary, a byte order switch to little endian (i.e. Intel/DOS) byte order. This is the same byte order expected by the CS-MAP library on all platforms. It is also the byte order which the data file from other sources, such as the NADCON LAS/LOS files, are distributed. Use of the /s options reverses this effect, causing big endian data files to be produced, regardless of the processor in use.\n\n\nSource File Formats\n\n\nCoordsys.asc\n\n\nRecords in the \nCOORDSYS.ASC\n source file consist of a line of text. Blank lines are generally ignored. All characters following an un-escaped pound sign character ('#') are ignored. The pound sign character can be escaped by the backslash ('\\') or pound sign ('#') characters. Note that this is required to get a pound sign character into a coordinate system description as these descriptions are not quoted. Leading and trailing whitespace on all records is also ignored. Records to be processed must start with one of the 39 keywords described below. The colon separator character is considered to be part of the keyword. The value of the keyword must follow the keyword on the same line of text, white space may be used to separate the keyword from its value.\n\n\nEach occurrence of the \nCS_NAME\n: keyword indicates the beginning of a new coordinate system definition and the end of any previous coordinate system definition. Otherwise, the order of the specifications is not important. However, to maintain your source in a comprehensible format, it is strongly recommended that each coordinate system definition begin with the \nCS_NAME\n: keyword and be terminated by one or more blank lines. No blank lines should appear within the definition itself. Further, while \nCS_COMP\n will sort the resulting binary Coordinate System Dictionary file, maintaining the coordinate system source file in sorted order makes it (relatively) easy to locate a definition should review or editing be required.\n\n\nFor projection specific information, refer to the projection descriptions of this guide. Note that rarely will any projection require the use of all 39 keyword specifications.\n\n\nThe 25 keywords and their values are:\n\n\n\n\nCS_NAME\n: - Used to specify the key name of the coordinate system which is to be defined, 23\ncharacters max. See \nCS_nampp\n for conventions concerning key names.\n\n\nDESC_NM\n: - Used to specify the 63 character descriptive name of the coordinate system being defined.\n\n\nDT_NAME\n: - Used to specify the datum key name to which a geodetically referenced coordinate system is to be referenced to. The ellipsoid used is a part of this datum definition. Presence of a valid datum key name here indicates that the coordinate system is geodetically referenced. Either a \nDT_NAME\n: specification, or an \nEL_NAME\n: specification must be provided for each coordinate system definition. If both \nDT_NAME\n: and \nEL_NAME\n: specifications are provided, the \nEL_NAME\n: specification is ignored by CS-MAP.\n\n\nEL_NAME\n: - Used to specify the ellipsoid key name for a cartographically referenced coordinate system. A coordinate system is cartographically referenced to the ellipsoid named by this specification if, and only if, the datum key name specification is omitted. If both \nDT_NAME\n: and \nEL_NAME\n: specifications are provided, the \nEL_NAME\n: specification is ignored by CS-MAP.\n\n\nORG_LAT\n: - Used to specify the origin latitude of the coordinate system. This value may be in any form acceptable to \nCS_atof\n, but is always in \ndegrees\n relative to the equator. Use positive numbers for north latitude, negative numbers for south latitude.\n\n\nORG_LNG\n: - Used to specify the origin longitude of the coordinate system. This value may in any form acceptable to \nCS_atof\n, but always in degrees and is always relative to the Greenwich prime meridian. Use positive numbers for east longitude, negative numbers for west longitude.\n\n\nSCL_RED\n: - Used to specify the scale reduction which may apply to a coordinate system. This value is ignored by the many projections which do not support this feature. The value may be specified as a decimal number, e.g. 0.9996, or as a ratio, e.g. 1:2500. A value of 1.0 or greater is unusual, but is accepted.\n\n\nZERO_X\n: - Used to specify the minimum X value which is to be considered non-zero. X coordinate values whose absolute value is less than the value specified here will be converted to hard zeros. This is used to suppress coordinate output such as 4.3472E-07 which can be of value in certain applications. A value of 0.0 is assumed if no specification is made.\n\n\nZERO_Y\n: - Used to specify the minimum Y value which is to be considered non-zero. Y coordinate values whose absolute value is less than the value specified here will be converted to hard zeros. This is used to suppress coordinate output such as 4.3472E-07 which can be of value in certain applications. A value of 0.0 is assumed if no specification is made.\n\n\nPARM1\n: thru \nPARM24\n: - Used to specify the value of as many as 24 parameters which are specific to the particular projection in use. The use of these items varies from one projection to another. The value is always a real number. Where a longitude is specified, it must be given in degrees, relative to Greenwich, where west longitude is negative. Where a latitude is expected, it must be given in degrees relative to the equator where north latitude is positive and south latitude is negative. When an azimuth is specified, it must be given in degrees east of north (i.e. west of north would be negative). In all cases, the values are processed by \nCS_atof\n, and any form acceptable to that function may be used.\n\n\nX_OFF\n: - Used to specify the value of the false easting of the coordinate system. A value of 0.0 is assumed if no specification is made. Any form acceptable to \nCS_atof\n may be used, including the use of the comma as a thousands separator.\n\n\nY_OFF\n: - Used to specify the value of the false northing of the coordinate system. A value of 0.0 is assumed if no specification is made. Any form acceptable to \nCS_atof\n may be used, including the use of the comma as a thousands separator.\n\n\nPROJ\n: - Used to specify the code name of the projection upon which the coordinate system is based. This code value must be the value assigned to the desired projection in the \nCSdataPJ\n module, i.e. the projection table. This value is a character string of two to eight characters. Since projections can now have several variations, this code value is not the same as the five character code used to generate function and structure tag names. You will need to refer to the \nCSdataPJ\n module to determine the code name for a specific projection type.\n\n\nUNIT\n: - Used to specify the name of the system unit for the coordinate system being defined. In the case of a normal cartesian coordinate system, this must be one of the supported unit of length names as defined in the \nCSdataU\n module. In the case of the Unity projection, i.e. the coordinate system being defined is latitude and longitude or a variation thereof, the unit name must be one of those names defined as a unit of angular measure in the \nCSdataU\n module.\n\n\nGROUP\n: - Used to classify coordinate systems into groups to make selection of a coordinate system from the 5,000+ provided a bit easier. The supported group codes are defined in the \nCSdata\n module.\n\n\nSOURCE\n: - Used to specify the source of the information used to define this coordinate system, 63 characters maximum. The term Authority is often used to describe this information.\n\n\nQUAD\n: - Used to indicate the quadrant of the cartesian coordinates produced by the coordinate system. Zero or 1 indicate the normal right handed cartesian system where X increases to the east, and Y increases to the north. Quadrants are numbered counterclockwise, therefore a value of 2 specifies a cartesian system where X increases to the west, while Y increases north. A value of 3 indicates that X increases to the west and Y increases to the south. A value of 4 indicates that X increases to the east and Y increases to the south. A negative value will cause the axes to be swapped \nafter\n the appropriate quadrant is applied. A value of 1 is assumed if this specification is absent.\n\n\nMIN_LNG\n: - This parameter is optional and can be used to specify the minimum longitude of the useful range of the coordinate system. The value is given in degrees relative to Greenwich in any form acceptable to \nCS_atof\n. Positive values indicate east longitude, while negative values indicate west longitude. Its value should be normalized between -360 and +360 and when used must be algebraically less than the \nMAX_LNG\n: parameter.\n\n\nMAX_LNG\n: - This parameter is optional and can be used to specify the maximum longitude of the useful range of the coordinate system. The value is given in degrees relative to Greenwich in any form acceptable to \nCS_atof\n. Positive values indicate east longitude, while negative values indicate west longitude. Its value should be normalized between -360 and +360 and when used must be algebraically greater than the \nMIN_LNG\n: parameter.\n\n\nMIN_LAT\n: - This parameter is optional and can be used to specify the minimum latitude of the useful range of the coordinate system. The value is given in degrees relative to the equator in nay form acceptable to \nCS_atof\n. Positive values indicate north latitude while negative values indicate south latitude. Its value should be normalized between -90 and +90 and when used must be algebraically less than the \nMAX_LAT\n: parameter.\n\n\nMAX_LAT\n: - This parameter is optional and can be used to specify the maximum latitude of the useful range of the coordinate system. The value is given in degrees relative to the equator in nay form acceptable to \nCS_atof\n. Positive values indicate north latitude while negative values indicate south latitude. Its value should be normalized between -90 and +90 and when used must be algebraically greater than the \nMIN_LAT\n: parameter.\n\n\nMIN_XX\n: - This parameter is optional and can be used to specify the minimum X coordinate value of the useful range of the coordinate system. The value is given in system units and may be provided in any form acceptable to \nCS_atof\n. Its value must be algebraically less than the \nMAX_XX\n: parameter.\n\n\nMAX_XX\n: - This parameter is optional and can be used to specify the maximum X coordinate value of the useful range of the coordinate system. The value is given in system units and may be provided in any form acceptable to \nCS_atof\n. Its value must be algebraically greater than the \nMIN_XX\n: parameter.\n\n\nMIN_YY\n: - This parameter is optional and can be used to specify the minimum Y coordinate value of the useful range of the coordinate system. The value is given in system units and may be provided in any form acceptable to CS_atof. Its value must be algebraically less than the \nMAX_YY\n: parameter.\n\n\nMAX_YY\n: - This parameter is optional and can be used to specify the maximum Y coordinate value of the useful range of the coordinate system. The value is given in system units and may be provided in any form acceptable to \nCS_atof\n. Its value must be algebraically greater than the \nMIN_YY\n: parameter.\n\n\n\n\nOther key words have been coded into the \nCS_COMP\n module but are reserved for future use by OSGeo contributors. They should not be used until their exact usage is defined in a future release.\n\n\nDatums.asc\n\n\nRecords in the DATUMS.ASC source file consist of a line of text. Blank lines are ignored. All characters following an un-escaped pound sign character ('\n#\n') are ignored. The pound sign character can be escaped by the backslash ('\\') or pound sign ('#') characters. Note that this is required to get a pound sign character into a datum description as these descriptions are not quoted. Leading and trailing whitespace on all records is also ignored. Records to be processed must start with one of the twelve keywords described below. The colon separator character is considered to be part of the keyword. The value of the keyword must follow the keyword on the same line of text, white space may be used to separate the keyword from its value.\n\n\nEach occurrence of the \nDT_NAME\n: keyword indicates the beginning of a new datum definition and the end of any previous datum definition. Otherwise, the order of the specifications is not important. However, to maintain your source in a comprehensible format, it is strongly recommended that each coordinate system definition begin with the \nDT_NAME\n: keyword and be terminated by one or more blank lines. No blank lines should appear within the definition itself. Further, while \nCS_COMP\n will sort the resulting binary Datum Dictionary file, maintaining the datums source file in sorted order makes it (relatively) easy to locate a definition should review or editing be required.\n\n\nAlso note, that CS-MAP uses the Datum Key name as the base portion of a file name to access the Multiple Regression Transformation file. Therefore, a datum key name of more than 8 characters on a DOS based system may not work as expected.\n\n\nThe twelve keywords and their required values are:\n\n\n\n\nDT_NAME\n: - Used to specify the key name of the datum which is to be defined, 23 characters max. Refer to \nCS_nampp\n for conventions concerning key names. Since datum key names are used to link to the Multiple Regression Transformation files, datum key names longer than 8 characters may present problems on systems using the DOS FAT-16 file system (i.e. file name limited to 8 characters).\n\n\nDESC_NM\n: - Used to specify the 63 character descriptive name of the datum being defined. ELLIPSOID: - Used to specify the key name of the ellipsoid definition upon which this datum is based.\nThis name must be the key name of an entry in the Ellipsoid Dictionary.\n\n\nUSE\n: \u2014 This parameter is required and is used to specify the datum conversion technique to convert coordinates based on the datum being defined to WGS84 coordinates. There are, currently, ten valid values. They are:\n\n\nMOLODENSKY\n - Use the Molodensky transformation to convert to WGS84.\n\n\nGEOCENTRIC\n - Use the geocentric translation method to convert to WGS84.\n\n\nBURSA\n - Use the Bursa/Wolfe Seven Parameter Transformation to convert to WGS84.\n\n\n7PARAMETER\n - Use the Seven Parameter Transformation to convert to WGS84, default to Molodensky if the necessary parameters are not present.\n\n\nMULREG\n - Use the Multiple Regression Transformation formulas. If such a definition is not available, default to the Bursa/Wolfe Seven Parameter Transformation.\n\n\nNAD27\n - Use the NADCON or Canadian National Transformation emulation as appropriateto convert to NAD83, and consider the result to be WGS84 coordinates.\n\n\n`NAD83 - Consider the coordinates to be WGS84 coordinates already, no shift is to be performed.\n\n\nWGS84\n - The coordinates are WGS84 coordinates already, no datum shift is required.\n\n\nWGS72\n - Use an internal formula to convert to WGS84.\n\n\nHPGN\n - Use the NADCON algorithm, but use the HPGN data files, to shift the coordinates to NAD83, then consider the result to be WGS84 coordinates without any further datum shift.\n\n\n\n\n\n\nDELTA_X\n: - The X component of the vector from the geocenter of this datum to the geocenter of the WGS-84 datum in meters.\n\n\nDELTA_Y\n: - The Y component of the vector from the geocenter of this datum to the geocenter of the WGS-84 datum in meters.\n\n\n`DELTA_Z : - The Z component of the vector from the geocenter of this datum to the geocenter of the WGS-84 datum in meters.\n\n\nBWSCALE\n: - The scale of the Bursa/Wolfe or Seven Parameter Transformation, given as parts per million as is ordinarily the case for this transformation. This value can be positive or negative. The actual resulting scale factor used in the transformation is \n1.0 + (BWSCALE * 1.0E-06)\n.\n\n\nROT_X\n: - The rotation about the X axis, given in seconds of arc. Positive values indicate clockwise rotation of the right handed Helmert coordinate system.\n\n\nROT_Y\n: - The rotation about the Y axis given in seconds of arc. Positive values indicate clockwise rotation of the right handed Helmert coordinate system.\n\n\nROT_Z\n: - The rotation about the Z axis given in seconds of arc. Positive values indicate clockwise rotation of the right handed Helmert coordinate system.\n\n\nSOURCE\n: - The source of information from which this definition was developed.\n\n\n\n\nSupport of other keywords has been coded into the \nCS_COMP\n module; but use of these is reserved by\nOSGeo contributors for future use.\n\n\nElipsoid.asc\n\n\nRecords in the \nELIPSOID.ASC\n source file consist of a line of text. Blank lines of text are ignored. All characters following an un-escaped pound sign character ('\n#\n') are ignored. The pound sign character can be escaped by the backslash ('\\') or pound sign ('\n#\n') characters. Note that this is required to get a pound sign character into an ellipsoid description as these descriptions are not quoted. Leading and trailing white space on all records is also ignored. Records to be processed must start with one of the five keywords described below. The colon separator character is considered to be part of the keyword. The value of the keyword must follow the keyword on the same line of text, white space may be used to separate the keyword from its value.\n\n\nEach occurrence of the \nEL_NAME\n: keyword indicates the beginning of a new ellipsoid definition and the end of any previous ellipsoid definition. Otherwise, the order of the specifications is not important. However, to maintain your source in a comprehensible format, it is strongly recommended that each ellipsoid definition begin with the \nEL_NAME\n: keyword and be terminated by one or more blank lines. No blank lines should appear within the definition itself. Further, while \nCS_COMP\n will sort the resulting binary Ellipsoid Dictionary file, maintaining the ellipsoid definition source file in sorted order makes it (relatively) easy to locate a definition should review or editing be required.\n\n\nThe six keywords and their required values are:\n\n\n\n\nEL_NAME\n: - Used to specify the key name of the ellipsoid which is to be defined, 23 characters max.\n\n\nDESC_NM\n: - Used to specify the 63 character descriptive name of the ellipsoid being defined.\n\n\nE_RAD\n: - Used to specify the equatorial radius of the ellipsoid being defined. This radius \nmust\n be specified in meters.\n\n\nP_RAD\n: - Used to specify the polar radius of the ellipsoid being defined. This radius \nmust\n be specified in meters. Use the same value given for \nE_RAD\n: to define a spherical ellipsoid.\n\n\nSOURCE\n: - The source of the information used to make this definition.\n\n\nGROUP\n: - This keyword is used to mark ellipsoid definitions as being for testing only. Additional\ngroups may be established in the future.\n\n\n\n\nCS_COMP\n will calculate the eccentricity and flattening from the provided radii.\n\n\nMReg.asc\n\n\nRecords in a \nMREG.ASC\n source file consist of a line of text. Blank lines are ignored. All characters following an un-escaped pound sign character ('\n#\n') are ignored. The pound sign character can be escaped by the backslash ('\\') or pound sign ('\n#\n') characters. Note that this is required to get a pound sign character into a datum description as these descriptions are not quoted. Leading and trailing white space on all records is also ignored. Records to be processed must start with one of the 12 keywords described below. The colon separator character is considered to be part of the keyword. The value of the keyword must follow the keyword on the same line of text, white space may be used to separate the keyword from its value. In certain cases, the actual keyword contains numeric qualifiers which indicate the specific power series term the keyword applies to.\n\n\nEach occurrence of the \nDATUM_NAME\n: keyword indicates the beginning of a new multiple regression definition and the end of any previous multiple regression definition. The order of the specifications is not important. However, to maintain your source in a comprehensible format, it is strongly recommended that each multiple regression definition begin with the \nDATUM_NAME\n: keyword and be terminated by one or more blank lines. No blank lines should appear within the definition itself. Maintaining the multiple regression source file in sorted order makes it (relatively) easy to locate a definition should review or editing be required.\n\n\nPlease note that a test case is required for each datum. A binary multiple regression coefficient data file will not be written unless the provided coefficients satisfy the provided test case. In the terminology used in this module, \nLAMBDA\n refers to longitude, and \nPHI\n refers to latitude. In preparation for future enhancements to CS-MAP, the \nHEIGHT\n coefficients are also required. If such are not currently available, simply use values which will produce a zero change in height to get around the required coefficient check.\n\n\nValues for the various keywords are given in a manner which is somewhat inconsistent with CS-MAP. However, the manner in which these values are specified is consistent with the conventions used in the source for most of this type of information: DMA TR-8350.2B.\n\n\nThe 12 keywords and their required values are:\n\n\n\n\nDATUM_NAME\n: - Used to specify the 23 character name of the datum for which the following coefficients represent the multiple regression coefficients. This is the name, with the .MRT extension appended, which is given to the coefficient data file. The association of a datum in the Datum Dictionary and the multiple regression data file is established by this name.\n\n\nTEST_LAMBDA\n: - This keyword must be followed by the longitude of the test point. This longitude must be given in degrees, minutes, and seconds form, where west longitudes are given as values greater than 180. This entry is processed by a \"%d %d %lf\" \nsscanf\n format specification.\n\n\nTEST_PHI\n: - This keyword must be followed by the latitude of the test point. This latitude must be given in degrees, minutes, and seconds form. Use a negative value to indicate south latitude. This entry is processed by a \"%d %d %lf\" \nsscanf\n format specification.\n\n\nDELTA_LAMBDA\n: - This keyword must be followed by a single real value which represents the amount of longitude shift, in seconds of arc, which is expected at the provided test point.\n\n\nDELTA_PHI\n: - This keyword must be followed by a single real value which represents the amount of latitude shift, in seconds of arc, which is expected at the provided test point.\n\n\nDELTA_HEIGHT\n: - This keyword must be followed by a single real value which represents the amount of elevation shift, in meters, which is expected at the provided test point.\n\n\nLAMBDA_OFF\n: - This keyword must be followed by the longitude offset used to normalize the coefficient formula. This value must be given in decimal degrees, use negative values for west longitude.\n\n\nPHI_OFF\n: - This keyword must be followed by the latitude offset used to normalize the coefficient formula. This value must be given in decimal degrees, use negative values for west longitude.\n\n\nKK\n - This keyword must be followed by the scale factor which is used to normalize the regression formula. This value is unitless.\n\n\nLAMBDA\n - This keyword is used to identify a longitude formula coefficient. The keyword itself must be followed by a \nUn\n and a \nVn\n sequence which indicates which coefficient follows. For example,\n      \nLAMBDA U1 V2: 1.23456\n\nindicates that 1.23456 is the coefficient for the longitude times latitude squared term in the regression formula. CS-MAP does not support terms with powers higher than 9.\n\n\nPHI\n - This keyword is used to identify a latitude formula coefficient. The keyword itself must be followed by a \nUn\n and a \nz\n sequence which indicates which coefficient follows. For example,\n      \nPHI U2 V1: 1.23456\n\nindicates that 1.23456 is the coefficient for the longitude squared times latitude term in the regression formula. CS-MAP does not support terms with powers higher than 9.\n\n\nHEIGHT\n - This keyword is used to identify an elevation formula coefficient. The keyword itself must be followed by a \nUn\n and a \nz\n sequence which indicates which coefficient follows. For example, \nHEIGHT U0 V0: 1.23456\n indicates that 1.23456 is the constant term in the regression formula. CS-MAP does not support terms with powers higher than 9.\n\n\n\n\nTEST -- TEST program\n\n\nTEST [/t12345...] [/dmap_dir] [/pnn] [/s] [/v] [/b] [test_data_file_name]\n\n\nTEST\n will exercise most (but not all) of the functions included in the Coordinate System Mapping Package library. It can be used to verify the correct operation of the library in different environments, especially useful after compiling the library with a new or different C compiler or on a different platform.\n\n\nSince \nTEST\n relies on the test coordinate systems, datums, and ellipsoids, \nCS_COMP\n should be run with the \n/t\n option prior to using the \nTEST\n program.\n\n\nThe program requires no arguments and normally expects the Ellipsoid Dictionary, the Datum Dictionary, the Coordinate System Dictionary, all Multiple Regression Transformation files, and Geodetic Data Catalogs to reside in their default locations and the file \nTEST.DAT\n to reside in the current working directory when executed. As a convenience, however, if a file named \nCOORDSYS\n exists in the same directory from which \nTEST\n was executed, \nTEST\n will look to that directory for all supporting data files (except the \nTEST.DAT\n file). Alternatively, you may use the \n/d\n option to specify the directory you want \nTEST\n to look to for all supporting data files.\n\n\nTEST\n will write all diagnostic messages to the console screen. On Windows 95/98/NT systems, you will need to use the MS-DOS option character (i.e. the forward slash) when specifying options.\n\n\nThe provided test file, \nTEST.DAT\n, includes tests for the NAD27 to NAD83 datum conversion software. Therefore, the NADCON CONUS database file system must exist in the default data directory (see \nCSdata(5CS)\n) if these tests are to be successful. \nTEST.DAT\n also includes tests for the Canadian National Transformation. However, since OSGeo cannot distribute the data files associated with the Canadian National Transformation, these tests have been commented out. Canadian users may wish to uncomment these tests before using \nTEST\n.\n\n\nThe command line options can be used to modify the operation of the test procedure. There are, currently, 19 separate tests performed by \nTEST\n, and each is designated with a number or a letter. Normally, \nTEST\n performs each of the first fifteen tests twice; first in forward numeric order, and then in reverse numeric order. Use the \n/t\n option to specify the specific test(s) you would like performed, and the order in which they are to be performed; one test per character (120 maximum).\n\n\nIndividual Tests\n\n\nThe nature of the 16 tests are:\n\n\n\n\nTest 1\n - This test manipulates the Ellipsoid Dictionary using \nCS_eldef\n, \nCS_elupd\n, and \nCS_eldel\n.\n\n\nTest 2\n - This test manipulates the Datums Dictionary using \nCS_dtdef\n, \nCS_dtupd\n, and \nCS_dtdel\n.\n\n\nTest 3\n - This test manipulates the Coordinate System Dictionary using \nCS_csdef\n, \nCS_csupd\n, and \nCS_csdel\n.\n\n\nTest 4\n - This test reads the file named \nTEST.DAT\n in the current directory and performs all of the conversions indicated, comparing the calculated results with the expected results recorded in the file. Of course, all discrepancies are reported to the user. You may specify an alternate file name (and directory) on the command line as the only positional argument. Each supported projection (except the Equidistant Cylindrical) has at least one test from a source other than CS-MAP in \nTEST.DAT\n. \nTEST.DAT\n also includes tests of datum conversions.\n\n\nTest 5\n - Test 5 is a performance test. Normally, it records the amount of wall clock time necessary to make 300,000 conversions from \"UTM27-13\" to \"CO83-C\" using the High Performance Interface. Each conversion, therefore, includes an inverse Transverse Mercator, a NAD27 to NAD83 datum shift, and a forward Lambert Conformal Conic conversion. The test cycles through a list of 10 different coordinate pairs to add some reality to the test without distorting the numeric results with I/O time and/or system overhead. The elapsed time and the effective conversion rate are reported to the user. The \n/p\n option can be used to change the number of conversions in the test. For example, \n/p45\n would instruct \nTEST\n to perform 450,000 conversions whenever it performs test number 5.\n\n\nTest 6\n - This test exercises the sorting and binary search functions of CS-MAP well beyond what would be experienced in normal use. This is accomplished by sorting the Coordinate System Dictionary into reverse order, binary searching the result, and resorting back into normal order. Finally, the order of the result is verified to be correct.\n\n\nTest 7\n - This test exercises the \nCS_csgrp\n function and its supporting data.\n\n\nTest 8\n - For each coordinate system in the Coordinate System Dictionary, this test will cause a coordinate to be converted in both the forward and inverse direction, as well as calculate the grid scale factor and the convergence angle. This test does not verify the accuracy of the results, but simply assures that every calculation function is exercised at least once. This test is somewhat superfluous now that Test C is available.\n\n\nTest 9\n - This test exercises the functions which are used to calculate the power series solutions to the elliptical integrals used quite frequently in CS-MAP. It verifies the results against an outside source, and then compares forward and inverse calculations with each other. Please note that the external source for the correct values is limited in precision. Therefore the RMS discrepancy values may be alarmingly high. This is not the case, however, as indicated by the RMS discrepancies between forward and reverse calculations.\n\n\nTest A\n - This test is identical to \ntest 4\n in every way except it uses the High Level Interface function \nCS_cnvrt\n function for all conversions, thus testing the caching system for coordinate systems and datum conversions.\n\n\nTest B\n - \nTest B\n tests the grid scale and convergence angle functions of all non-azimuthal projections. It uses an empirical technique to determine the grid scale and convergence angle of several random points within the useful range of each coordinate system. Azimuthal projections are skipped as the grid scale functions in these cases usually return scale factors along and normal to radials from the origin. An empirical means of calculating these scale factors eludes us at the current time.\n\n\nTest C\n - This test tries very hard to produce a floating point exception. Very regular and randomly generated coordinate values, both geographic and cartesian, are generated and passed to all functions for each coordinate system in the coordinate system dictionary. The coordinates are, in most cases, completely outlandish numbers. Reporting floating point exceptions is very difficult, however, varying from compiler to compiler, system to system. However, CS-MAP has passed this test many times, on four different compilers.\n\n\nTest D\n - This test tests the forward and inverse functions of each projection against each other. That is, random geographic coordinates within the useful range of each coordinate system are converted to cartesian form using the forward function, and then back to geographic using the inverse function. The results are then compared.\n\n\nTest E\n - This test performs all the functions of Test D; but in this case the useful range of each of the projections is reduced by about one half, and thus enabling the error tolerance to be substantially reduced.\n\n\nTest F\n - \nTest F\n tests the \nCS_atof\n and \nCS_ftoa\n functions in two phases. First, the standard system function \nsprintf\n is used to check the operation of the \nCS_atof\n function. In the second phase, \nCS_atof\n is used to test the \nCS_ftoa\n function. Neither phase, currently, tests the operation of the degree, minute. and/or second processing.\n\n\nTest G\n - \nTest G\n is the coordinate creep test. Creep is defined as the number of millimeters a coordinate moves after repeated conversions from cartesian to geographic and back. \nTest G\n starts with a specific cartesian coordinate well within the useful range of a projection (but certainly not the natural origin) and converts the coordinate to geographic and back to cartesian 1,000 times. The distance between the original coordinate and the final result is calculated in millimeters to arrive at the creep value. A creep value greater than 10 is considered a failure. As of release 8.01, only the four most used projections are tested.\n\n\nTest S\n - This is not really a test, per se, but a request that the test program switch its mode with regard to byte ordering. Thus, on an little endian processor such as Intel, the initial S in a test sequence will cause all binary data files to be swapped to big endian byte ordering and the \nCS_bswap\n module adjusted to cause the necessary byte swaps for the program to function. Thus, all byte swapping mechanisms can be tested on a single processor. Since the byte swap algorithm is its own inverse, a second occurrence of Test S reverses the effect of a previous execution. Note, including an odd number of S specifications in the test specification will leave all dictionary files in a swapped condition.\n\n\nTest V\n - This is not a test. Occurrence of a \nV\n in the test string simply toggles the verbose flag. Thus, the verbose flag can be turned off , or on, for specific tests individually.\n\n\nTest Z\n - This is not a test. When \nTEST\n encounters this character in the test sequence, it simply starts the test sequence again from the beginning. Thus, an infinite loop can be established. Typically, a \nCONTROL-C\n is used to terminate the program at some point.\n\n\n\n\nTest Data\n\n\nThe \nTEST.DAT\n file specifies the actual coordinates which are to be converted and the expected results. TEST ignores empty lines in the file and lines which begin with the pound sign (\n#\n) character. Other records are expected to contain 8 fields separated by commas. The eight fields are expected to contain:\n\n\n\n\nKey name of the coordinate system of the coordinates specified in fields 2 and 3 of this line. That is, the name of the source coordinate system of the test conversion to be performed.\n\n\n 3. The X and then Y coordinates to be converted. These are expected in decimal form and are converted to binary using the \nCS_atof\n function of the CS-MAP library. Thus a variety of forms can be used.\n\n\nKey name of the coordinate system to which the coordinates given in fields 2 \n 3 are to be converted.\n\n\n 6. The expected X and Y coordinates of the conversion. Again, any form acceptable to \nCS_atof\n can be used.\n\n\n 8. The X and Y tolerance within which the converted values must agree with the expected values. If the converted values do not match the expected values within the specified tolerance, a diagnostic message is printed.\n\n\n\n\nMost conversion examples provided in \nTEST.DAT\n were obtained from reputable sources other than CS_MAP itself. Comments in the \nTEST.DAT\n file itself will indicate those specific tests which have not been verified with sources outside other than CS-MAP. The tolerance values given in the provided \nTEST.DAT\n file should not be considered as an indication of the accuracy or precision of the CS-MAP library. Rather, these values usually indicate the accuracy and precision of the source data from which the examples were obtained. Occasionally, the tolerance values do indicate the accuracy of the CS- MAP library; comments in the \nTEST.DAT\n file indicate when this is the case.\n\n\nOther Command Line Options\n\n\nFinally, the \n/v\n option can be used to cause \nTEST\n to operate in verbose mode. In this mode, \nTEST\n will report its progress through each test. In order to enable use of \nTEST\n as a Windows NT console application, \nTEST\n normally requires an acknowledgment when all tests are complete. The \n/b\n option can be used to suppress this feature. The \n/s\n option can be used to instruct \nTEST\n to start out in big endian mode; useful when testing the automatic byte swapping feature. Use the \n/d\n option to provide TEST with the full path to the directory containing the binary dictionary files it is to use. In the absence of this option, \nTEST\n uses the directory encoded into the \nCSdata\n module; except that if a valid \nCOORDSYS\n file exists in the directory from which \nTEST\n was executed, that directory is used (MS-DOS only). Use the \n/p\n option to indicate the length of the performance test (i.e. \nTest 5\n). The value provided is multiplied by 10,000 to obtain the number of conversions which are performed and timed in order to produce the conversion rate.\n\n\nBUGS\n\n\nTest C\n, the floating point exception test, does not exercise the datum conversion functions as yet.\n\n\nmfcTEST -- MFC Dialog TEST\n\n\nmfcTEST\n\n\nmfcTest\n is designed to test the MFC based GUI interactive dialogs provided with CS-MAP. The program is a simple dialog box MFC program which contains a menu. The single menu entry provides a selection for each of the primary dialogs provided. Note also, that the Test dialog can be very convenient for testing projection and datum shift calculations in an interactive environment (assuming you're using Windows, of course).\n\n\nThis test program requires no arguments. All testing must be done in an interactive manner. Note, that each of the dialogs has a help button, and expects to find the help file in the same directory as the primary mapping data files. The help buttons are grayed out if the help file does not exist in this location.\n\n\nDictionary Differences Program\n\n\nThe source to Dictionary Difference program, \nDictDiff\n, is conveyed in a file named \nCS_DictDiff.c\n; the distribution places this file in the \nDictionary\n directory. The main module calls functions named \nCS_csDiff\n, \nCS_dtDiff\n, and \nCS_elDiff\n which are defined in a module named \nCSdictDiff.c\n which the distribution deposits in the \nSource\n directory. These three functions are a part of the normal library build.\n\n\nMessages which report differences refer to \"was\" and \"is\". That is, messages report the previous value and the new value for all detected changes.\n\n\nDictDiff\n is a command line program and can used in virtually any environment that supports a C compiler. It compares the binary forms of dictionary files and reports all differences detected. It requires exactly two positional arguments. The first command line argument is the directory containing the \"was\" or previous dictionary files. The second argument is the directory of the \"is\" or current dictionary files. All messages are reported to \nstdout\n, i.e. the terminal.\n\n\nIn producing the differences, some tolerance numbers had to be chosen to delineate what a change consists of. You should examine the source code in file named \nCSdiffDict.c\n to verify that you are comfortable with the tolerance values that were chosen. The tolerance values are manipulated throughout the program, but the variable name \nokValue\n is consistent.", 
            "title": "Executables"
        }, 
        {
            "location": "/userguide/executables/#executables", 
            "text": "This section describes the use and function of the three executable modules which are a part of the CS- MAP distribution. Note that the executables modules themselves are not provided. Source code which can be used to create the executable modules on your platform are included.", 
            "title": "Executables"
        }, 
        {
            "location": "/userguide/executables/#cs_compcoordinate-system-compiler", 
            "text": "CS_COMP [/c] [/b] [/s] [/t] [/w] source_file_dir output_dir  CS_COMP  creates binary dictionary files from the ASCII source files provided with the CS-MAP distribution. This feature has been added to   eliminate problems with the byte order of binary data on platforms other than Intel and  provide a means by which coordinate system definitions can be committed to source control procedures. Release 6 (and later) of CS-MAP precludes, to a large extent, the first need described above. See Byte Ordering below.   On UNIX systems, you will need to use the UNIX option character (i.e. the dash) when specifying options.  Source code to  CS_COMP  and its components is provided to all licensees, and has been tested as a console application under Windows XP and Linux 3.2.2. As CS-MAP is intended for use in a large variety of systems, and for compilation and linking by users who may not have access to lex and yacc, the user interface and source file formats are very simple and basic.  By compiling all four source files at the same time,  CS_COMP  can now perform consistency checks between all four files. To simplify use, the actual file names are hard coded into the program. Thus, the source files are required to be named  Coordsys.asc ,  Datums.asc ,  Elipsoid.asc , and  Mreg.asc  for the Coordinate System, Datum, Ellipsoid, and Multiple Regression Transformation data files respectively.  CS_COMP  expects these files to reside in the directory specified as the first positional argument on the command line.  Similarly, the names of the output files are fixed by the program, being the names specified in the  CSdata  module. These are the same names that the library in general searches for. The directory in which these files are written is specified as the second positional parameter on the command line.  Since  CS_COMP  performs a consistency check between all files, it expects to compile all four files. It is not possible to compile the files individually.  CS_COMP  is coded for possible compilation as a Windows XP console application. Therefore, it requires an acknowledgment before it exits, enabling the operator to verify successful completion before the window disappears. For use in make files and/or batch files, you may wish to use the  /b  option to suppress the requirement for acknowledgment before exit.  CS_COMP  normally produces encrypted output files. Use the  /c  option to cause unencrypted versions of the dictionaries to be produced for testing and/or debugging purposes.  Presence of the  /t  option instructs  CS_COMP  to include coordinates systems, datums, and ellipsoids in the Test group. Normally, these are neither compiled or distributed with your application.  Use the  /w  option to instruct  CS_COMP  to report any inconsistency in the data which may only be suspicious.  In the UNIX environment, the dash must be used as the option character.  Use the  /s  option to instruct  CS_COMP  to produce dictionary files in big endian byte order regardless of the system on which the program has been compiled. This forces a byte swap before output on little endian processors (e.g. Intel) and omits the byte swap on big endian processors (e.g. Sun).", 
            "title": "CS_COMP\u2014Coordinate System COMPiler"
        }, 
        {
            "location": "/userguide/executables/#byte-ordering", 
            "text": "CS_COMP  calls  CS_bswap  immediately prior to writing any data to the dictionary file in order to effect, as necessary, a byte order switch to little endian (i.e. Intel/DOS) byte order. This is the same byte order expected by the CS-MAP library on all platforms. It is also the byte order which the data file from other sources, such as the NADCON LAS/LOS files, are distributed. Use of the /s options reverses this effect, causing big endian data files to be produced, regardless of the processor in use.", 
            "title": "Byte Ordering"
        }, 
        {
            "location": "/userguide/executables/#source-file-formats", 
            "text": "", 
            "title": "Source File Formats"
        }, 
        {
            "location": "/userguide/executables/#coordsysasc", 
            "text": "Records in the  COORDSYS.ASC  source file consist of a line of text. Blank lines are generally ignored. All characters following an un-escaped pound sign character ('#') are ignored. The pound sign character can be escaped by the backslash ('\\') or pound sign ('#') characters. Note that this is required to get a pound sign character into a coordinate system description as these descriptions are not quoted. Leading and trailing whitespace on all records is also ignored. Records to be processed must start with one of the 39 keywords described below. The colon separator character is considered to be part of the keyword. The value of the keyword must follow the keyword on the same line of text, white space may be used to separate the keyword from its value.  Each occurrence of the  CS_NAME : keyword indicates the beginning of a new coordinate system definition and the end of any previous coordinate system definition. Otherwise, the order of the specifications is not important. However, to maintain your source in a comprehensible format, it is strongly recommended that each coordinate system definition begin with the  CS_NAME : keyword and be terminated by one or more blank lines. No blank lines should appear within the definition itself. Further, while  CS_COMP  will sort the resulting binary Coordinate System Dictionary file, maintaining the coordinate system source file in sorted order makes it (relatively) easy to locate a definition should review or editing be required.  For projection specific information, refer to the projection descriptions of this guide. Note that rarely will any projection require the use of all 39 keyword specifications.  The 25 keywords and their values are:   CS_NAME : - Used to specify the key name of the coordinate system which is to be defined, 23\ncharacters max. See  CS_nampp  for conventions concerning key names.  DESC_NM : - Used to specify the 63 character descriptive name of the coordinate system being defined.  DT_NAME : - Used to specify the datum key name to which a geodetically referenced coordinate system is to be referenced to. The ellipsoid used is a part of this datum definition. Presence of a valid datum key name here indicates that the coordinate system is geodetically referenced. Either a  DT_NAME : specification, or an  EL_NAME : specification must be provided for each coordinate system definition. If both  DT_NAME : and  EL_NAME : specifications are provided, the  EL_NAME : specification is ignored by CS-MAP.  EL_NAME : - Used to specify the ellipsoid key name for a cartographically referenced coordinate system. A coordinate system is cartographically referenced to the ellipsoid named by this specification if, and only if, the datum key name specification is omitted. If both  DT_NAME : and  EL_NAME : specifications are provided, the  EL_NAME : specification is ignored by CS-MAP.  ORG_LAT : - Used to specify the origin latitude of the coordinate system. This value may be in any form acceptable to  CS_atof , but is always in  degrees  relative to the equator. Use positive numbers for north latitude, negative numbers for south latitude.  ORG_LNG : - Used to specify the origin longitude of the coordinate system. This value may in any form acceptable to  CS_atof , but always in degrees and is always relative to the Greenwich prime meridian. Use positive numbers for east longitude, negative numbers for west longitude.  SCL_RED : - Used to specify the scale reduction which may apply to a coordinate system. This value is ignored by the many projections which do not support this feature. The value may be specified as a decimal number, e.g. 0.9996, or as a ratio, e.g. 1:2500. A value of 1.0 or greater is unusual, but is accepted.  ZERO_X : - Used to specify the minimum X value which is to be considered non-zero. X coordinate values whose absolute value is less than the value specified here will be converted to hard zeros. This is used to suppress coordinate output such as 4.3472E-07 which can be of value in certain applications. A value of 0.0 is assumed if no specification is made.  ZERO_Y : - Used to specify the minimum Y value which is to be considered non-zero. Y coordinate values whose absolute value is less than the value specified here will be converted to hard zeros. This is used to suppress coordinate output such as 4.3472E-07 which can be of value in certain applications. A value of 0.0 is assumed if no specification is made.  PARM1 : thru  PARM24 : - Used to specify the value of as many as 24 parameters which are specific to the particular projection in use. The use of these items varies from one projection to another. The value is always a real number. Where a longitude is specified, it must be given in degrees, relative to Greenwich, where west longitude is negative. Where a latitude is expected, it must be given in degrees relative to the equator where north latitude is positive and south latitude is negative. When an azimuth is specified, it must be given in degrees east of north (i.e. west of north would be negative). In all cases, the values are processed by  CS_atof , and any form acceptable to that function may be used.  X_OFF : - Used to specify the value of the false easting of the coordinate system. A value of 0.0 is assumed if no specification is made. Any form acceptable to  CS_atof  may be used, including the use of the comma as a thousands separator.  Y_OFF : - Used to specify the value of the false northing of the coordinate system. A value of 0.0 is assumed if no specification is made. Any form acceptable to  CS_atof  may be used, including the use of the comma as a thousands separator.  PROJ : - Used to specify the code name of the projection upon which the coordinate system is based. This code value must be the value assigned to the desired projection in the  CSdataPJ  module, i.e. the projection table. This value is a character string of two to eight characters. Since projections can now have several variations, this code value is not the same as the five character code used to generate function and structure tag names. You will need to refer to the  CSdataPJ  module to determine the code name for a specific projection type.  UNIT : - Used to specify the name of the system unit for the coordinate system being defined. In the case of a normal cartesian coordinate system, this must be one of the supported unit of length names as defined in the  CSdataU  module. In the case of the Unity projection, i.e. the coordinate system being defined is latitude and longitude or a variation thereof, the unit name must be one of those names defined as a unit of angular measure in the  CSdataU  module.  GROUP : - Used to classify coordinate systems into groups to make selection of a coordinate system from the 5,000+ provided a bit easier. The supported group codes are defined in the  CSdata  module.  SOURCE : - Used to specify the source of the information used to define this coordinate system, 63 characters maximum. The term Authority is often used to describe this information.  QUAD : - Used to indicate the quadrant of the cartesian coordinates produced by the coordinate system. Zero or 1 indicate the normal right handed cartesian system where X increases to the east, and Y increases to the north. Quadrants are numbered counterclockwise, therefore a value of 2 specifies a cartesian system where X increases to the west, while Y increases north. A value of 3 indicates that X increases to the west and Y increases to the south. A value of 4 indicates that X increases to the east and Y increases to the south. A negative value will cause the axes to be swapped  after  the appropriate quadrant is applied. A value of 1 is assumed if this specification is absent.  MIN_LNG : - This parameter is optional and can be used to specify the minimum longitude of the useful range of the coordinate system. The value is given in degrees relative to Greenwich in any form acceptable to  CS_atof . Positive values indicate east longitude, while negative values indicate west longitude. Its value should be normalized between -360 and +360 and when used must be algebraically less than the  MAX_LNG : parameter.  MAX_LNG : - This parameter is optional and can be used to specify the maximum longitude of the useful range of the coordinate system. The value is given in degrees relative to Greenwich in any form acceptable to  CS_atof . Positive values indicate east longitude, while negative values indicate west longitude. Its value should be normalized between -360 and +360 and when used must be algebraically greater than the  MIN_LNG : parameter.  MIN_LAT : - This parameter is optional and can be used to specify the minimum latitude of the useful range of the coordinate system. The value is given in degrees relative to the equator in nay form acceptable to  CS_atof . Positive values indicate north latitude while negative values indicate south latitude. Its value should be normalized between -90 and +90 and when used must be algebraically less than the  MAX_LAT : parameter.  MAX_LAT : - This parameter is optional and can be used to specify the maximum latitude of the useful range of the coordinate system. The value is given in degrees relative to the equator in nay form acceptable to  CS_atof . Positive values indicate north latitude while negative values indicate south latitude. Its value should be normalized between -90 and +90 and when used must be algebraically greater than the  MIN_LAT : parameter.  MIN_XX : - This parameter is optional and can be used to specify the minimum X coordinate value of the useful range of the coordinate system. The value is given in system units and may be provided in any form acceptable to  CS_atof . Its value must be algebraically less than the  MAX_XX : parameter.  MAX_XX : - This parameter is optional and can be used to specify the maximum X coordinate value of the useful range of the coordinate system. The value is given in system units and may be provided in any form acceptable to  CS_atof . Its value must be algebraically greater than the  MIN_XX : parameter.  MIN_YY : - This parameter is optional and can be used to specify the minimum Y coordinate value of the useful range of the coordinate system. The value is given in system units and may be provided in any form acceptable to CS_atof. Its value must be algebraically less than the  MAX_YY : parameter.  MAX_YY : - This parameter is optional and can be used to specify the maximum Y coordinate value of the useful range of the coordinate system. The value is given in system units and may be provided in any form acceptable to  CS_atof . Its value must be algebraically greater than the  MIN_YY : parameter.   Other key words have been coded into the  CS_COMP  module but are reserved for future use by OSGeo contributors. They should not be used until their exact usage is defined in a future release.", 
            "title": "Coordsys.asc"
        }, 
        {
            "location": "/userguide/executables/#datumsasc", 
            "text": "Records in the DATUMS.ASC source file consist of a line of text. Blank lines are ignored. All characters following an un-escaped pound sign character (' # ') are ignored. The pound sign character can be escaped by the backslash ('\\') or pound sign ('#') characters. Note that this is required to get a pound sign character into a datum description as these descriptions are not quoted. Leading and trailing whitespace on all records is also ignored. Records to be processed must start with one of the twelve keywords described below. The colon separator character is considered to be part of the keyword. The value of the keyword must follow the keyword on the same line of text, white space may be used to separate the keyword from its value.  Each occurrence of the  DT_NAME : keyword indicates the beginning of a new datum definition and the end of any previous datum definition. Otherwise, the order of the specifications is not important. However, to maintain your source in a comprehensible format, it is strongly recommended that each coordinate system definition begin with the  DT_NAME : keyword and be terminated by one or more blank lines. No blank lines should appear within the definition itself. Further, while  CS_COMP  will sort the resulting binary Datum Dictionary file, maintaining the datums source file in sorted order makes it (relatively) easy to locate a definition should review or editing be required.  Also note, that CS-MAP uses the Datum Key name as the base portion of a file name to access the Multiple Regression Transformation file. Therefore, a datum key name of more than 8 characters on a DOS based system may not work as expected.  The twelve keywords and their required values are:   DT_NAME : - Used to specify the key name of the datum which is to be defined, 23 characters max. Refer to  CS_nampp  for conventions concerning key names. Since datum key names are used to link to the Multiple Regression Transformation files, datum key names longer than 8 characters may present problems on systems using the DOS FAT-16 file system (i.e. file name limited to 8 characters).  DESC_NM : - Used to specify the 63 character descriptive name of the datum being defined. ELLIPSOID: - Used to specify the key name of the ellipsoid definition upon which this datum is based.\nThis name must be the key name of an entry in the Ellipsoid Dictionary.  USE : \u2014 This parameter is required and is used to specify the datum conversion technique to convert coordinates based on the datum being defined to WGS84 coordinates. There are, currently, ten valid values. They are:  MOLODENSKY  - Use the Molodensky transformation to convert to WGS84.  GEOCENTRIC  - Use the geocentric translation method to convert to WGS84.  BURSA  - Use the Bursa/Wolfe Seven Parameter Transformation to convert to WGS84.  7PARAMETER  - Use the Seven Parameter Transformation to convert to WGS84, default to Molodensky if the necessary parameters are not present.  MULREG  - Use the Multiple Regression Transformation formulas. If such a definition is not available, default to the Bursa/Wolfe Seven Parameter Transformation.  NAD27  - Use the NADCON or Canadian National Transformation emulation as appropriateto convert to NAD83, and consider the result to be WGS84 coordinates.  `NAD83 - Consider the coordinates to be WGS84 coordinates already, no shift is to be performed.  WGS84  - The coordinates are WGS84 coordinates already, no datum shift is required.  WGS72  - Use an internal formula to convert to WGS84.  HPGN  - Use the NADCON algorithm, but use the HPGN data files, to shift the coordinates to NAD83, then consider the result to be WGS84 coordinates without any further datum shift.    DELTA_X : - The X component of the vector from the geocenter of this datum to the geocenter of the WGS-84 datum in meters.  DELTA_Y : - The Y component of the vector from the geocenter of this datum to the geocenter of the WGS-84 datum in meters.  `DELTA_Z : - The Z component of the vector from the geocenter of this datum to the geocenter of the WGS-84 datum in meters.  BWSCALE : - The scale of the Bursa/Wolfe or Seven Parameter Transformation, given as parts per million as is ordinarily the case for this transformation. This value can be positive or negative. The actual resulting scale factor used in the transformation is  1.0 + (BWSCALE * 1.0E-06) .  ROT_X : - The rotation about the X axis, given in seconds of arc. Positive values indicate clockwise rotation of the right handed Helmert coordinate system.  ROT_Y : - The rotation about the Y axis given in seconds of arc. Positive values indicate clockwise rotation of the right handed Helmert coordinate system.  ROT_Z : - The rotation about the Z axis given in seconds of arc. Positive values indicate clockwise rotation of the right handed Helmert coordinate system.  SOURCE : - The source of information from which this definition was developed.   Support of other keywords has been coded into the  CS_COMP  module; but use of these is reserved by\nOSGeo contributors for future use.", 
            "title": "Datums.asc"
        }, 
        {
            "location": "/userguide/executables/#elipsoidasc", 
            "text": "Records in the  ELIPSOID.ASC  source file consist of a line of text. Blank lines of text are ignored. All characters following an un-escaped pound sign character (' # ') are ignored. The pound sign character can be escaped by the backslash ('\\') or pound sign (' # ') characters. Note that this is required to get a pound sign character into an ellipsoid description as these descriptions are not quoted. Leading and trailing white space on all records is also ignored. Records to be processed must start with one of the five keywords described below. The colon separator character is considered to be part of the keyword. The value of the keyword must follow the keyword on the same line of text, white space may be used to separate the keyword from its value.  Each occurrence of the  EL_NAME : keyword indicates the beginning of a new ellipsoid definition and the end of any previous ellipsoid definition. Otherwise, the order of the specifications is not important. However, to maintain your source in a comprehensible format, it is strongly recommended that each ellipsoid definition begin with the  EL_NAME : keyword and be terminated by one or more blank lines. No blank lines should appear within the definition itself. Further, while  CS_COMP  will sort the resulting binary Ellipsoid Dictionary file, maintaining the ellipsoid definition source file in sorted order makes it (relatively) easy to locate a definition should review or editing be required.  The six keywords and their required values are:   EL_NAME : - Used to specify the key name of the ellipsoid which is to be defined, 23 characters max.  DESC_NM : - Used to specify the 63 character descriptive name of the ellipsoid being defined.  E_RAD : - Used to specify the equatorial radius of the ellipsoid being defined. This radius  must  be specified in meters.  P_RAD : - Used to specify the polar radius of the ellipsoid being defined. This radius  must  be specified in meters. Use the same value given for  E_RAD : to define a spherical ellipsoid.  SOURCE : - The source of the information used to make this definition.  GROUP : - This keyword is used to mark ellipsoid definitions as being for testing only. Additional\ngroups may be established in the future.   CS_COMP  will calculate the eccentricity and flattening from the provided radii.", 
            "title": "Elipsoid.asc"
        }, 
        {
            "location": "/userguide/executables/#mregasc", 
            "text": "Records in a  MREG.ASC  source file consist of a line of text. Blank lines are ignored. All characters following an un-escaped pound sign character (' # ') are ignored. The pound sign character can be escaped by the backslash ('\\') or pound sign (' # ') characters. Note that this is required to get a pound sign character into a datum description as these descriptions are not quoted. Leading and trailing white space on all records is also ignored. Records to be processed must start with one of the 12 keywords described below. The colon separator character is considered to be part of the keyword. The value of the keyword must follow the keyword on the same line of text, white space may be used to separate the keyword from its value. In certain cases, the actual keyword contains numeric qualifiers which indicate the specific power series term the keyword applies to.  Each occurrence of the  DATUM_NAME : keyword indicates the beginning of a new multiple regression definition and the end of any previous multiple regression definition. The order of the specifications is not important. However, to maintain your source in a comprehensible format, it is strongly recommended that each multiple regression definition begin with the  DATUM_NAME : keyword and be terminated by one or more blank lines. No blank lines should appear within the definition itself. Maintaining the multiple regression source file in sorted order makes it (relatively) easy to locate a definition should review or editing be required.  Please note that a test case is required for each datum. A binary multiple regression coefficient data file will not be written unless the provided coefficients satisfy the provided test case. In the terminology used in this module,  LAMBDA  refers to longitude, and  PHI  refers to latitude. In preparation for future enhancements to CS-MAP, the  HEIGHT  coefficients are also required. If such are not currently available, simply use values which will produce a zero change in height to get around the required coefficient check.  Values for the various keywords are given in a manner which is somewhat inconsistent with CS-MAP. However, the manner in which these values are specified is consistent with the conventions used in the source for most of this type of information: DMA TR-8350.2B.  The 12 keywords and their required values are:   DATUM_NAME : - Used to specify the 23 character name of the datum for which the following coefficients represent the multiple regression coefficients. This is the name, with the .MRT extension appended, which is given to the coefficient data file. The association of a datum in the Datum Dictionary and the multiple regression data file is established by this name.  TEST_LAMBDA : - This keyword must be followed by the longitude of the test point. This longitude must be given in degrees, minutes, and seconds form, where west longitudes are given as values greater than 180. This entry is processed by a \"%d %d %lf\"  sscanf  format specification.  TEST_PHI : - This keyword must be followed by the latitude of the test point. This latitude must be given in degrees, minutes, and seconds form. Use a negative value to indicate south latitude. This entry is processed by a \"%d %d %lf\"  sscanf  format specification.  DELTA_LAMBDA : - This keyword must be followed by a single real value which represents the amount of longitude shift, in seconds of arc, which is expected at the provided test point.  DELTA_PHI : - This keyword must be followed by a single real value which represents the amount of latitude shift, in seconds of arc, which is expected at the provided test point.  DELTA_HEIGHT : - This keyword must be followed by a single real value which represents the amount of elevation shift, in meters, which is expected at the provided test point.  LAMBDA_OFF : - This keyword must be followed by the longitude offset used to normalize the coefficient formula. This value must be given in decimal degrees, use negative values for west longitude.  PHI_OFF : - This keyword must be followed by the latitude offset used to normalize the coefficient formula. This value must be given in decimal degrees, use negative values for west longitude.  KK  - This keyword must be followed by the scale factor which is used to normalize the regression formula. This value is unitless.  LAMBDA  - This keyword is used to identify a longitude formula coefficient. The keyword itself must be followed by a  Un  and a  Vn  sequence which indicates which coefficient follows. For example,\n       LAMBDA U1 V2: 1.23456 \nindicates that 1.23456 is the coefficient for the longitude times latitude squared term in the regression formula. CS-MAP does not support terms with powers higher than 9.  PHI  - This keyword is used to identify a latitude formula coefficient. The keyword itself must be followed by a  Un  and a  z  sequence which indicates which coefficient follows. For example,\n       PHI U2 V1: 1.23456 \nindicates that 1.23456 is the coefficient for the longitude squared times latitude term in the regression formula. CS-MAP does not support terms with powers higher than 9.  HEIGHT  - This keyword is used to identify an elevation formula coefficient. The keyword itself must be followed by a  Un  and a  z  sequence which indicates which coefficient follows. For example,  HEIGHT U0 V0: 1.23456  indicates that 1.23456 is the constant term in the regression formula. CS-MAP does not support terms with powers higher than 9.", 
            "title": "MReg.asc"
        }, 
        {
            "location": "/userguide/executables/#test-test-program", 
            "text": "TEST [/t12345...] [/dmap_dir] [/pnn] [/s] [/v] [/b] [test_data_file_name]  TEST  will exercise most (but not all) of the functions included in the Coordinate System Mapping Package library. It can be used to verify the correct operation of the library in different environments, especially useful after compiling the library with a new or different C compiler or on a different platform.  Since  TEST  relies on the test coordinate systems, datums, and ellipsoids,  CS_COMP  should be run with the  /t  option prior to using the  TEST  program.  The program requires no arguments and normally expects the Ellipsoid Dictionary, the Datum Dictionary, the Coordinate System Dictionary, all Multiple Regression Transformation files, and Geodetic Data Catalogs to reside in their default locations and the file  TEST.DAT  to reside in the current working directory when executed. As a convenience, however, if a file named  COORDSYS  exists in the same directory from which  TEST  was executed,  TEST  will look to that directory for all supporting data files (except the  TEST.DAT  file). Alternatively, you may use the  /d  option to specify the directory you want  TEST  to look to for all supporting data files.  TEST  will write all diagnostic messages to the console screen. On Windows 95/98/NT systems, you will need to use the MS-DOS option character (i.e. the forward slash) when specifying options.  The provided test file,  TEST.DAT , includes tests for the NAD27 to NAD83 datum conversion software. Therefore, the NADCON CONUS database file system must exist in the default data directory (see  CSdata(5CS) ) if these tests are to be successful.  TEST.DAT  also includes tests for the Canadian National Transformation. However, since OSGeo cannot distribute the data files associated with the Canadian National Transformation, these tests have been commented out. Canadian users may wish to uncomment these tests before using  TEST .  The command line options can be used to modify the operation of the test procedure. There are, currently, 19 separate tests performed by  TEST , and each is designated with a number or a letter. Normally,  TEST  performs each of the first fifteen tests twice; first in forward numeric order, and then in reverse numeric order. Use the  /t  option to specify the specific test(s) you would like performed, and the order in which they are to be performed; one test per character (120 maximum).", 
            "title": "TEST -- TEST program"
        }, 
        {
            "location": "/userguide/executables/#individual-tests", 
            "text": "The nature of the 16 tests are:   Test 1  - This test manipulates the Ellipsoid Dictionary using  CS_eldef ,  CS_elupd , and  CS_eldel .  Test 2  - This test manipulates the Datums Dictionary using  CS_dtdef ,  CS_dtupd , and  CS_dtdel .  Test 3  - This test manipulates the Coordinate System Dictionary using  CS_csdef ,  CS_csupd , and  CS_csdel .  Test 4  - This test reads the file named  TEST.DAT  in the current directory and performs all of the conversions indicated, comparing the calculated results with the expected results recorded in the file. Of course, all discrepancies are reported to the user. You may specify an alternate file name (and directory) on the command line as the only positional argument. Each supported projection (except the Equidistant Cylindrical) has at least one test from a source other than CS-MAP in  TEST.DAT .  TEST.DAT  also includes tests of datum conversions.  Test 5  - Test 5 is a performance test. Normally, it records the amount of wall clock time necessary to make 300,000 conversions from \"UTM27-13\" to \"CO83-C\" using the High Performance Interface. Each conversion, therefore, includes an inverse Transverse Mercator, a NAD27 to NAD83 datum shift, and a forward Lambert Conformal Conic conversion. The test cycles through a list of 10 different coordinate pairs to add some reality to the test without distorting the numeric results with I/O time and/or system overhead. The elapsed time and the effective conversion rate are reported to the user. The  /p  option can be used to change the number of conversions in the test. For example,  /p45  would instruct  TEST  to perform 450,000 conversions whenever it performs test number 5.  Test 6  - This test exercises the sorting and binary search functions of CS-MAP well beyond what would be experienced in normal use. This is accomplished by sorting the Coordinate System Dictionary into reverse order, binary searching the result, and resorting back into normal order. Finally, the order of the result is verified to be correct.  Test 7  - This test exercises the  CS_csgrp  function and its supporting data.  Test 8  - For each coordinate system in the Coordinate System Dictionary, this test will cause a coordinate to be converted in both the forward and inverse direction, as well as calculate the grid scale factor and the convergence angle. This test does not verify the accuracy of the results, but simply assures that every calculation function is exercised at least once. This test is somewhat superfluous now that Test C is available.  Test 9  - This test exercises the functions which are used to calculate the power series solutions to the elliptical integrals used quite frequently in CS-MAP. It verifies the results against an outside source, and then compares forward and inverse calculations with each other. Please note that the external source for the correct values is limited in precision. Therefore the RMS discrepancy values may be alarmingly high. This is not the case, however, as indicated by the RMS discrepancies between forward and reverse calculations.  Test A  - This test is identical to  test 4  in every way except it uses the High Level Interface function  CS_cnvrt  function for all conversions, thus testing the caching system for coordinate systems and datum conversions.  Test B  -  Test B  tests the grid scale and convergence angle functions of all non-azimuthal projections. It uses an empirical technique to determine the grid scale and convergence angle of several random points within the useful range of each coordinate system. Azimuthal projections are skipped as the grid scale functions in these cases usually return scale factors along and normal to radials from the origin. An empirical means of calculating these scale factors eludes us at the current time.  Test C  - This test tries very hard to produce a floating point exception. Very regular and randomly generated coordinate values, both geographic and cartesian, are generated and passed to all functions for each coordinate system in the coordinate system dictionary. The coordinates are, in most cases, completely outlandish numbers. Reporting floating point exceptions is very difficult, however, varying from compiler to compiler, system to system. However, CS-MAP has passed this test many times, on four different compilers.  Test D  - This test tests the forward and inverse functions of each projection against each other. That is, random geographic coordinates within the useful range of each coordinate system are converted to cartesian form using the forward function, and then back to geographic using the inverse function. The results are then compared.  Test E  - This test performs all the functions of Test D; but in this case the useful range of each of the projections is reduced by about one half, and thus enabling the error tolerance to be substantially reduced.  Test F  -  Test F  tests the  CS_atof  and  CS_ftoa  functions in two phases. First, the standard system function  sprintf  is used to check the operation of the  CS_atof  function. In the second phase,  CS_atof  is used to test the  CS_ftoa  function. Neither phase, currently, tests the operation of the degree, minute. and/or second processing.  Test G  -  Test G  is the coordinate creep test. Creep is defined as the number of millimeters a coordinate moves after repeated conversions from cartesian to geographic and back.  Test G  starts with a specific cartesian coordinate well within the useful range of a projection (but certainly not the natural origin) and converts the coordinate to geographic and back to cartesian 1,000 times. The distance between the original coordinate and the final result is calculated in millimeters to arrive at the creep value. A creep value greater than 10 is considered a failure. As of release 8.01, only the four most used projections are tested.  Test S  - This is not really a test, per se, but a request that the test program switch its mode with regard to byte ordering. Thus, on an little endian processor such as Intel, the initial S in a test sequence will cause all binary data files to be swapped to big endian byte ordering and the  CS_bswap  module adjusted to cause the necessary byte swaps for the program to function. Thus, all byte swapping mechanisms can be tested on a single processor. Since the byte swap algorithm is its own inverse, a second occurrence of Test S reverses the effect of a previous execution. Note, including an odd number of S specifications in the test specification will leave all dictionary files in a swapped condition.  Test V  - This is not a test. Occurrence of a  V  in the test string simply toggles the verbose flag. Thus, the verbose flag can be turned off , or on, for specific tests individually.  Test Z  - This is not a test. When  TEST  encounters this character in the test sequence, it simply starts the test sequence again from the beginning. Thus, an infinite loop can be established. Typically, a  CONTROL-C  is used to terminate the program at some point.", 
            "title": "Individual Tests"
        }, 
        {
            "location": "/userguide/executables/#test-data", 
            "text": "The  TEST.DAT  file specifies the actual coordinates which are to be converted and the expected results. TEST ignores empty lines in the file and lines which begin with the pound sign ( # ) character. Other records are expected to contain 8 fields separated by commas. The eight fields are expected to contain:   Key name of the coordinate system of the coordinates specified in fields 2 and 3 of this line. That is, the name of the source coordinate system of the test conversion to be performed.   3. The X and then Y coordinates to be converted. These are expected in decimal form and are converted to binary using the  CS_atof  function of the CS-MAP library. Thus a variety of forms can be used.  Key name of the coordinate system to which the coordinates given in fields 2   3 are to be converted.   6. The expected X and Y coordinates of the conversion. Again, any form acceptable to  CS_atof  can be used.   8. The X and Y tolerance within which the converted values must agree with the expected values. If the converted values do not match the expected values within the specified tolerance, a diagnostic message is printed.   Most conversion examples provided in  TEST.DAT  were obtained from reputable sources other than CS_MAP itself. Comments in the  TEST.DAT  file itself will indicate those specific tests which have not been verified with sources outside other than CS-MAP. The tolerance values given in the provided  TEST.DAT  file should not be considered as an indication of the accuracy or precision of the CS-MAP library. Rather, these values usually indicate the accuracy and precision of the source data from which the examples were obtained. Occasionally, the tolerance values do indicate the accuracy of the CS- MAP library; comments in the  TEST.DAT  file indicate when this is the case.", 
            "title": "Test Data"
        }, 
        {
            "location": "/userguide/executables/#other-command-line-options", 
            "text": "Finally, the  /v  option can be used to cause  TEST  to operate in verbose mode. In this mode,  TEST  will report its progress through each test. In order to enable use of  TEST  as a Windows NT console application,  TEST  normally requires an acknowledgment when all tests are complete. The  /b  option can be used to suppress this feature. The  /s  option can be used to instruct  TEST  to start out in big endian mode; useful when testing the automatic byte swapping feature. Use the  /d  option to provide TEST with the full path to the directory containing the binary dictionary files it is to use. In the absence of this option,  TEST  uses the directory encoded into the  CSdata  module; except that if a valid  COORDSYS  file exists in the directory from which  TEST  was executed, that directory is used (MS-DOS only). Use the  /p  option to indicate the length of the performance test (i.e.  Test 5 ). The value provided is multiplied by 10,000 to obtain the number of conversions which are performed and timed in order to produce the conversion rate.", 
            "title": "Other Command Line Options"
        }, 
        {
            "location": "/userguide/executables/#bugs", 
            "text": "Test C , the floating point exception test, does not exercise the datum conversion functions as yet.", 
            "title": "BUGS"
        }, 
        {
            "location": "/userguide/executables/#mfctest-mfc-dialog-test", 
            "text": "mfcTEST  mfcTest  is designed to test the MFC based GUI interactive dialogs provided with CS-MAP. The program is a simple dialog box MFC program which contains a menu. The single menu entry provides a selection for each of the primary dialogs provided. Note also, that the Test dialog can be very convenient for testing projection and datum shift calculations in an interactive environment (assuming you're using Windows, of course).  This test program requires no arguments. All testing must be done in an interactive manner. Note, that each of the dialogs has a help button, and expects to find the help file in the same directory as the primary mapping data files. The help buttons are grayed out if the help file does not exist in this location.", 
            "title": "mfcTEST -- MFC Dialog TEST"
        }, 
        {
            "location": "/userguide/executables/#dictionary-differences-program", 
            "text": "The source to Dictionary Difference program,  DictDiff , is conveyed in a file named  CS_DictDiff.c ; the distribution places this file in the  Dictionary  directory. The main module calls functions named  CS_csDiff ,  CS_dtDiff , and  CS_elDiff  which are defined in a module named  CSdictDiff.c  which the distribution deposits in the  Source  directory. These three functions are a part of the normal library build.  Messages which report differences refer to \"was\" and \"is\". That is, messages report the previous value and the new value for all detected changes.  DictDiff  is a command line program and can used in virtually any environment that supports a C compiler. It compares the binary forms of dictionary files and reports all differences detected. It requires exactly two positional arguments. The first command line argument is the directory containing the \"was\" or previous dictionary files. The second argument is the directory of the \"is\" or current dictionary files. All messages are reported to  stdout , i.e. the terminal.  In producing the differences, some tolerance numbers had to be chosen to delineate what a change consists of. You should examine the source code in file named  CSdiffDict.c  to verify that you are comfortable with the tolerance values that were chosen. The tolerance values are manipulated throughout the program, but the variable name  okValue  is consistent.", 
            "title": "Dictionary Differences Program"
        }, 
        {
            "location": "/userguide/libraryfunctions/", 
            "text": "Library Functions\n\n\nThis section includes a technical description of 500+ functions in the CS-MAP library. The descriptions are organized by the interface of which they are a part. An index is provided elsewhere in this document.\n\n\nHigh Level Interface Functions\n\n\nFunctions described in this section are designed to be called from high level languages such as Visual Basic. Therefore, descriptions of most functions in this section also include a function declaration appropriate for use in Visual Basic and Delphi in addition to the standard C prototype.\n\n\nCS_altdr Alternate Directory\n\n\nFunction CS_altdr (ByVal new_dir As String) As Integer function CS_altdr (alt_dr :PChar):Integer;\nint CS_altdr (Const char alt_dir);\n\n\n\n\nNormally, all functions in the Coordinate System Mapping Package library expect to find data files in the \nC:\\MAPPING\n directory as defined in \nCSdata\n. \nCS_altdr\n can be used to specify an alternate directory at run time; that indicated by the \nalt_dir\n argument. \nCS_altdr\n returns zero if a coordinate system dictionary was indeed found in the directory provided; otherwise, it returns -1.\n\n\nCalling \nCS_altdr\n with the \nNULL\n pointer as its argument instructs \nCS_altdr\n to use the value of the environmental variable \nCS_MAP_DIR\n as the location of the CS-MAP data files. Again a zero is returned if this was successful, -1 if not. (The string defining the name of the environmental variable name is defined in the \ncs_map.h\n header file.)\n\n\nCalling \nCS_altdr\n with the \nalt_dir\n argument pointing to the null string instructs \nCS_altdr\n to use the current directory on the current drive as the location of CS-MAP data files. Again a zero is returned if this selection produces a directory which contains a Coordinate System Dictionary File. Otherwise -1 is returned.\n\n\nNotice, that using the return status as a guide, several attempts at locating the CS-MAP data directory can be made in any application.\n\n\nThe name of the directory which is searched for all data files is maintained in a global character array \ncs_Dir\n, which is defined in the \nCSdata\n module. The \ncs_Dir\n array must, initially, contain a null terminated string, the last non-null character of which must be the directory separator character. The global character pointer \ncs_DirP\n (also defined in \nCSdata\n) is expected to point to the terminating null character of the string in \ncs_Dir\n. Under this scheme, Coordinate System Mapping Package data files\nare accessed as follows:\n\n\nextern char cs_Dir [];\nextern char *cs_DirP;\n:\nstrcpy (cs_DirP,\nfile_name\n);\nfd = open (cs_Dir,O_MODE);\n:\n\n\n\n\nAchieving this particular setup is relatively easy using \nCS_stcpy\n:\n\n\ncs_DirP = CS_stcpy (cs_Dir,\nC:\\\\MAPPING\\\\\n);\n\n\n\n\nBUGS\n\n\nThe purpose of this function is to insulate the library from system implementation issues. Without a function of this nature, all applications using CS-MAP would have to implement a specific directory on a specific drive. Not very pleasant. There does not appear to be a nice clean solution to this problem.\n\n\nCS_atof Ascii to floating point\n\n\nFunction CS_atof (ByRef result As Double,ByVal value As String) As Long\nfunction CS_atof (var result :double;value: PChar) :LongInt;\nlong CS_atof (double *result,Const char *value);\n\n\n\n\nCS_atof\n will convert the ASCII, null terminated string provided by the \nvalue\n argument to double precision floating point form, returning this result in the location pointed to by the \nresult\n argument. Obviously, the string provided by \nvalue\n is expected to be an ASCII representation of a numeric value.\n\n\nCS_atof\n has several features built into it for handling numeric formats that are commonly used in mapping, specifically, large numbers, and values in degrees, minutes, and seconds format. Use of thousands separators is supported and, when present, their improper use is reported. Other than leading white space, spaces in the input value are interpreted to indicate degrees, minutes, and seconds format. Values can be entered using minutes only (a single space) or minutes and seconds (two spaces encountered). Use of either directional characters (i.e. N, S, E, W) or plus and hyphen characters for sign is also supported. \nCS_atof\n returns a long that carries a complete specification of the format used to enter the value, suitable for use by \nCS_ftoa\n for formatting the value for output. \nCS_atof\n will also correctly process scale factors entered as ratios, and this feature can be mixed with the thousands separator feature. Thus, scale reduction for state plane coordinate systems can be entered as \"1:17,000.\"\n\n\nThe return value is a bitmap of information used to contain precision, formatting specifications, and error status values. The following descriptions refer to constants defined in the various header files. Construct a format specification by inclusively or'ing the desired options:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_ATOF_PRCMSK\n\n\nThe least significant five bits are used to indicate the number of digits found after the decimal point. The value is actually the number of digits plus one. (Zero is reserved to indicate automatic precision determination on output.) This constant is a mask that will mask out the precision value.\n\n\n\n\n\n\ncs_ATOF_VALLNG\n\n\nThe value processed is acceptable for a longitude value.\n\n\n\n\n\n\ncs_ATOF_VALLAT\n\n\nThe value processed is acceptable for a latitude value.\n\n\n\n\n\n\ncs_ATOF_MINSEC\n\n\nThe value processed was in degrees, minutes, and seconds form.\n\n\n\n\n\n\ncs_ATOF_MINUTE\n\n\nThe value processed was in degrees and minutes form.\n\n\n\n\n\n\ncs_ATOF_EXPNT\n\n\nThe value processed was in scientific notation form.\n\n\n\n\n\n\ncs_ATOF_COMMA\n\n\nThe value processed included thousands separators to the left of the decimal point.\n\n\n\n\n\n\ncs_ATOF_DIRCHR\n\n\nThe value processed included directional characters to indicate sign.\n\n\n\n\n\n\ncs_ATOF_XEAST\n\n\nThe directional characters used to indicate the sign came from the E and W set, as opposed to the N and S set.\n\n\n\n\n\n\ncs_ATOF_MINSEC0\n\n\nThe value processed included leading zeros in the minutes or seconds fields.\n\n\n\n\n\n\ncs_ATOF_DEG0\n\n\nThe value processed included leading zeros in the degrees field.\n\n\n\n\n\n\ncs_ATOF_0BLNK\n\n\nThe value processed was the null string.\n\n\n\n\n\n\ncs_ATOF_FORCE3\n\n\nThe value processed used minutes or minutes and seconds format, and 3 digits of degrees were encountered; implying a longitude value.\n\n\n\n\n\n\ncs_ATOF_RATIO\n\n\nThe processed value was provided in the form of a ratio, e.g. 1:2500, to indicate a value such as, for example, 0.9996.\n\n\n\n\n\n\n\n\nBits defined by the following constants are set to indicate the associated error condition. The \ncs_ATOF_FMTERR\n bit is set if any error condition is detected and forces the return value to negative. In all such cases, \nCS_atof\n will report the error condition and a subsequent call to \nCS_errmsg\n will return an appropriate error message.\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_ATOF_SECS60\n\n\nWhat was interpreted to be the seconds field of the processed value produced a value greater than or equal to 60.\n\n\n\n\n\n\ncs_ATOF_MINS60\n\n\nWhat was interpreted to be the minutes field of the processed value produced a value greater than or equal to 60.\n\n\n\n\n\n\ncs_ATOF_MLTPNT\n\n\nMore than one decimal point was encountered in the input value.\n\n\n\n\n\n\ncs_ATOF_MLTSGN\n\n\nMore than one sign indication was encountered in the input value.\n\n\n\n\n\n\ncs_ATOF_ERRCMA\n\n\nImproper positioning of the thousands separator character was detected in the input value.\n\n\n\n\n\n\ncs_ATOF_RATERR\n\n\nA string that contained the ratio character, usually ':', did not conform to the normal convention for a ratio. Usually, the character immediately left of the colon was not a '1'.\n\n\n\n\n\n\ncs_ATOF_FMTERR\n\n\nA general format error, not covered by the above, was encountered in the input value.\n\n\n\n\n\n\ncs_ATOF_ERRFLG\n\n\nThis bit is set, producing a negative return value, if any of the above error conditions are encountered during processing. Whenever this bit is set, the error condition will have been reported to \nCS_erpt\n, and a subsequent call to \nCS_errmsg\n will produce an appropriate error message.\n\n\n\n\n\n\n\n\nCS_azddll LatLong Azimuth Distance calculator\n\n\nFunction CS_azddll ( ByVal e_rad As Double, ByVal e_sq As Double, ByRef ll_fromAs Double,\n                      ByVal azimuth As Double,\n                      ByVal distance As Double,\n                      ByRef ll_to As Double) As Integer\nfunction CS_azddl (e_rad, e_sq: Double; var ll_from: Double; azimuth, distance : Double; var ll_to: Double): Integer;\nint CS_azddl (double e_rad, double e_sq, double ll_from[3], double azimuth, double dist, double ll_to[3]);\n\n\n\n\nCS_azddll\n calculates the latitude and longitude of a target point given an initial point, an azimuth from the initial point, and a distance. The initial point and the result are in degrees, where the longitude occupies the first element in the array and latitude the second element. The reference of the longitude is immaterial, as both (the initial point and the calculated point) will share the same reference whatever it is. Currently, the third element in each array is unused (i.e. un-referenced and unmodified). This may change in future releases. \ne_rad\n is the equatorial radius, and \ne_sq\n the eccentricity squared, of the ellipsoid to be used. The units of the radius are immaterial other than they must be the same as that used to specify the \ndistance\n. \nAzimuth\n is the azimuth at the initial point given in degrees east of north. \ndistance\n is the distance traveled in the same units as used to specify the equatorial radius of the ellipsoid. The result is returned in the array pointed to by the \nll_to\n argument.\n\n\nCS_azddll\n returns a zero to indicate success, -1 for failure. Failure of the internal Newton Rhapson iterative calculation is the only possible cause of failure. This can be caused by rather strange input values, specifically values that would produce results that are antipodal to the initial point.\n\n\nThe algorithm used is known as: \"Solution of the geodetic inverse problem after T. Vincenty modified Rainsford's Method with Helmert's elliptical terms,\" whatever all that means. This algorithm is appropriate for any combination of points that are not antipodal.\n\n\nCS_azsphr Azimuth on a Sphere\n\n\nFunction CS_azsphr (ByRef ll_1 As Double, ByRef ll_2 As Double) As Double\nfunction CS_azsphr (var ll_1, ll_2 :Double) : Double;\ndouble CS_azshpr (Const double ll0 [2],Const double ll1 [2]);\n\n\n\n\nCS_azsphrl\n returns the azimuth, in degrees east of north, from the geographic location given by \nll0\n to the geographic location given by \nll1\n. The calculation assumes a spherical earth, so a radius and eccentricity is not required.\n\n\nCS_cnvrg Convergence function\n\n\nFunction CS_cnvrg (ByVal cs_name As String, ByRef ll_ary As Double) As Double\nfunction CS_cnvrg (cs_name :PChar;var ll_ary :double) :Double;\ndouble CS_cnvrg (Const char *cs_name, Const double ll_ary [2]);\n\n\n\n\nCS_cnvrg\n returns the convergence angle of the coordinate system whose key name is provided by the \ncs_name\n argument, at the location provided by the \nll_ary\n argument. The position provided by the \nll_ary\n argument must be in longitude and latitude form, in degrees, where the first element of the array is the longitude and the second element of the array is the latitude. Use negative values for west longitude and south latitude. The returned value is in degrees, east of north.\n\n\nCS_cnvrg\n uses the same cache of coordinate system definitions as does \nCS_cnvrt\n, therefore, the performance penalty of using this very simple function is not as great as one might expect.\n\n\nErrors\n\n\nCS_cnvrg\n will return a value of -360.0 (clearly a bogus value for a convergence angle) if an error is detected during the calculation. The most common cause of errors is an invalid coordinate system name.\n\n\nCS_cnvrt generalized convert function\n\n\nFunction CS_cnvrt (ByVal src_cs As String,ByVal trg_cs As String, ByRef coord As Double) As Integer\nfunction CS_cnvrt (src_cs,trg_cs :PChar;var coord :double) :Integer;\nint CS_cnvrt (Const char *src_cs,Const char *trg_cs,double coord [3]);\n\n\n\n\nCS_cnvrt\n is in essence a High Level Interface to the CS_MAP library. Using this single function, one can convert coordinates from any defined system to any other. Simply provide the key name of the source system via the \nsrc_cs\n argument, and the key name of the destination coordinate system via the \ntrg_cs\n argument, and \nCS_cnvrt\n will cause the coordinate in the array given by the \ncoord\n argument is converted from the source system to the destination system. \nCS_cnvrt\n returns zero if the conversion completed successfully without incident. Otherwise, a CS-MAP error code value is returned (see \ncs_map.h\n).\n\n\nCS_cnvrt\n relies on a cache of coordinate systems, and for each conversion linearly searches the cache for the definitions of the two coordinate system definitions, and the datum conversion definition, it needs to perform its function. Thus, the performance penalty incurred from using this High Level Interface is not as great as one may think.\n\n\nCurrently, the third element of the \ncoord\n argument is unused; but may be used in the future.\n\n\nCS_cnvrt3D 3D generalized Convert function\n\n\n\nFunction CS_cnvrt3D (ByVal src_cs As String, ByVal dst_cs As String, ByRef coor d As Doubl e) As Integer\nfunction CS_cnvrt3D (src_cs,dst_cs :PChar; var coord :Double):Integer\nint CS_cnvrt3D (Const char *src_cs, Const char *dst_cs, double coord [3]);\n\n\n\n\nCS_cnvrt3D\n is in essence a High Level Interface with regard to three dimensional conversions. Using this single function, one can convert three dimensional coordinates from any defined system to any other. Simply provide the key name of the source system via the \nsrc_cs\n argument, and the key name of the destination coordinate system via the \ndst_cs\n argument, and \nCS_cnvrt3D\n will cause the coordinate in the array given by the \ncoord\n argument to be converted from the source system to the destination system. \nCS_cnvrt3D\n returns a zero if the conversion completed successfully without incident. Otherwise, a CS_MAP error code value is returned.\n\n\nCS_cnvrt3D\n relies on a cache of coordinate systems, and for each conversion linearly searches the cache for the definitions of the two coordinate system definitions, and the datum conversion definition, it needs to perform its function. Thus, the performance penalty incurred from using this High Level Interface is not as great as one may think.\n\n\nUse \nCS_cnvrt3D\n only when converting data maintained in a three dimensional database. Note that if the application is able to supply the returned Z value during an inverse calculation, the inverted result may not match the original values.\n\n\nCS_csEnum Coordinate System Enumerator\n\n\nFunction CS_csEnum ( ByVal index As Integer , ByVal key_name As String, ByVal size As Integer) As Integer\nfunction CS_csEnum(index: Integer; key_name: Pchar; size: Integer):Integer;\nint CS_csEnum(int index, char *key_name, int size);\n\n\n\n\nCS_csEnum\n is used to enumerate all coordinate systems in the Coordinate System Dictionary. \nCS_csEnum\n returns in the memory buffer pointer to by the \nkey_name\n argument the key name of the \nindex\n'th entry in the Coordinate System Dictionary. \nCS_csEnum\n will never write more than size bytes to the indicated location. \nIndex\n is a zero based index; the index of the first entry in the Coordinate System Dictionary is zero.\n\n\nCS_csEnum\n returns a positive 1 to indicate success. If \nindex\n is too large, a zero is returned.\n\n\nErrors\n\n\nCS_csEnum\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_CSDICT\n\n\nThe Coordinate System Dictionary could not be found or otherwise opened. See CS_altdr.\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in accessing the Coordinate System Dictionary.\n\n\n\n\n\n\ncs_CS_BAD_MAGIC\n\n\nThe file assumed to be the Coordinate System Dictionary by virtue of its name was not a Coordinate System Dictionary; it had an invalid magic number or was of an incompatible release level.\n\n\n\n\n\n\ncs_INV_INDX\n\n\nThe index argument was negative.\n\n\n\n\n\n\n\n\nCS_csIsValid Coordinate System key name Is Valid\n\n\nFunction CS_csIsValid (ByVal key_name As String) As Integer\nfunction CS_csIsValid (key_name: PChar) :Integer;\nint CS_csIsValid (Const char *key_name);\n\n\n\n\nCS_csIsValid\n is used to validate coordinate system key names. \nCS_csIsValid\n returns a positive 1 if \nkey_name\n is a valid coordinate system key name, a zero if not.\n\n\nErrors\n\n\nCS_csEnum\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_CSDICT\n\n\nThe Coordinate System Dictionary could not be found or otherwise opened. (See \nCS_altdr\n.)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in accessing the Coordinate System Dictionary.\n\n\n\n\n\n\ncs_CS_BAD_MAGIC\n\n\nThe file assumed to be the Coordinate System Dictionary by virtue of its name was not a Coordinate System Dictionary; it had an invalid magic number. This can also be caused by an incompatible release.\n\n\n\n\n\n\n\n\nCS_csRangeEnum Coordinate System Useful Range Enumerator\n\n\nFunction CS_csRangeEnum (ByVal index As Integer, ByVal csKeyName As String,\nByVal size As Integer) As Integer\nfunction CS_csRangeEnum(index: Integer; csKeyName: Pchar; size: Integer):Integer;\nint CS_csRangeEnum (int index, char * csKeyName, int size);\n\n\n\n\nCS_csRangeEnum\n is used to enumerate all coordinate systems which were located by the last call to the \nCS_csRangeEnumSetup\n function. Using these two functions, it is possible to obtain a list of only those coordinate systems whose useful range include a specific point. \nCS_csRangeEnum\n returns in the memory buffer pointer to by the key_name argument the key name of the \nindex\n'th entry in the list generated by \nCS_csRangeEnumSetup\n. \nCS_csRangeEnum\n will never write more than \nsize\n bytes to the indicated location. \nIndex\n is a zero based index; the index of the first entry in the Coordinate System Dictionary is zero.\n\n\nCS_csEnum\n returns a positive 1 to indicate success. If \nindex\n is too large, a zero is returned. A negative value is returned for a serious error, such as failure to call \nCS_csRangeEnumSetup\n prior to calling this function.\n\n\nCS_csRangeEnumSetup Coordinate System Range Enumeration Setup\n\n\nFunction CS_csRangeEnumSetup (ByVal longitude As Double, ByVal latitude As Double) As Integer\nfunction CS_csRangeEnumSetup (longitude, latitutde :Double) : Integer\nint CS_csRangeEnumSetup (double longitude, double latitude);\n\n\n\n\nUse this function to set the base location for subsequent \nCS_csEnumRange\n usage. That is, use this function to produce (internally) a list of all coordinate systems whose useful range includes the given location. Essentially, this function will generate the list, and the application programmer then uses the \nCS_csEnumRange\n function to enumerate the list.\n\n\nThe location is specified in geographical terms (i.e. latitude and longitude). These values must be in degrees, relative to Greenwich. Since datum differences are on the order of, at most, a few hundred meters, the datum upon which these coordinates are based is immaterial for the purpose of this function.\n\n\nCS_csRangeEnumSetup\n will return a negative value in the event of a serious error, such as being unable to access the Coordinate System Dictionary. Use \nCS_errmsg\n to get a textual description of the error which can be reported to the application user. Otherwise, \nCS_csRangeEnumSetup\n will return the number of coordinate systems located, which can be zero.\n\n\nFinally, note that the \nCS_recvr\n function will recover all allocated resources, including the list of coordinate systems generated by the last call to this function.\n\n\nCS_dtEnum Datum Enumerator\n\n\nFunction CS_dtEnum(ByVal index As Integer, ByVal key_name As String, ByVal size As Integer) As Integer\nfunction CS_dtEnum(index: Integer; key_name: Pchar; size: Integer) :Integer;\nint CS_dtEnum(int index, char *key_name, int size);\n\n\n\n\nCS_dtEnum\n is used to enumerate all datums in the Datum Dictionary. \nCS_dtEnum\n returns in the memory buffer pointer to by the \nkey_name\n argument the key name of the \nindex\n'th entry in the Datum Dictionary. \nCS_dtEnum\n will never write more than \nsize\n bytes to the indicated location. \nIndex\n is a zero based index; the index of the first entry in the Datum Dictionary is zero.\n\n\nCS_dtEnum\n returns a positive 1 to indicate success. If \nindex\n is too large, a zero is returned.\n\n\nERRORS\n\n\nCS_dtEnum\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_DTDICT\n\n\nThe Datum Dictionary could not be found or otherwise opened. (See \nCS_altdr\n.)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in accessing the Datum Dictionary.\n\n\n\n\n\n\ncs_DT_BAD_MAGIC\n\n\nThe file assumed to be the Datum Dictionary by virtue of its name was not a Datum Dictionary; it had an invalid magic number. This can also be caused by a dictionary file of an incompatible release.\n\n\n\n\n\n\ncs_INV_INDX\n\n\nThe index argument was negative.\n\n\n\n\n\n\n\n\nCS_dtIsValid Datum key name is valid\n\n\nFunction CS_dtIsValid (ByVal key_name As String) As Integer\nfunction CS_dtIsValid (key_name: PChar): Integer;\nint CS_dtIsValid (Const char *key_name);\n\n\n\n\nCS_dtIsValid\n is used to validate datum key names. \nCS_dtIsValid\n returns a positive 1 if \nkey_name\n is a valid datum key name, a zero if not.\n\n\nERRORS\n\n\nCS_dtIsValid\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_DTDICT\n\n\nThe Datum Dictionary could not be found or otherwise opened. (See \nCS_altdr\n.)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in accessing the Datum Dictionary.\n\n\n\n\n\n\ncs_DT_BAD_MAGIC\n\n\nThe file assumed to be the Datum Dictionary by virtue of its name was not a Datum Dictionary; it had an invalid magic number. This can also be caused by a dictionary file of an incompatible release.\n\n\n\n\n\n\n\n\nCS_elEnum Ellipsoid Enumerator\n\n\nFunction CS_elEnum(ByVal index As Integer, ByVal key_name As String, ByVal size As Integer) As Integer\nfunction CS_elEnum(index: Integer; key_name: Pchar; size: Integer): Integer;\nint CS_elEnum(int index, char *key_name, int size);\n\n\n\n\nCS_elEnum\n is used to enumerate all ellipsoids in the Ellipsoid Dictionary. \nCS_elEnum\n returns in the memory buffer pointer to by the \nkey_name\n argument the key name of the \nindex\n'th entry in the Ellipsoid Dictionary. \nCS_elEnum\n will never write more than size bytes to the indicated location. \nIndex\n is a zero based index; the index of the first entry in the Ellipsoid Dictionary is zero.\n\n\nCS_elEnum\n returns a positive 1 to indicate success. If \nindex\n is too large, a zero is returned.\n\n\nERRORS\n\n\nCS_elEnum\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_ELDICT\n\n\nThe Ellipsoid Dictionary could not be found or otherwise opened. (See \nCS_altdr\n.)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in accessing the Ellipsoid Dictionary.\n\n\n\n\n\n\ncs_DT_BAD_MAGIC\n\n\nThe file assumed to be the Ellipsoid Dictionary by virtue of its name was not an Ellipsoid Dictionary; it had an invalid magic number. Note that dictionary magic numbers can be different for different releases.\n\n\n\n\n\n\ncs_INV_INDX\n\n\nThe index argument was negative.\n\n\n\n\n\n\n\n\nCS_elIsValid Ellipsoid key name is valid\n\n\nFunction CS_elIsValid (ByVal key_name As String) As Integer\nfunction CS_elIsValid (key_name: PChar): Integer;\nint CS_elIsValid (Const char *key_name);\n\n\n\n\nCS_elIsValid\n is used to validate ellipsoid key names. \nCS_elIsValid\n returns a positive 1 if \nkey_name\n is a valid ellipsoid key name, a zero if not.\n\n\nErrors\n\n\nCS_elIsValid\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_ELDICT\n\n\nThe Ellipsoid Dictionary could not be found or otherwise opened. (See \nCS_altdr\n.)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in accessing the Ellipsoid Dictionary.\n\n\n\n\n\n\ncs_EL_BAD_MAGIC\n\n\nThe file assumed to be the Ellipsoid Dictionary by virtue of its name was not a Ellipsoid Dictionary; it had an invalid magic number. Note that magic numbers can be different for different releases.\n\n\n\n\n\n\n\n\nCS_errmsg Error Message\n\n\nSub CS_errmsg (ByVal my_bufr As String, ByVal bufr_size As Integer)\nprocedure CS_errmsg (msg_bufr: PChar; bufr_size: Integer);\nvoid CS_errmsg (char msg_bufr, int bufr_size);\n\n\n\n\nCS_errmsg\n returns to the calling function a null terminated string which describes the last error condition detected by the CS_MAP library. The result is returned in the buffer pointed to by the \nmsg_bufr\n argument, which is assumed to be \nbufr_size\n bytes long. The message is returned in one character per byte ANSI code characters.\n\n\nCS_errmsg\n will return the null string if called before any error condition is detected.\n\n\nBUGS\n\n\nAfter returning an error message to the user, \nCS_errmsg\n should reset itself to the null string preventing the same error message from being returned a second time. It should, but it doesn't.\n\n\nCS_erpt Error Report\n\n\nextern int cs_Error,cs_Errno;\nvoid CS_erpt (int err_num);\n\n\n\n\nCS_erpt\n is called by all functions in the Coordinate System Mapping Package whenever an error condition is detected. The value of \nerr_num\n indicates the specific error condition detected and \nmust\n be one of the manifest constants defined in \ncs_map.h\n.\n\n\nAt the current time, \nCS_erpt\n does nothing other than set the value of global variable \ncs_Error\n to the supplied value of \nerr_num\n and set the global variable of \ncs_Errno\n to the current value of the system's global variable \nerrno\n.\n\n\nIt is expected that users will want to write their own \nCS_erpt\n function that will properly inform the operator of the nature of the problem encountered.\n\n\nEach function in the Coordinate System Mapping Package is programmed to clean up after itself after return from \nCS_erpt\n. That is, upon return from \nCS_erpt\n, all memory \nmalloc\n'ed by the function detecting the error is \nfree\n'ed and any temporary file created by the function detecting the error is removed.\n\n\nCS_fast FAST mode\n\n\nSub CS_fast(ByVal fast As Integer)\nprocedure CS_fast(fast: Integer);\nvoid CS_fast(int fast);\n\n\n\n\nCS_fast\n can be used to improve the performance of applications using the High Level Interface. When incorporated into a DLL, the High Level Interface normally verifies the veracity of each pointer argument provided by the application. This is convenient, of course, but also somewhat time consuming. Calling \nCS_fast\n with a non-zero value for the fast argument will disable this checking. It is recommended that calling \nCS_fast\n be added to your application only after it has been debugged. Fast mode can be turned off by calling \nCS_fast\n with\nargument fast set to zero.\n\n\nCS_ftoa floating point TO Ascii\n\n\nFunction CS_ftoa(ByVal buffer As String, ByVal size As Integer, ByVal value As Double, ByVal format As Long) As Long\nfunction CS_ftoa buffer: Pchar; size: Integer; value: Double; format: Longint) :Longint;\nlong CS_ftoa(char *buffer, int size, double value, long format);\n\n\n\n\nCS_ftoa\n formats the double precision floating point value provided by the \nvalue\n argument into ASCII form returning the result in the character array pointed to by the \nbuffer\n argument. The result is always a null terminated string, and the length of the string is never longer than \nsize\n - 1 characters. The format of the character string is controlled by the \nformat\n argument. \nCS_ftoa\n returns a long that indicates the actual format used to format the value. The returned format specification may be different from the requested format if the buffer provided was not large enough, or if the requested format is not appropriate for the value provided.\n\n\nCS_ftoa\n is intended to be a generalized formatting function that accommodates the formats commonly used in mapping. That is, large numbers and values in degrees minutes and seconds form. The somewhat awkward \nformat\n argument is designed such that the value returned by \nCS_atof\n is suitable for use by \nCS_ftoa\n.\n\n\nThe original intent behind the design of the format specification was to enable users to indicate the desired format of output by simply entering a suitable value in the form they desire. The application would then use \nCS_atof\n to convert the value to binary form. If no errors occurred during the conversion, the returned long could then be used to format output. Experience will determine the success of this approach.\n\n\nThe \nformat\n argument is a bitmap of information used to contain precision, formatting specifications, and error status values. The following descriptions refer to constants defined in the various header files. Construct a format specification by inclusively or'ing the desired options.\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_ATOF_PRCMSK\n\n\nThe least significant five bits are used to indicate the number of digits to be produced after the decimal point. The value is actually the number of desired digits plus one. Zero indicates that the precision is to be calculated automatically. This constant is a mask that will mask out the precision value.\n\n\n\n\n\n\ncs_ATOF_MINSEC\n\n\nOutput is to be in degrees, minutes, and seconds form.\n\n\n\n\n\n\ncs_ATOF_MINUTE\n\n\nOutput is to be in degrees and minutes form.\n\n\n\n\n\n\ncs_ATOF_EXPNT\n\n\nThis bit is set in the returned value if \nCS_ftoa\n had to resort to scientific notation in order to format the value in the space provided.\n\n\n\n\n\n\ncs_ATOF_OVRFLW\n\n\nThis bit is set in the returned value if \nCS_ftoa\n could only output the overflow indication (i.e. \n.\n) in the space provided.\n\n\n\n\n\n\ncs_ATOF_COMMA\n\n\nOutput is to include thousands separators to the left of the decimal point as appropriate.\n\n\n\n\n\n\ncs_ATOF_DIRCHR\n\n\nOutput is to include directional characters to indicate the sign of the numbers rather than plus or minus signs.\n\n\n\n\n\n\ncs_ATOF_XEAST\n\n\nMeaningful only when the \ncs_ATOF_DIRCHR\n bit is set. Indicates that character set used to indicate positive or negative are E and W as opposed to N and S.\n\n\n\n\n\n\ncs_ATOF_MINSEC0\n\n\nOutput is to include leading zeros in the minutes and seconds fields instead of leading spaces.\n\n\n\n\n\n\ncs_ATOF_DEG0\n\n\nOutput is to include leading zeros in the degrees field rather than spaces.\n\n\n\n\n\n\ncs_ATOF_0BLNK\n\n\nOutput a null string if the provided value is zero.\n\n\n\n\n\n\ncs_ATOF_FORCE3\n\n\nUsed to force at least three character output in the degree field. Usually used when formatting a longitude.\n\n\n\n\n\n\ncs_ATOF_RATIO\n\n\nOutput the result in a ratio format, e.g. 1:2500. Can be used in conjunction with \ncs_ATOF_COMMA\n to get something like 1:2,500.\n\n\n\n\n\n\n\n\nCS_geoctrSetUp Geocentric setup\n\n\nFunction CS_geoctrSetUp (ByVal ellipsoid As String) As Integer\nfunction CS_geoctrSetUp (ellipsoid: PChar): Integer;\nint CS_geoctrSetUp (const char *ellipsoid);\n\n\n\n\nUse this function to specify the ellipsoid definition that is to be used in geocentric coordinate calculations. The ellipsoid argument must be the key name of an \nellipsoid\n defined in the ellipsoid dictionary. Zero is returned on success, -1 on error. Errors are usually caused by invalid ellipsoid names.\n\n\nCS_geoctrGetXyz Geocentric get XYZ\n\n\nFunction CS_geoctrGetXyz (ByRef xyz As Double, ByRef llh As Double) As Integer\nfunction CS_geoctrGetXyz (var xyz, llh: Double): Integer;\nint CS_geoctrGetXyz (double xyz[3], double llh[3]);\n\n\n\n\nGiven the geographic coordinates of a point via the \nllh\n argument, \nCS_geoctrGetXyz\n returns the corresponding geographic coordinate in the array indicated by the \nxyz\n argument. Use the \nCS_geoctrSetUp\n to specify the ellipsoid that is to be used in the calculation. Note that the returned geocentric coordinates will be in meters, and the third element of the \nllh\n argument is considered to be the ellipsoidal height in meters. \nCS_geoctrGetXyz\n returns zero on success and \u20131 on failure. Failure can be caused by failing to specify an ellipsoid by calling \nCS_geoctrSetUp\n, or providing a bogus set of geographic coordinates.\n\n\nCS_geoctrGetLlh Geocentric get LatLongHgt\n\n\nFunction CS_geoctrGetLlh (ByRef llh As Double, ByRef xyz As Double) As Integer\nfunction CS_geoctrGetLlh (var llh, xyz :Double): Integer;\nint CS_geoctrGetLlh (double llh[3], double xyz[3]);\n\n\n\n\nGiven the geocentric coordinates of a point via the \nxyz\n argument, \nCS_geoctrGetLlh\n returns the corresponding geographic coordinate in the array indicated by the \nllh\n argument. Use the \nCS_geoctrSetUp\n to specify the ellipsoid that is to be used in the calculation. Note that the geocentric coordinates must be in meters, and the height (i.e. the third element of the \nllh\n result) is the ellipsoidal height in meters. \nCS_geoctrGetLlh\n returns zero on success and \u20131 on failure. Failure can be caused by failing to specify an ellipsoid by calling \nCS_geoctrSetUp\n, or providing a bogus set of geocentric coordinates.\n\n\nCS_getCountyFips Get County Federal Information Processing Standard code\n\n\nFunction CS_getCountyFips ( ByVal stateFips As Integer , ByVal count yName As String) As Integer\nfunction CS_getDataDirectory (stateFips :Integer; countyName :PChar) : Integer;\nint CS_getCountyFips ( int stateFips, Const char * count yName);\n\n\n\n\nThis function returns the Federal Information Processing Standard code value assigned to a county indicated by the \ncountyName\n argument. This is appropriate for the US only. You can obtain the appropriate value for the \nstateFips\n argument by using \nCS_getStateFips\n. Note, that countyName must be the complete official name of the county without any punctuation. The lookup procedure is NOT case sensitive. The function returns zero if the information provided by the two arguments fails to produce a county code.\n\n\nCS_getDataDirectory GET DATA DIRECTORY\n\n\nFunction CS_getDataDirectory (ByVal data_dir As String, ByVal dir_sz As Integer) As Integer\nfunction CS_getDataDirectory (data_dir: PChar; dir_sz: Integer): Integer;\nint CS_getDataDirectory (char *data_dir, int dir_sz);\n\n\n\n\nCS_getDataDirectory\n will return in the character array pointed to by the \ndata_dir\n argument the full path to the directory it is searching for supporting data file. It will always return a null terminated string, but never write more than \ndir_sz\n characters to the array. \nCS_getDataDirectory\n will return \nTRUE\n if the directory returned does indeed contain a Coordinate System Dictionary file (i.e. a file named COORDSYS).\n\n\nCS_getDatumOf Get Datum of a Coordinate System\n\n\nFunction CS_getDatumOf ( ByVal csKeyName As String, ByVal datumName As String, ByVal size As Integer) As Integer\nfunction CS_getDatumOf (csKeyName, datumName: PChar; size: Integer) : Integer;\nint CS_get DatumOf ( Const char * csKeyName, char * datumName, int size);\n\n\n\n\nUse this function to obtain the key name of the datum assigned to the coordinate system whose key name is provided by the \ncsKeyName\n argument. The datum key name is returned in the string pointed to by the \ndatumName\n argument. \nCS_getDatumOf\n will never write more than size characters to the \ndatumName\n string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. The string at \ndatumName\n will be the empty string if the coordinate system referred to is cartographically referenced (i.e. referenced directly to an ellipsoid).\n\n\nCS_getDescriptionOf Get Description of a Coordinate System\n\n\nFunction CS_getDescriptionOf ( ByVal csKeyName As String, ByVal description As String,\nByVal size As Integer) As Integer\nfunction CS_getDescriptonOf (csKeyName, description :PChar; size :Integer) : Integer;\nint CS_getDescriptionOf (Const char *csKeyName, char *description, int size);\n\n\n\n\nUse this function to obtain the description the coordinate system whose key name is provided by the \ncsKeyName\n argument. The description is returned in the string pointed to by the description argument. \nCS_get DescriptionOf\n will never write more than \nsize\n characters to the \ndatumName\n string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. Note that description field of a coordinate system definition is limited to 63 characters, and \nsize\n is typically 64 (to accommodate for the null terminating character used in C).\n\n\nCS_getEllipsoidOf Get Ellipsoid Of a Coordinate System\n\n\nFunction CS_getEllipsoidOf ( ByVal csKeyName As String, ByVal ellipsoidName As String, ByVal size As Integer) As Integer\nfunction CS_getEllipsoidOf (csKeyName, ellipsoidName: PChar; size :Integer) :Integer;\nint CS_getEllipsoidOf (Const char *csKeyName, char *ellipsoidName, int size);\n\n\n\n\nUse this function to obtain the ellipsoid referenced by the coordinate system whose key name is provided by the \ncsKeyName\n argument. The ellipsoid key name is returned in the string pointed to by the \nellipsoidName\n argument. \nCS_getEllipsoidOf\n will never write more than size characters to the \nellipsoidName\n string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. Note that key names are limited to 23 characters, and \nsize\n is typically 24 (to accommodate for the null terminating character used in\n\n\nThis function usually returns the empty string as most coordinate systems are referenced to a datum rather than an ellipsoid. Use this function only in those cases where the \nCS_getDatumOf\n function returns the empty string, indicating a coordinate system which is cartographically referenced.\n\n\nCS_getReferenceOf Get Reference Of a Coordinate System\n\n\nFunction CS_getReferenceOf ( ByVal csKeyName As String, ByVal reference As String, ByVal size As Integer) As Integer\nfunction CS_getReferenceOf ( csKeyName, reference : PChar; size :Integer) :Integer;\nint CS_getReferenceOf (Const char *csKeyName, char *reference, int size);\n\n\n\n\nUse this function to obtain an ASCII representation of what the coordinate system referenced by the \ncsKeyName\n argument is referenced to. This operates correctly for both geodetic and cartographic references. The returned ASCII string will include an indication of the type of reference, and also the keyname involved. The reference description is returned in the string pointed to by the \nreference\n argument. CS_getRefernceOf will never write more than \nsize\n characters to the \nreference\n string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. 32 is a customary value for the \nsize\n argument. A geodetic reference looks something like: \nDatum: WGS84\n.\n\n\nCS_getSourceOf Get Source Of Coordinate System\n\n\nFunction CS_getSourceOf ( ByVal csKeyName As String, ByVal source As String, ByVal size As Integer) As Integer\nfunction CS_getSourceOf (csKeyName, source: PChar; size: Integer): Integer;\nint CS_getSourceOf (Const char *csKeyName,char *source,int size);\n\n\n\n\nUse this function to obtain the source of information field of the coordinate system definition whose key name is provided by the \ncsKeyName\n argument. The source information is returned in the string pointed to by the source argument. \nCS_getSourceOf\n will never write more than \nsize\n characters to the \nsource\n string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. Note that source of information field of a coordinate system definition is limited to 63 characters, and \nsize\n is typically 64 (to accommodate for the null terminating character used in C).\n\n\nCS_getUnitsOf Get Units of a Coordinate System\n\n\nFunction CS_getUnitsOf (ByVal csKeyName As String,ByVal units As String, ByVal size As Integer) As Integer\nfunction CS_getUnitsOf (csKeyName, units: PChar; size: Integer) :Integer;\nint CS_getUnitsOf (Const char *csKeyName, char *units, int size);\n\n\n\n\nUse this function to obtain the key name of the units of the coordinate system definition whose key name is provided by the \ncsKeyName\n argument. The unit key name is returned in the string pointed to by the \nunits\n argument. \nCS_ge UnitsOf\n will never write more than \nsize\n characters to the \nunits\n string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. Note that unit key name field of a coordinate system definition is limited to 23 characters, and \nsize\n is typically 24 (to accommodate for the null terminating character used in C).\n\n\nCS_getElValues Get Ellipsoid Values\n\n\nFunction CS_getElValues ( ByVal elKeyName As String, ByRef eRadius As Double, ByRef eSquared As Double) As Integer\nfunction CS_getElVal ues ( elKeyName: PChar ; var eRadius, eSquared : Double) : Integer;\nint CS_getElValues ( Const char * el KeyName, double * eRadius, double * eSquared ;\n\n\n\n\nUse this function to obtain the equatorial radius and the eccentricity squared values for the ellipsoid referenced by \nelKeyName\n argument. The appropriate values are returned in the double variables pointed to by the \neRadius\n and \neSquared\n arguments.. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid ellipsoid key name. Note that the value returned in \neRadius\n is the equatorial radius and is always in meters. The value returned in the \neSquared\n variable is unit less, and will be zero if the ellipsoid definition referenced by the \nelKeyName\n argument is actually the definition of a sphere.\n\n\nCS_getCurvatureAt get curvature at specified latitude\n\n\nFunction CS_getCurvatureAt ( ByVal csKeyName As String, ByVal latitude As Double) As Double\nfunction CS_getCurvatureAt (csKeyName, source: PChar; latitude: double) : Double;\ndouble CS_getCurvatureAt ( Const char * csKeyName, double latitude);\n\n\n\n\nThis function uses the ellipsoid underlying the coordinate system definition indicated by the \ncsKeyName\n argument, and computes the Gaussian curvature at the specified \nlatitude\n. The key name argument must be that of a coordinate system definition, and the latitude argument is specified in degrees.\n\n\nThe function returns a hard zero in the event of an error, which can be caused by providing an invalid coordinate system key name. The latitude argument is not checked and used as is, since only the sine of the latitude is necessary for the calculation (and all real values have, technically, a sine value).\n\n\nCS_isgeo is geographic\n\n\nFunction CS_isgeo (ByVal key_nmAs String) As Integer\nfunction CS_isgeo (key_nm: PChar): Integer;\nint * CS_isgeo (Const char * key_nm);\n\n\n\n\nCS_isgeo\n will check the coordinate system definition with the key name indicated by the \nkey_nm\n argument and return +1 (i.e. TRUE) if the coordinate system does return geographic coordinates. A zero is returned if the named coordinate system is not geographic.\n\nCS_isgeo\n returns a negative value in the event of a hard error. The most frequent cause of a hard error is providing an invalid coordinate system name.\n\n\nCS_llazdd Lat/Long to Azimuth and Distance calculator\n\n\n\nFunction CS_llazdd(ByVal e_rad As Double, ByVal e_sq As Double, ByRef ll_from As Double, ByRef ll_to As Double, ByRef dist As Double) As Double\nfunction CS_llazdd(e_rad, e_sq: Double; var ll_from, ll_to: Double; var dist: Double): Double;\ndouble CS_llazdd (double e_rad, double e_sq, Const double ll_from[2], Const double ll_to [2], double *dist);\n\n\n\n\nCS_llazdd\n returns the ellipsoidal azimuth and distance between two points on the surface of an ellipsoid specified in terms of latitude and longitude. \ne_rad\n specifies the equatorial radius and \ne_sq\n specifies the square of the eccentricity of the ellipsoid. The returned azimuth is calculated from the location specified by \nll_from\n to that specified by \nll_to\n, and the distance between the two points is returned at the location pointed to by \ndist\n. The units of the returned distance are the same as those used to specify the equatorial radius.\n\n\nLatitude and longitude values are in degrees where the first element in each array is the longitude and the second element is the latitude. West longitude and south latitude are negative.\n\n\nThe algorithm used is known as: \"Solution of the geodetic inverse problem after T. Vincenty modified Rainsford's Method with Helmert's elliptical terms.\"\n\n\nERRORS\n\n\nCS_llazdd\n makes no checks for possible errors. The algorithm used is appropriate for any combination of points that are not antipodal. That is, the points used must not be exactly opposite each other, i.e. on the endpoints of a straight line that passes through the center of the earth.\n\n\nCS_llFromMgrs calculate Lat/Long from MGRS\n\n\nFunction CS_mgrsFromLl(ByRef latLng As Double, ByVal mgrs As String) As Integer\nfunction CS_mgrsFromLl(var latLng: Double; mgrs: PChar) :Integer;\ndouble CS_mgrsFromLl (double latLng[2], const char *mgrs);\n\n\n\n\nCS_llFromMgrs\n returns in the array indicated by the \nlatLng\n argument the geographic coordinate equivalent of the MGRS (Military Grid Reference System) string provided by the \nmgrs\n argument. This function is aware of the poles and the rather strange stuff that happens in the northern Europe.\n\n\nCS_llFromMgrs\n returns a zero for success, and \u20131 for failure. Failure can be caused by failing to call the \nCS_mgrsSetUp\n prior to calling \nCS_llFromMgrs\n or providing an invalid MGRS string.\n\n\nCS_mgrsFromLl calculate MGRS from Lat/Long\n\n\nFunction CS_mgrsFromLl(ByVal mgrs As String, ByRef latLng As Double, ByVal precision As Integer) As Integer\nfunction CS_mgrsFromLl(mgrs :PChar; var latLng :Double; precision :Integer) : Integer;\ndouble CS_mgrsFromLl (char *mgrs, double latLng [2], int precision);\n\n\n\n\nCS_mgrsFromLl\n returns the MGRS (Military Grid Reference System) equivalent of the geographic position provided by the \nlatLng\n argument in the character array (string) indicated by the \nmgrs\n argument. The \nprecision\n of the result is controlled by the precision argument that must have a value between 1 and 5 (inclusive). The result array is assumed to be at least 16 bytes in length. The \nlatLng\n argument must adhere to the convention established for internal coordinates. This function is aware of the poles and the rather strange stuff that happens in the northern Europe.\n\n\nCS_mgrsFromLl\n returns a zero for success, and \u20131 for failure. Failure can be caused by failing to call the \nCS_mgrsSetUp\n prior to calling \nCS_mgrsFromLl\n or providing an invalid geographic coordinate.\n\n\nCS_mgrsSetUp MGRS setup\n\n\nFunction CS_mgrsSetUp (ByVal ellipsoid As String, ByVal bessel As Integer) As Integer\nfunction CS_mgrsSetUp (ellipsoid: PChar; bessel: Integer): Integer;\ndouble CS_mgrsSetUp (const char* ellipsoid, int bessel);\n\n\n\n\nUse the \nCS_mgrsSetUp\n to specify the ellipsoid that is to be used in the MGRS (Military Grid Reference System) calculations. Use the \nellipsoid\n argument to provide the key name of the ellipsoid definition that is to be used. There are two alphabetic code sequences used with MGSR. A zero value for the \nbessel\n argument causes the normal code sequence to be used, a value of +1 indicates that the code sequence associated with the Bessel ellipsoid is to be used.\n\n\nCS_mgrsFromLl\n returns a zero for success, and \u20131 for failure. Failure is usually caused by a invalid ellipsoid name.\n\n\nCS_recvr recover resources\n\n\nSub CS_recvr\nprocedure CS_recvr;\nvoid CS_rcvr (void);\n\n\n\n\nCS_rcvr\n will release all system resources allocated by use of the single function user interface functions \nCS_cnvrt\n, \nCS_cnvrg\n, and \nCS_scale\n. It essentially frees up the coordinate system cache and the datum conversion cache established by these functions to enhance performance.\n\n\nCS_scale grid SCALE factor function\n\n\nFunction CS_scale (ByVal cs_name As String, ByRef ll As Double) As Double\nfunction CS_scale (cs_name: PChar; var ll :Double): Double;\ndouble CS_scale (Const char *cs_name, double ll[2]);\n\n\n\n\nCS_scale\n returns the grid scale factor of the coordinate system whose key name is provided by the \ncs_name\n argument, at the location provided by the \nll\n argument. The position provided by the \nll\n argument \nmust\n be in longitude and latitude form, in degrees, where the first element of the array is the longitude and the second element of the array is the latitude. Use negative values for west longitude and south latitude. The returned value is the grid scale factor.\n\n\nCS_scale\n uses the same cache of coordinate system definitions as does \nCS_cnvrt\n, therefore, the performance penalty of using this very simple function is not as great as one might expect.\n\n\nIn the case of a conformal projection, the K and H scale factors are the same; there is no ambiguity. For non-conformal projections, however, the K and H functions are not the same. In these cases, this function will return the more interesting of the two factors. For example, for the Equidistant Conic, the K factor is always 1.0, and this function would return the H factor for this projection.\n\n\nERRORS\n\n\nCS_scale\n will return a negative one (i.e. -1.0) if an error occurs. Providing an invalid coordinate system name is the most common source of error.\n\n\nC## S_scalh grid scale factor(H) function\n\n\nFunction CS_scalh (ByVal cs_name As String, ByRef ll As Double) As Double\nfunction CS_scalh (cs_name: PChar; var ll: Double) :Double;\ndouble CS_scalh (Const char *cs_name, double ll[2]);\n\n\n\n\nCS_scalh\n returns the grid scale factor along a meridian of the coordinate system whose key name is provided by the \ncs_name\n argument, at the location provided by the \nll\n argument. The position provided by the \nll\n argument \nmust\n be in longitude and latitude form, in degrees, where the first element of the array is the longitude and the second element of the array is the latitude. Use negative values for west longitude and south latitude. The returned value is the grid scale factor.\n\n\nCS_scalh\n uses the same cache of coordinate system definitions as does \nCS_cnvrt\n, therefore, the performance penalty of using this very simple function is not as great as one might expect.\n\n\nERRORS\n\n\nCS_scalh\n will return a negative one (i.e. -1.0) if an error occurs. Providing an invalid coordinate system name is the most common source of error.\n\n\nCS_scalk grid SCALE factor(K) function\n\n\nFunction CS_scalk (ByVal cs_name As String, ByRef ll As Double) As Double\nfunction CS_scalk (cs_name: PChar; var ll: Double): Double;\ndouble CS_scalk (Const char *cs_name, double ll[2]);\n\n\n\n\nCS_scalk\n returns the grid scale factor along a parallel of the coordinate system whose key name is provided by the \ncs_name\n argument, at the location provided by the \nll\n argument. The position provided by the \nll\n argument \nmust\n be in longitude and latitude form, in degrees, where the first element of the array is the longitude and the second element of the array is the latitude. Use negative values for west longitude and south latitude. The returned value is the grid scale factor.\n\n\nCS_scalk\n uses the same cache of coordinate system definitions as does \nCS_cnvrt\n, therefore, the performance penalty of using this very simple function is not as great as one might expect.\n\n\nERRORS\n\n\nCS_scalk\n will return a negative one (i.e. -1.0) if an error occurs. Providing an invalid coordinate system name is the most common source of error.\n\n\nCS_setHelpPath SET HELP PATH\n\n\nFunction CS_setHelpPath (ByVal helpPath As String) As Integer\nfunction CS_setHelpPath (helpPath: PChar): Integer;\nint CS_setHelpPath (const char *helpPath);\n\n\n\n\nUse the \nCS_setHelpPath\n function to set the directory that you desire to have CS-MAP search when seeking the MFC dialog help file. The \nhelpPath\n argument must point to a null terminated string that carries the full path to the desired directory.\n\n\nCS_setHelpPath\n returns +1 (i.e. TRUE) if a properly named file exists in the indicated directory. Zero (i.e. FALSE) is returned if such a file does not exist.\n\n\nCS_spZoneNbrMap State Plane Zone Number Mapper\n\n\nFunction CS_spzone (ByValue csKeyName As String,ByVal is83 As Integer) As Integer\nfunction CS_spzone (csKeyName: PChar; is83: Integer): Integer\nint CS_spzone (char *csKeyName, int is83);\n\n\n\n\nCS_spZoneNbrMap\n examines the character array provided by the \ncsKeyName\n argument and if it determines that the array contains a valid state plane zone number specification, the contents of the array is replaced with the appropriate corresponding coordinate system key name. If the \nis83\n parameter is non-zero, the zone number is interpreted as a NAD83 zone number. Otherwise, the zone number is interpreted as a NAD27 zone number.\n\n\nIf the original content of the character array pointed to be the \ncsKeyName\n argument is not a valid state plane zone number, the contents of the array remains unchanged.\n\n\nCS_spZoneNbrMap\n returns 0 if a substitution was made. A positive one is returned if a substitution was not made because the value passed was not considered to be a valid state plane zone number. Minus one is returned if the original passed value is close to a state plane zone number (i.e. consisted of three or four digits), but did not match a valid state plane zone number.\n\n\nCS_unEnum Units Enumerator\n\n\nFunction CS_unEnum(ByVal ByVal ByVal index As Integer,ByVal type As Integer, key_name As String, name_sz As Integer) As Integer\nfunction CS_unEnum(index, type: Integer; key_name: Pchar; name_sz: Integer): Integer;\nint CS_unEnum(int index, int type, char *key_name, int nm_size);\n\n\n\n\nCS_unEnum\n is used to enumerate all units of a specific type in the CS-MAP units table. \nCS_unEnum\n returns in the memory buffer pointer to by the \nkey_name\n argument the name of the \nindex\n'th entry in the unit table of the type specified by the type argument. \nCS_unEnum\n will never write more than \nnm_size\n bytes to the indicated location. Index is a zero based index; the index of the first entry in the unit table is zero.\n\n\nCurrently, only two types of units supported, length and angular measure. Manifest constants defined in the \ncs_map.h\n header file are used to distinguish the desired type. These are \ncs_UTYP_LEN\n, for linear units, and \ncs_UTYP_ANG\n, for angular units. The \ntype\n argument must be one of these values.\n\n\nCS_unEnum\n returns a positive 1 to indicate success. If \nindex\n is too large, a zero is returned.\n\n\nErrors\n\n\nCS_unEnum\n will return a -1 and set \ncsError\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_INV_INDX\n\n\nThe index argument was negative.\n\n\n\n\n\n\n\n\nBUGS\n\n\nIf called with an invalid type, \nCS_unEnum\n should probably return an error condition, but it doesn't. Calling \nCS_unEnum\n with an invalid type causes a return value of zero for all positive values of the \nindex\n argument.\n\n\nCS_unitlu unit look up\n\n\nFunction CS_unitlu (ByVal type As Integer, ByVal unit_nmAs String) As Double\nfunction CS_unitlu (type: Integer; unit_nm: PChar): Double;\ndouble CS_unitlu (short type, Const char *unit_nm);\n\n\n\n\nGiven the type of measurement, either length or angular, as specified by the \ntype\n argument and the unit name as specified by the \nunit_nm\n argument, \nCS_unitlu\n will return a double which represents the multiplier required to convert a value in the unit system indicated by \nunit_nm\n to units of meters or degrees.\n\n\nCurrently, only two types of units supported, length and angular measure. Manifest constants defined in the \ncs_map.h\n header file are used to distinguish the desired type. These are \ncs_UTYP_LEN\n and \ncs_UTYP_ANG\n. The \ntype\n argument must be one of these values.\n\n\nunit_nm\n must be a null terminated string matching one of the supported units as defined in \nCSdataU\n. \nCS_unitlu\n returns zero in the event the provided unit name is not known. \nunit_nm\n may be one of the supported abbreviations for any of the units defined in the unit table.\n\n\nFor example, to convert a value in feet to meters, one could code:\n\n\ndouble CS_unitlu(); {\n  meters = feet * CS_unitlu(cs_UTYP_LEN, \nFOOT\n);\n}\n\n\n\n\nOr to convert degrees to grads:\n\n\ndouble CS_unitlu (); {\n  grads = degrees / CS_unitlu (cs_UTYP_ANG, \nGRAD\n);\n}\n\n\n\n\nCS_unitlu\n knows about the first and second abbreviations provided for in the \ncs_Unittab_\n structure.\nTherefore, the following are equivalent to the above:\n\n\ndouble CS_unitlu(); {\n  meters = feet * CS_unitlu (cs_UTYP_LEN,\nFT\n);\n}\n\ndouble CS_unitlu(); {\n  grads = degrees / CS_unitlu (cs_UTYP_ANG,\nGR\n);\n}\n\n\n\n\nERRORS\n\n\nCS_unitlu\n will return zero and set \ncs_Error\n to \ncs_INV_UNIT\n if the unit name pointed to by \nunit_nm\n is not defined in \ncs_Unittab\n for the specified type, or the specified type is not valid.\n\n\nHigh Performance Interface\n\n\nFunctions which are considered part of the High Performance Interface are described in this section. Several of these functions return addresses (i.e. pointers to) malloc'ed memory, and therefore these functions are not suitable for all languages. Function prototype definitions are given in the C syntax only.\n\n\nCS_audflt Angular unit default\n\n\nchar *CS_audlt (Const char *new_dflt);\n\n\n\n\nUse \nCS_audflt\n to control the status of the \"defaultable\" angular unit reference feature of CS-MAP. new_dflt must be either a pointer to a valid angular unit name, a pointer to the null string, or the \nNULL\n pointer. In the case where \nnew_dflt\n is a pointer to a valid angular unit name, \nCS_audflt\n causes the default angular unit feature to be activated, using the angular unit name provided as the, possibly new, default value. When \nnew_dflt\n is a pointer to the null string, \nCS_audflt\n disables the default angular unit feature. When \nnew_dflt\n is the \nNULL\n pointer, the status of the angular unit default feature remains unchanged.\n\n\nIn all cases, \nCS_audflt\n returns the previous status (or in the case of \nnew_dflt == NULL\n, the current status) in the form of a pointer to a static character array that contains the name of the previous default angular unit. Should the returned pointer point to a null string, the indicated previous status is disabled.\n\n\nERRORS\n\n\nCS_audflt\n will return the \nNULL\n pointer if the key name provided is not that of a valid angular unit. In this event, the current status of the default angular unit feature remains unchanged.\n\n\nCS_cs2ll Coordinate System to Latitude/Longitude\n\n\nvoid CS_cs2ll(Const struct cs_Csprm_ *csprm,double ll[2], Const double xy[2]);\n\n\n\n\nGiven the definition of the coordinate system, \ncsprm\n, such as returned by \nCS_csloc\n, \nCS_cs2ll\n will convert the coordinates \nxy\n to latitude and longitude, returning the results in \nll\n. The \nll\n and \nxy\n arguments may point to the same array.\n\n\nIn the array arguments, the X coordinate and the longitude occupy the first element, the Y coordinate and the latitude the second element. West longitudes and south latitudes are negative. The returned values are in degrees.\n\n\nCS_cscnv Coordinate System Convergence\n\n\ndouble CS_cscnv(Const struct cs_Csprm_ *csprm, Const double ll[2]);\n\n\n\n\nGiven the definition of the coordinate system, \ncsprm\n, such as returned by \nCS_csloc\n, \nCS_cscnv\n will return the convergence angle in degrees east of north at the location given by \nll\n.\n\n\nThe location, as given by \nll\n is in terms of latitude and longitude. The longitude is the first element of the \nll\n array, latitude is the second, and both must be given in degrees. Positive values are used to specify north latitude and east longitude, negative values are used to specify south latitude and west longitude.\n\n\nCS_csdef Coordinate System definition locator\n\n\nstruct cs_Csdef_ * CS_csdef (Const char* key_nm);\n\n\n\n\nCS_csdef\n will return a pointer to a \nmalloc\n'ed \ncs_Csdef_\n structure that contains the definition of the coordinate system indicated by \nkey_nm\n. \nKey_nm\n must point to an array that contains the null terminated key name of the desired coordinate system. The memory allocated for the coordinate system definition may be released by calling \nCS_free\n when no longer needed.\n\n\nERRORS\n\n\nCS_csdef\n will return a \nNULL\n pointer and set \ncs_Error\n if any of the following conditions are detected:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_CSDICT\n\n\nThe Coordinate System Dictionary file could not be found or otherwise opened. (See \nCS_altdr\n).\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred during access to the Coordinate System Dictionary file.\n\n\n\n\n\n\ncs_CS_BAD_MAGIC\n\n\nThe file accessed under the assumption that it was a Coordinate System Dictionary wasn't a Coordinate System Dictionary after all; it had an invalid magic number on the front end.\n\n\n\n\n\n\ncs_CS_NOT_FND\n\n\nA coordinate system definition with the name given by key_nm was not found in the Coordinate System Dictionary.\n\n\n\n\n\n\ncs_NO_MEM\n\n\nInsufficient dynamic memory was available to allocate space for the \ncs_Csdef_\n structure.\n\n\n\n\n\n\n\n\nCS_csdel Coordinate System definition delete\n\n\nint CS_csdel(struct cs_Csdef_ *csdef);\n\n\n\n\nCS_csdel\n will delete from the Coordinate System Dictionary the definition of the coordinate system pointed to by \ncsdef\n.\n\n\nThe delete is accomplished by creating a new Coordinate System Dictionary file and copying all but the referenced coordinate system definitions from the existing dictionary to the new one. This implies that sufficient disk space must exist to perform the copy. A zero is returned if the delete was successfully completed, a -1 if a problem occurred. An attempt to delete a non-existent coordinate system definition is \nNOT\n considered an error.\n\n\nIf the value of the global variable \ncs_Protect\n is greater than or equal to zero, \nCS_csdel\n will not delete a coordinate system which is marked as being a distribution coordinate system (i.e. \ncs_Csdef_.protect == 1\n). If the value of \ncs_Protect\n is greater than zero, it is interpreted as the number of days after which a user defined coordinate system is protected. For example, is\n\ncs_Protect\n is 60, a user-defined coordinate system becomes protected 60 days after it is last modified.\n\n\nERRORS\n\n\nCS_csdel\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_CSDICT\n\n\nThe Coordinate System Dictionary could not be found or otherwise opened. (See \nCS_altdr\n)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in copying the Coordinate System Dictionary to the new file.\n\n\n\n\n\n\ncs_CS_BAD_MAGIC\n\n\nThe file assumed to be the Coordinate System Dictionary by virtue of its name was not a Coordinate System Dictionary; it had an invalid magic number.\n\n\n\n\n\n\ncs_TMP_CRT\n\n\nThe attempt to create a new file, to which the modified Coordinate System Dictionary was to be copied, failed.\n\n\n\n\n\n\ncs_DISK_FULL\n\n\nInsufficient disk space was available to accommodate the copying of the Coordinate System Dictionary to the new file.\n\n\n\n\n\n\ncs_UNLINK\n\n\nThe request to remove the old copy of the Coordinate System Dictionary failed.\n\n\n\n\n\n\ncs_RENAME\n\n\nThe request to rename the new Coordinate System Dictionary file from its temporary name to COORDSYS failed.\n\n\n\n\n\n\ncs_CS_PROT\n\n\nThe coordinate system to be deleted is a distribution coordinate system and may not be deleted.\n\n\n\n\n\n\ncs_CS_UPROT\n\n\nThe coordinate system is a user defined coordinate system that has not been modified for 60 days and is therefore protected.\n\n\n\n\n\n\n\n\nCS_csEnumByGroup Coordinate System Enumerator By Group\n\n\nint CS_csEnumByGroup (int index, Const char * grp_name, struct cs_Csgrplst_ * cs_descr);\n\n\n\n\nCS_csEnumByGroup\n is used to enumerate a specific group of coordinate systems in the Coordinate System Dictionary. \nCS_csEnumByGroup\n returns a completed \ncs_Csgrplst_\n structure at the location given by the \ncs_descr\n argument containing information that describes the \nindex\n'th entry in the coordinate system group named by the \ngrp_name\n argument. \nIndex\n is a zero based index; the index of the first coordinate system in any group is zero. The next element of the returned \ncs_Csgrplst_\n structure is always set to the NULL pointer.\n\n\nCS_csEnumByGroup\n returns a positive 1 to indicate success. If \nindex\n is too large, a zero is returned.\n\n\nERRORS\n\n\nCS_csEnumByGroup\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_CSDICT\n\n\nThe Coordinate System Dictionary could not be found or otherwise opened. (See \nCS_altdr\n)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in accessing the Coordinate System Dictionary.\n\n\n\n\n\n\ncs_CS_BAD_MAGIC\n\n\nThe file assumed to be the Coordinate System Dictionary by virtue of its name was not a Coordinate System Dictionary; it had an invalid magic number.\n\n\n\n\n\n\ncs_CSGRP_INVKEY\n\n\nThe \ngrp_name\n argument was not that of a valid group name.\n\n\n\n\n\n\ncs_INV_INDX\n\n\nThe index argument was negative.\n\n\n\n\n\n\n\n\nCS_csGrpEnum Coordinate System grour enumerator\n\n\nint CS_csGrpEnum(int index, char *grp_name, int name_sz, char *grp_dscr, int dscr_sz);\n\n\n\n\nCS_csGrpEnum\n is used to enumerate all groups in the Coordinate System Group table. \nCS_csGrpEnum\n returns in the memory buffer pointer to by the \ngrp_name\n argument the key name of the \nindex\n'th entry in the Coordinate System Group Table. \nCS_csGrpEnum\n will never write more than \nname_sz\n bytes to the indicated location. Similarly, \nCS_csGrpEnum\n returns the Coordinate System Group description in the buffer pointed to be \ngrp_dscr\n and whose size in indicated by \ndscr_sz\n. The \ngrp_name\n and/or the \ngrp_dscr\n arguments may be the \nNULL\n pointer to suppress return of the indicated item.\n\n\nIndex\n is a zero based index; the index of the first entry in the Coordinate System Group Table is zero. \nCS_dtEnum\n returns a positive 1 to indicate success. If \nindex\n is too large, a zero is returned. Inactive groups (a feature planned for a future release) are ignored, and are not considered to exist as far as \nindex\n is concerned.\n\n\nERRORS\n\n\nCS_csGrpEnum\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_INV_INDX\n\n\nThe index argument was negative.\n\n\n\n\n\n\n\n\nCS_csloc Coordinate System locate and initialize\n\n\nstruct cs_Csprm_ *CS_csloc(Const char *cs_nam);\nstruct cs_Csprm_ *Cscsloc1(Const struct cs_Csdef_ *cs_ptr);\nstruct cs_Csprm_ *Cscsloc2(Const struct cs_Csdef_ *csPtr,\n                          Const struct cs_Dtdef_ *dtPtr,\n                          Const struct cs_Eldef_ *elPtr);\nstruct cs_Csprm_ *Cscsloc(Const struct cs_Csdef_ *csPtr,\n                          Const struct cs_Dtdef_ *dtPtr);\n\n\n\n\nCS_csloc\n locates the coordinate system definition indicated by \ncs_nam\n and returns a pointer to a \nmalloc\n'ed, coordinate system parameter structure initialized for the specified coordinate system. The return value is the argument required by \nCS_cs2ll\n, \nCS_ll2cs\n, \nCS_csscl\n, and \nCS_cscnv\n. When no longer needed, the memory pointed to by the returned pointer should be released using \nCS_free\n.\n\n\nCS_csloc\n accesses the definition dictionaries as is necessary to accomplish its task. The alternative functions enable applications to create coordinate system parameter structures using definitions that may have been obtained from sources other than the dictionaries. For example, certain applications may store definitions in vehicles other than the dictionaries, and then desire to construct a coordinate system parameter structure from these definitions.\n\n\nNote that \nCscsloc1\n does not need to access the coordinate system dictionary as the coordinate system definition is provided by the \ncs_ptr\n argument. However, it will need to access the datum and ellipsoid dictionaries to resolve datum and ellipsoid references. \nCscsloc2\n is completely independent of all dictionaries as all three definitions must be provided. \nCScsloc\n is simply a basic function is encapsulates the basic functions of \nCS_csloc\n and its alternatives, and thus prevents duplication of large amounts of code.\n\n\nERRORS\n\n\nCS_csloc\n, \nCScsloc1\n, \nCScsloc2\n, and \nCScsloc\n return a \nNULL\n pointer and set \ncs_Error\n through the use of \nCS_erpt\n if any of the following conditions occur:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_UNKWN_PROJ\n\n\nThe projection specified in the coordinate system definition is unknown to the system.\n\n\n\n\n\n\n\n\nCS_csloc\n uses the following functions that detect a majority of the exceptional conditions that may occur:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCS_csdef\n\n\nLocates and fetches the coordinate system definition from the Coordinate System Dictionary.\n\n\n\n\n\n\nCS_dtloc\n\n\nLocates and fetches the datum definition from the Datum Dictionary.\n\n\n\n\n\n\nCS_eldef\n\n\nLocates and fetches the ellipsoid definition from the Ellipsoid Dictionary.\n\n\n\n\n\n\n\n\nCScsloc1\n uses the following functions that detect a majority of the exceptional conditions that may occur:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCS_dtloc\n\n\nLocates and fetches the datum definition from the Datum Dictionary.\n\n\n\n\n\n\nCS_eldef\n\n\nLocates and fetches the ellipsoid definition from the Ellipsoid Dictionary.\n\n\n\n\n\n\n\n\nCS_cssch Coordinate System Scale H, along a meridian\n\n\ndouble CS_cssch (Const struct cs_Csprm_ *csprm, Const double ll[2]);\n\n\n\n\nGiven the definition of the coordinate system, \ncsprm\n, such as returned by \nCS_csloc\n, \nCS_cssch\n will compute the grid scale factor along a meridian at the location given by \nll\n and return this value. See \nCS_cssck\n for the grid scale factor along a parallel. Note that in conformal projections, the grid scale along a parallel equals the grid scale along a meridian at any point.\n\n\nThe location, as given by \nll\n, is in terms of latitude and longitude. The longitude is the first element of the \nll\n array, latitude is the second, and both must be given in degrees. Positive values are used to specify north latitude and east longitude, negative values are used to specify south latitude and west longitude.\n\n\nCS_cssck Coordinate System Scale K, along a parallel\n\n\ndouble CS_cssck (Const struct cs_Csprm_ *csprm, Const double ll[2]);\n\n\n\n\nGiven the definition of the coordinate system, \ncsprm\n, such as returned by \nCS_csloc\n, \nCS_cssck\n will compute the grid scale factor along a parallel at the location given by \nll\n and return this value. See \nCS_cssch\n for the grid scale factor along a meridian. Note that in conformal projections, the grid scale along a parallel equals the grid scale along a meridian at any point.\n\n\nThe location, as given by \nll\n is in terms of latitude and longitude. The longitude is the first element of the \nll\n array, latitude is the second, and both must be given in degrees. Positive values are used to specify north latitude and east longitude, negative values are used to specify south latitude and west longitude.\n\n\nCS_csscl Coordinate System Scale\n\n\ndouble CS_csscl (Const struct cs_Csprm_ *csprm, Const double ll[2]);\n\n\n\n\nGiven the definition of the coordinate system, \ncsprm\n, such as returned by \nCS_csloc\n, \nCS_csscl\n will compute the grid scale factor at the location given by \nll\n and return this value.\n\n\nThe location, as given by \nll\n, is in terms of latitude and longitude. The longitude is the first element of the \nll\n array, latitude is the second, and both must be given in degrees. Positive values are used to specify north latitude and east longitude, negative values are used to specify south latitude and west longitude.\n\n\nNon-conformal projections have two different grid scale factors: the scale along a meridian and the scale along a parallel. In the case of azimuthal projections, the two scale factors are along a radial line from the origin and normal to such radial lines, respectively. In these cases, \nCS_csscl\n will return the more interesting of the two. For example, in the American Polyconic, the grid scale factor along all parallels is always 1.0; therefore \nCS_csscl\n return the grid scale factor along a meridian for this projection.\n\n\nCS_csupd Coordinate system dictionary update\n\n\nint CS_csupd (struct cs_Csdef_ *csdef, int crypt);\n\n\n\n\nCS_csupd\n will cause coordinate system definition pointed to by \ncsdef\n to be added to the Coordinate System Dictionary. If a coordinate system with the same key name already exists, it is replaced by the definition provided. If no such definition exists, the new definition is added to the dictionary. If \ncrypt\n is non-zero, the entry will be encrypted before being written to the dictionary.\n\n\nIn the event that the indicated coordinate system already exists, \nCS_csupd\n will return a 1 to indicate a successful update. In the event that the provided coordinate system had to be added to the Coordinate System Dictionary, a zero is returned. A -1 is returned if the update failed for any reason.\n\n\nPlease note that the addition of a new coordinate system definition requires the sorting of the Coordinate System Definition file. This may take a few seconds to complete, depending upon the size of the Coordinate System Dictionary.\n\n\nIf the value of the global variable \ncs_Protect\n is greater than or equal to zero, \nCS_csupd\n will not change a coordinate system which is marked as being a distribution coordinate system (i.e. \ncs_Csdef_.protect == 1\n). If the value of \ncs_Protect\n is greater than zero, it is interpreted as the number of days after which a user defined coordinate system is protected. For example, if \ncs_Protect\n is 60, a user-defined coordinate system becomes protected 60 days after it is last modified.\n\n\nAdditionally, if the value of the global character variable \ncs_Unique\n is not the null character, \nCS_csupd\n will not add a coordinate system definition if its key name does not contain the character indicated. For example, if \ncs_Unique\n is set to the colon character, \nCS_csupd\n will not add a coordinate system whose key name does not contain a colon character.\n\n\nERRORS\n\n\nCS_csupd\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered during the update:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_CSDICT\n\n\nThe Coordinate System Dictionary file could not be opened. (See \nCS_altdr\n).\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred during the update process.\n\n\n\n\n\n\ncs_CS_BAD_MAGIC\n\n\nThe file that, by virtue of its name and location, was supposed to be a Coordinate System Dictionary wasn't a Coordinate System Dictionary; its magic number was invalid.\n\n\n\n\n\n\ncs_DISK_FULL\n\n\nThere was insufficient disk space available to add the coordinate system definition to the dictionary.\n\n\n\n\n\n\ncs_CS_PROT\n\n\nThe coordinate system to be updated is a distribution coordinate system and may not be updated.\n\n\n\n\n\n\ncs_CS_UPROT\n\n\nThe coordinate system is a user defined coordinate system that has not been modified for 60 days and is therefore protected.\n\n\n\n\n\n\ncs_UNIQUE\n\n\nThe coordinate system provided does not already exist and would need to be added; but the key name does not contain the unique character.\n\n\n\n\n\n\n\n\nCS_dtcls Datum conversion close\n\n\nvoid CS_dtcls (struct cs_Dtcprm_ *dtc_ptr);\n\n\n\n\nInitializing a datum conversion can use file descriptors (handles) and allocate memory from the heap. Applications may need to recover these system resources for other use prior to exiting. \nCS_dtcls\n will release all system resources allocated to the datum conversion indicated by the \ndtc_ptr\n argument (as returned by \nCS_dtcsu\n). This function is, essentially, the inverse of \nCS_dtcsu\n.\n\n\nCS_dtcsu Datum conversion set up\n\n\nstruct cs_Dtcprm_ *CS_dtcsu (Const struct cs_Csprm_ *src_cs, Const struct cs_Crprm_ *dest_cs, int dat_err, int blk_err);\n\n\n\n\nCS_dtcsu\n, \nCS_dtcvt\n, and \nCS_dtcls\n, are designed to provide a generic application interface for datum conversion. The objective is to enable application programmers to incorporate datum conversion capabilities into applications with a minimum of impact. Therefore, application programmers use \nCS_dtcsu\n to set up a datum conversion and \nCS_dtcvt\n to perform the actual conversions independently of the number or type of datum conversions that may or may not be supported. \nCS_dtcls\n provides a means of recovering any system resources that may be allocated by the activation of a datum conversion.\n\n\nApplication programmers use \nCS_dtcsu\n to initiate a datum conversion process. \nSrc_cs\n points to the coordinate system definition of the source data that is to be converted while \ndest_cs\n points to the coordinate system definition for the results. \nCS_dtcsu\n examines the datum references in these coordinate systems, initializes the appropriate datum shift conversion, and returns a pointer to a \nmalloc\n'ed datum conversion parameter block. The returned pointer is a required argument for the \nCS_dtcvt\n function.\n\n\nAs is often the case, should the source and destination coordinate systems share the same datum, the null datum conversion is activated. That is, source latitudes and longitudes are copied directly to the destination array without modification.\n\n\nThe \ndat_err\n argument is used to indicate the desired disposition of certain errors that are encountered during the setup of the datum conversion. The error disposition control afforded by \ndat_err\n applies only to errors indicating that an unsupported datum conversion was requested. System errors, such as physical I/O or insufficient memory for example, are always treated as fatal errors and a \nNULL\n pointer is returned.\n\n\nThe following values for \ndat_err\n are recognized:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_DTCFLG_DAT_I\n\n\nIgnore unsupported datum conversion request errors and, in the event of such an error, silently activate the null conversion.\n\n\n\n\n\n\ncs_DTCFLG_DAT_W\n\n\nIn the event of an unsupported datum conversion request error, report the condition as a warning to \nCS_erpt\n (\ncs_DTC_DAT_W\n) and activate the null conversion. In this case, the user is notified, but data processing continues.\n\n\n\n\n\n\ncs_DTCFLG_DAT_F\n\n\nIn the event of any error, report the condition as a fatal error to \nCS_erpt\n (\ncs_DTC_DAT_F\n) and return the NULL pointer.\n\n\n\n\n\n\n\n\nThe \nblk_err\n argument is used to indicate the desired disposition of certain errors that are encountered during the conversion of individual coordinate values. The error disposition control afforded by \nblk_err\n applies only to errors indicating that the required data for the geographic region containing the coordinate to be converted is not available. System errors, such as physical I/O or insufficient memory for example, are always treated as fatal errors.\n\n\nThe following values for \nblk_err\n are recognized:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_DTCFLG_BLK_I\n\n\nIgnore datum conversion errors caused by data availability problems and silently use the null conversion for the specific coordinate that could not be converted and cause \nCS_dtcvt\n to return a zero value.\n\n\n\n\n\n\ncs_DTCFLG_BLK_W\n\n\nIn the event a datum conversion fails due to data availability, report a warning through \nCS_erpt\n (\ncs_DTC_BLK_W\n), convert the coordinate using the null conversion, and cause a \nCS_dtcvt\n to return a positive non-zero value for the specific coordinate that could not be converted. The warning message is issued for each coordinate that could not be converted.\n\n\n\n\n\n\ncs_DTCFLG_BLK_1\n\n\nIn the event a datum conversion fails due to data availability, cause \nCS_dtcvt\n to return a positive non-zero value for the specific coordinate that could not be converted. That such an error has been reported is recorded in the datum parameter block and this is used to suppress repeated reporting of the error with regard to the same block.\n\n\n\n\n\n\ncs_DTCFLG_BLK_F\n\n\nReport a fatal condition through \nCS_erpt\n (\ncs_DTC_BLK_F\n), convert the coordinate using the null conversion, and cause \nCS_dtcvt\n to return a negative non-zero value to indicate that the expected conversion did not take place.\n\n\n\n\n\n\n\n\nSpecial cases\n\n\nThree special cases have been coded into this function. Normally, the geographic coodinates of the source datum are converted to WGS84 values, and the resulting WGS84 values are then converted to the target datum.\n\n\nThere are three cases where this genberal technique proved to be unsatisfactory. In these three cases, \nCS_dtcsu\n has been expressly coded to look at the source and target datums, and implement direct conversions where appropriate. Note, that in each case, a specific Geodetic Data Catalog file is also involved. Thus, if the required Geodetic Data Catalog file is not present, all of the special processing is disabled.\n\n\nThe following table defines the special cases:\n\n\n\n\n\n\n\n\nSource Datum\n\n\nTarget Datum\n\n\nGeodetic Data Catalog\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNAD27\n\n\nATS77\n\n\nNad27ToAts77.gdc\n\n\nConverts directly from NAD27 to ATS77 using the very special \nTRANSFORM\n algorithm.\n\n\n\n\n\n\nATS77\n\n\nCSRS\n\n\nAts77ToCsrs.gdc\n\n\nConverts directly as direct NTv2 format files are generally available.\n\n\n\n\n\n\nNAD27\n\n\nCSRS\n\n\nNad27ToCsrs.gdc\n\n\nConverts directly as direct NTv2 format files are generally available.\n\n\n\n\n\n\n\n\nERRORS\n\n\nShould the requested datum conversion requested be unsupported, \nCS_dtcsu\n will perform as indicated by the \ndat_err\n argument. Should the initialization of a supported datum conversion fail due to a system error, the \nNULL\n pointer will be returned and \ncs_Error\n set to indicate the nature of failure. Should a datum conversion for which appropriate code is present fail because a required data file is not present, the failure is treated as an unsupported datum conversion request.\n\n\nCS_dtcvt Datum Convert\n\n\nint CS_dtcvt (struct cs_Dtcprm_ *dtc_ptr, Const double src_ll[2], double dest_ll[2]);\n\n\n\n\nCS_dtcvt\n performs the datum conversion indicated by \ndtc_ptr\n returning in the array pointed to by \ndest_ll\n the result of converting the latitude and longitude values pointed to by \nsrc_ll\n. \nSrc_ll\n and \ndest_ll\n may point to the same array. Latitude and longitude values must be given in degrees, where negative values indicate south and west. The longitude is carried in the first element of the array and the latitude is carried in the second element. The \ndtc_ptr\n argument is that which is returned by \nCS_dtcsu\n.\n\n\nERRORS\n\n\nShould a system error occur during the conversion (e.g. a physical I/O error or insufficient memory) \nCS_dtcvt\n returns a negative non-zero value and sets \ncs_Error\n to indicate the cause of the failure.\n\n\nConversion failures caused by a lack of data covering the specific coordinate to be converted are handled as indicated by the \nblk_err\n element of the \ncs_Dtcprm_\n structure pointed to by the \n**tc_ptr** argument. The **blk_err** element is set by\nCS_dtcsu\nto the value of its **blk_err** argument prior to returning **dtc_ptr**. Refer to\nCS_dtcsu` for a detailed description of how such errors are handled.\n\n\nIn all cases, the null conversion is always performed before any other processing is attempted.\n\n\nEXAMPLE\n\n\nThis function, and its companion \nCS_dtcsu\n have been designed such that the following sequence of code is all that is necessary to perform a complete coordinate conversion, including a datum conversion (error handling omitted):\n\n\n#define XX 0\n#define YY 1\nstruct cs_Csprm * src_cs, * dest_cs;\nstruct cs_Dtcprm_ *dtc_ptr;\ndouble src_xy [2], ll[2], dest_xy[2];\n.\n.\nsrc_cs = CS_csloc ( src_name) ;\ndest_cs = CS_csloc (dest_name);\ndtc_ptr = CS_dtcsu ( src_cs, dest_cs, cs_DTCFLG_DAT_F, cs_DTCDLG_BLK_1) ; .\n.\nwhile (TRUE)\n{\n.\n.\nsrc_xy[XX] = ???;\nsrc_xy[YY] = ???;\nCS_cs2ll (src_cs,ll,src_xy); CS_dtcvt (dtc_ptr,ll,ll); CS_ll2cs (dest_cs,dest_xy,ll);\n??? = dest_xy[XX]; ??? = dest_xy[YY]; .\n.\n}\nCS_free (src_cs); CS_free (dest_cs); CS_dtcls (dtc_ptr);\n\n\n\n\nNotice, that adding the datum conversion to a simple cartographic conversion requires only the insertion of three lines of code (error handling aside) to the simple High Performance Interface described elsewhere in this manual.\n\n\nCS_dtdef Datum Definition locator\n\n\nstruct cs_Dtdef_ * CS_dtdef ( Const char * key_nm) ;\n\n\n\n\nCS_dtdef\n will return a pointer to a \nmalloc\n'ed \ncs_Dt def_\n structure which contains the definition of the datum indicated by \nkey_nm\n. \nKey_nm\n must point to an array that contains the null terminated key name of the desired datum definition. The memory allocated for the datum definition should be released by using \nCS_free\n when no longer needed.\n\n\nERRORS\n\n\nCS_dtdef\n will return a \nNULL\n pointer and set \ncs_Error\n if any of the following conditions are detected:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_DTDICT\n\n\nThe Datum Dictionary file could not be found or otherwise opened. (See \nCS_altdr\n)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred during access to the Datum Dictionary file.\n\n\n\n\n\n\ncs_DT_BAD_MAGIC\n\n\nThe file accessed under the assumption that it was a Datum Dictionary wasn't a Datum Dictionary after all; it had an invalid magic number on the front end.\n\n\n\n\n\n\ncs_DT_NOT_FND\n\n\nA datum definition with the name given by \nkey_nm\n was not found in the Datum Dictionary.\n\n\n\n\n\n\ncs_NO_MEM\n\n\nInsufficient dynamic memory was available to allocate space for the \ncs_Dtdef_\n structure.\n\n\n\n\n\n\n\n\nCS_dtdel DaTum definition delete\n\n\nint CS_dtdel (struct cs_Dtdef_ *dtdef);\n\n\n\n\nCS_dtdel\n will delete from the Datum Dictionary the definition of the Datum pointed to by \ndtdef\n.\n\n\nThe delete is accomplished by creating a new Datum Dictionary file and copying all but the referenced datum definition from the existing dictionary to the new one. This implies that sufficient disk space must be available to perform this copy. A zero is returned if the delete was successfully completed, a - 1 if a problem occurred. An attempt to delete a non-existent datum definition is \nNOT\n considered a problem.\n\n\nIf the value of the global variable \ncs_Protect\n is greater than or equal to zero, \nCS_dtdel\n will not delete a datum definition which is marked as being a distribution datum definition (i.e. \ncs_Dt def_.protect == 1\n). If the value of \ncs_Protect\n is greater than zero, it is interpreted as the number of days after which a user defined datum is protected. For example, is \ncs_Protect\n is 60, a user-defined datum becomes protected 60 days after it is last modified.\n\n\nERRORS\n\n\nCS_dtdel\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_DTDICT\n\n\nThe Datum Dictionary file could not be found or otherwise opened. (See \nCS_altdr\n)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in copying the Datum Dictionary to the new file.\n\n\n\n\n\n\ncs_DT_BAD_MAGIC\n\n\nThe file assumed to be the Datum Dictionary by virtue of its name and location was not a Datum Dictionary; it had an invalid magic number.\n\n\n\n\n\n\ncs_TMP_CRT\n\n\nThe attempt to create a new file, to that the modified Datum Dictionary was to be copied, failed.\n\n\n\n\n\n\ncs_DISK_FULL\n\n\nInsufficient disk space was available to accommodate the copying of the Datum Dictionary to the new file.\n\n\n\n\n\n\ncs_UNLINK\n\n\nThe request to remove the old copy of the Datum Dictionary failed.\n\n\n\n\n\n\ncs_RENAME\n\n\nThe request to rename the new Datum Dictionary file from its temporary name to DATUMS failed.\n\n\n\n\n\n\ncs_DT_PROT\n\n\nThe datum definition to be updated is a distribution datum definition and may not be deleted.\n\n\n\n\n\n\ncs_DT_UPROT\n\n\nThe datum is a user-defined datum which has not been modified for 60 days and is therefore protected.\n\n\n\n\n\n\n\n\nCS_dtdflt Datum default\n\n\nchar *CS_dtdflt (Const char *new_dflt);\n\n\n\n\nUse \nCS_dtdflt\n to control the status of the \"defaultable\" datum reference feature of CS-MAP. \nNew_dflt\n must be either a valid datum key name, a pointer to the null string, or the \nNULL\n pointer. In the case where \nnew_dflt\n is a pointer to a valid datum definition key name, \nCS_dtdflt\n causes the default datum feature to be active, using the datum key name provided as the default value. When \nnew_dflt\n is a pointer to the null string, \nCS_dtdflt\n disables the default datum feature. When \nnew_dflt\n is the \nNULL\n pointer, the status of the default feature remains unchanged.\n\n\nIn all cases, \nCS_dtdflt\n returns the previous status (or in the case of \nnew_dflt == NULL\n, the current status) in the form of a pointer to a static character array which shall contain the name of the previous default datum. Should the returned pointer point to a null string, the indicated status is disabled.\n\n\nERRORS\n\n\nCS_dtdflt\n will return the \nNULL\n pointer if the key name provided is not that of a valid datum. In this event, the status of the default datum feature remains unchanged.\n\n\nCS_dtloc Datum locate\n\n\nstruct cs_Datum_ *CS_dtloc (Const char * key_nm) ;\nstruct cs_Datum_ *Csdtloc1 (Const struct cs_Dtdef_ *dtPtr);\nstruct cs_Datum_ *Csdtloc2 (Const struct cs_Dtdef_ *dtPtr, Const struct cs_Eldef_ *elPtr);\n\n\n\n\nCS_dtloc\n will return a pointer to a \nmalloc\n'ed \ncs_Datum_\n structure which contains the definition of the datum indicated by \nkey_nm\n along with the ellipsoid information referenced by the datum definition. \nKey_nm\n must point to an array that contains the key name of the desired datum. The memory allocated for the datum definition should be released using \nCS_free\n when no longer needed.\n\n\nCSdtloc1\n and \nCSdtloc2\n are alternatives to \nCS_dtloc\n that enable alternative sources for datum and ellipsoid definitions. These have been provided for applications that may, for example, store the datum, and/or ellipsoid, definitions in an application database.\n\n\nNote that while \nCSdtloc1\n will not need to access the Datum Dictionary, it will need to access the Ellipsoid Dictionary to resolve the ellipsoid reference in the datum definition provided. \nCSdtloc2\n is completely independent of both dictionaries.\n\n\nERRORS\n\n\nCS_dtloc\n, \nCsdtloc\n, and \nCSdtloc2\n will return a NULL pointer and set \ncs_Error\n if any of the following conditions are detected:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_NO_MEM\n\n\nInsufficient dynamic memory was available to allocate space for the \ncs_Datum_\n structure.\n\n\n\n\n\n\n\n\nCS_dtloc\n uses \nCS_dtdef\n and \nCS_eldef\n to obtain definition records from the Datum and Ellipsoid Dictionaries. Therefore, all of the error conditions detected by these functions apply to this function as well.\n\n\nCSdtloc1\n uses \nCS_eldef\n to obtain definition records from the Ellipsoid Dictionary. Therefore, all of the error conditions detected by this function apply to this function as well.\n\n\nCS_dtupd Datum dictionary update\n\n\nint CS_dtupd (struct cs_Dtdef_ *dt_def, int crypt);\n\n\n\n\nCS_dtupd\n will cause the datum definition pointed to by \ndt_def\n to be added to the Datum Dictionary. If a datum with the same key name exists, it is replaced by the definition provided. If no such definition exists, the new definition is added to the dictionary. If \ncrypt\n is non-zero, the datum entry is encrypted before being written.\n\n\nIn the event that the indicated datum already existed, \nCS_dtupd\n will return a 1 to indicate a successful update. In the event that the provided datum definition had to be added to the Datum Dictionary, a zero is returned. A -1 is returned if the update failed for any reason.\n\n\nPlease note that the addition of a new datum definition requires the sorting of the Datum Dictionary file. This may take a few seconds to complete, depending upon the size of the Datum Dictionary.\n\n\nIf the value of the global variable \ncs_Protect\n is greater than or equal to zero, \nCS_dtupd\n will not change a datum definition which is marked as being a distribution datum definition (i.e.\n\ncs_Dtdef_.protect == 1\n). If the value of \ncs_Protect\n is greater than zero, it is interpreted as the number of days after which a user defined datum is protected. For example, is \ncs_Protect\n is 60, a user-defined datum becomes protected 60 days after it is last modified.\n\n\nAdditionally, if the value of the global character variable \ncs_Unique\n is not the null character, \nCS_dtupd\n will not add a datum definition if its key name does not contain the character indicated. For example, if \ncs_Unique\n is set to the colon character, \nC\nS_dtupd` will not add a datum definition whose key name does not contain a colon character.\n\n\nERRORS\n\n\nCS_dtupd\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered during the update:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_DTDICT\n\n\nThe Datum Dictionary file could not be opened. (See \nCS_altdr\n)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred during the update process.\n\n\n\n\n\n\ncs_DT_BAD_MAGIC\n\n\nThe file which, by virtue of its name and location, was assumed to be a Datum Dictionary wasn't a Datum Dictionary; its magic number was invalid.\n\n\n\n\n\n\nCs_DISK_FULL\n\n\nThere was insufficient disk space available to add the datum definition to the Datum Dictionary.\n\n\n\n\n\n\nCs_DT_PROT\n\n\nThe datum definition to be updated is a distribution datum definition and may not be updated.\n\n\n\n\n\n\ncs_DT_UPROT\n\n\nThe datum is a user-defined datum that has not been modified for 60 days and is therefore protected.\n\n\n\n\n\n\ncs_UNIQUE\n\n\nThe datum provided does not already exist and would need to be added; but the key name does not contain the unique character.\n\n\n\n\n\n\n\n\nCS_eldef Ellipsoid definition locator\n\n\nstruct cs_Eldef_ * CS_eldef ( Const char * key_nm) ;\n\n\n\n\nCS_eldef\n will return a pointer to a \nmalloc\n'ed \ncs_Eldef_\n structure which contains the definition of the ellipsoid indicated by \nkey_nm\n. \nKey_nm\n must point to an array that contains the null terminated key name of the desired ellipsoid definition. The memory allocated for the ellipsoid definition should be released using \nCS_free\n when no longer needed.\n\n\nERRORS\n\n\nCS_eldef\n will return a \nNULL\n pointer and set \ncs_Error\n if any of the following conditions are detected:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_ELDICT\n\n\nThe Ellipsoid Dictionary file could not be found or otherwise opened. (See \nCS_altdr\n)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred during access to the Ellipsoid Dictionary file.\n\n\n\n\n\n\ncs_EL_BAD_MAGIC\n\n\nThe file accessed under the assumption that it was an Ellipsoid Dictionary wasn't an Ellipsoid Dictionary after all; it had an invalid magic number on the front end.\n\n\n\n\n\n\ncs_EL_NOT_FND\n\n\nA ellipsoid definition with the name given by key_nm was not found in the Ellipsoid Dictionary.\n\n\n\n\n\n\ncs_NO_MEM\n\n\nInsufficient dynamic memory was available to allocate space for the \ncs_Eldef_\n structure\n\n\n\n\n\n\n\n\nCS_eldel Ellipsoid definition delete\n\n\n\nint CS_eldel (struct cs_Eldef_ *eldef);\n\n\n\n\nCS_eldel\n will delete from the Ellipsoid Dictionary the definition of the Ellipsoid pointed to by \neldef\n.\n\n\nThe delete is accomplished by creating a new Ellipsoid Dictionary file and copying all but the referenced ellipsoid definition from the existing dictionary to the new one. This implies that sufficient disk space must be available to perform this copy. A zero is returned if the delete was successfully completed, a -1 if a problem occurred. An attempt to delete a non-existent ellipsoid definition is \nNOT\n considered a problem.\n\n\nIf the value of the global variable \ncs_Protect\n is greater than or equal to zero, \nCS_eldel\n will not delete an ellipsoid definition which is marked as being a distribution ellipsoid definition (i.e. \ncs_El def_.protect == 1\n). If the value of \ncs_Protect\n is greater than zero, it is interpreted as the number of days after which a user defined ellipsoid is protected. For example, is \ncs_Protect\n is 60, a user-defined ellipsoid becomes protected 60 days after it is last modified.\n\n\nERRORS\n\n\nCS_eldel\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_ELDICT\n\n\nThe Ellipsoid Dictionary could not be found or otherwise opened. (See \nCS_altdr\n)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in copying the Ellipsoid Dictionary to the new file.\n\n\n\n\n\n\ncs_EL_BAD_MAGIC\n\n\nThe file assumed to be the Ellipsoid Dictionary by virtue of its name and location was not an Ellipsoid Dictionary; it had an invalid magic number.\n\n\n\n\n\n\ncs_TMP_CRT\n\n\nThe attempt to create a new file, to which the modified Ellipsoid Dictionary was to be copied, failed.\n\n\n\n\n\n\ncs_DISK_FULL\n\n\nInsufficient disk space was available to accommodate the copying of the Ellipsoid Dictionary to the new file.\n\n\n\n\n\n\ncs_UNLINK\n\n\nThe request to remove the old copy of the Ellipsoid Dictionary failed.\n\n\n\n\n\n\ncs_RENAME\n\n\nThe request to rename the new Ellipsoid Dictionary file from its temporary name to ELIPSOID failed.\n\n\n\n\n\n\ncs_EL_PROT\n\n\nThe ellipsoid definition to be updated is a distribution ellipsoid definition and may not be deleted.\n\n\n\n\n\n\ncs_EL_UPROT\n\n\nThe ellipsoid is a user-defined ellipsoid which has not been modified for 60 days and is therefore protected.\n\n\n\n\n\n\n\n\nCS_eldflt Ellipsoid default\n\n\nchar *CS_eldlt (Const char *new_dflt);\n\n\n\n\nUse \nCS_eldflt\n to control the status of the \"defaultable\" ellipsoid reference feature of CS-MAP.\n\nNew_dflt\n must be either a pointer to a valid ellipsoid key name, a pointer to the null string, or the \nNULL\n pointer. In the case where \nnew_dflt\n is a pointer to a valid ellipsoid definition key name, \nCS_eldflt\n causes the default ellipsoid feature to be activated, using the ellipsoid key name provided as the, possibly new, default value. When \nnew_dflt\n is a pointer to the null string, \nCS_eldflt\n disables the default ellipsoid feature. When \nnew_dflt\n is the \nNULL\n pointer, the status of the default feature remains unchanged.\n\n\nIn all cases, \nCS_eldflt\n returns the previous status (or in the case of \nnew_dflt == NULL\n, the current status) in the form of a pointer to a static character array that shall contain the name of the previous default ellipsoid. Should the returned pointer point to a null string, the indicated status is disabled.\n\n\nERRORS\n\n\nCS_eldflt\n will return the \nNULL\n pointer if the key name provided is not that of a valid ellipsoid. In this event, the status of the default ellipsoid feature remains unchanged.\n\n\nCS_elEnum Ellipsoid enumerator\n\n\nint CS_elEnum(int index, char *key_name, int size);\n\n\n\n\nCS_elEnum\n is used to enumerate all ellipsoids in the Ellipsoid Dictionary. \nCS_elEnum\n returns in the memory buffer pointer to by the \nkey_name\n argument the key name of the \nindex\n'th entry in the Ellipsoid Dictionary. \nCS_elEnum\n will never write more than size bytes to the indicated location. \nIndex\n is a zero based index; the index of the first entry in the Ellipsoid Dictionary is zero.\n\n\nCS_elEnum\n returns a positive 1 to indicate success. If \nindex\n is too large, a zero is returned.\n\n\nERRORS\n\n\nCS_elEnum\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_ELDICT\n\n\nThe Ellipsoid Dictionary could not be found or otherwise opened. (See \nCS_altdr\n)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred in accessing the Ellipsoid Dictionary.\n\n\n\n\n\n\ncs_DT_BAD_MAGIC\n\n\nThe file assumed to be the Ellipsoid Dictionary by virtue of its name was not an Ellipsoid Dictionary; it had an invalid magic number.\n\n\n\n\n\n\ncs_INV_INDX\n\n\nThe index argument was negative.\n\n\n\n\n\n\n\n\nCS_elupd Ellipsoid dictionary update\n\n\nint CS_elupd (struct cs_Eldef_ *el_def, int crypt);\n\n\n\n\nCS_elupd\n will cause the ellipsoid definition pointed to by \nel_def\n to be added to the Ellipsoid Dictionary. If an ellipsoid with the same key name exists, it is replaced by the definition provided. If no such definition exists, the new definition is added to the dictionary. If \ncrypt\n is non-zero, the ellipsoid entry is encrypted before being written.\n\n\nIn the event that the indicated ellipsoid already existed, \nCS_elupd\n will return a 1 to indicate a successful update. In the event that the provided ellipsoid had to be added to the Ellipsoid Dictionary, a zero is returned. A -1 is returned if the update failed for any reason.\n\n\nPlease note that the addition of a new ellipsoid definition requires the sorting of the Ellipsoid Dictionary file. This may take a few seconds to complete, depending upon the size of the Ellipsoid Dictionary.\n\n\nIf the value of the global variable \ncs_Protect\n is greater than or equal to zero, \nCS_elupd\n will not change an ellipsoid definition which is marked as being a distribution ellipsoid definition (i.e.\n\ncs_Elde_.protect == 1\n). If the value of \ncs_Protect\n is greater than zero, it is interpreted as the number of days after which a user defined ellipsoid is protected. For example, is \ncs_Protect\n is 60, a user-defined ellipsoid becomes protected 60 days after it is last modified.\n\n\nAdditionally, if the value of the global character variable \ncs_Unique\n is not the null character, \nCS_elupd\n will not add an ellipsoid definition if its key name does not contain the character indicated. For example, if \ncs_Unique\n is set to the colon character, \nCS_elupd\n will not add an ellipsoid definition whose key name does not contain a colon character.\n\n\nERRORS\n\n\nCS_elupd\n will return a -1 and set \ncs_Error\n appropriately if any of the following conditions are encountered during the update:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_ELDICT\n\n\nThe Ellipsoid Dictionary file could not be opened. (See \nCS_altdr\n)\n\n\n\n\n\n\ncs_IOERR\n\n\nA physical I/O error occurred during the update process.\n\n\n\n\n\n\ncs_EL_BAD_MAGIC\n\n\nThe file which, by virtue of its name and location, was assumed to be an Ellipsoid Dictionary wasn't an Ellipsoid Dictionary; its magic number was invalid.\n\n\n\n\n\n\ncs_DISK_FULL\n\n\nThere was insufficient disk space available to add the ellipsoid definition to the Ellipsoid Dictionary.\n\n\n\n\n\n\ncs_EL_PROT\n\n\nThe ellipsoid definition to be updated is a distribution ellipsoid definition and may not be updated.\n\n\n\n\n\n\ncs_EL_UPROT\n\n\nThe ellipsoid is a user-defined ellipsoid that has not been modified for 60 days and is therefore protected.\n\n\n\n\n\n\ncs_UNIQUE\n\n\nThe ellipsoid provided does not already exist and would need to be added; but the key name does not contain the unique character.\n\n\n\n\n\n\n\n\nCS_errmsg Error message\n\n\nvoid CS_errmsg (char msg_bufr, int bufr_size);\n\n\n\n\nCS_errmsg\n returns to the calling function a null terminated string that describes the last error condition detected by the CS-MAP library. The result is returned in the buffer pointed to by the \nmsg_bufr\n argument, which is assumed to be \nbufr_size\n bytes long. The message is returned in one character per byte ANSI code characters.\n\n\nCS_errmsg\n will return the null string if called before any error condition is detected.\n\n\nBUGS\n\n\nAfter returning an error message to the user, \nCS_errmsg\n should reset itself to the null string preventing the same error message from being returned a second time. It should, but it doesn't.\n\n\nCS_ll2cs Latitude/Longitude TO Coordinate System\n\n\nvoid CS_ll2cs (Const struct cs_Csprm_ *csprm, double xy[2], Const double ll[2] );\n\n\n\n\nGiven the definition of the coordinate system, \ncsprm\n, such as returned by \nCS_csloc\n, \nCS_ll2cs\n will convert the latitude and longitude given by \nll\n to X and Y coordinates, returning the results in \nxy\n. The \nll\n and \nxy\n arguments may point to the same array.\n\n\nIn the arrays, the X coordinate and the longitude occupy the first element, the Y coordinate and the latitude the second element. The latitude and longitude must be given in degrees where negative values are used to indicate west longitude and south latitude.\n\n\nCS_llchk Lat/Long limits check\n\n\nint CS_llchk (Const struct cs_Csprm_ *csprm, int cnt, Const double pnts[][3]);\n\n\n\n\nCS_llchk\n determines if the points, great circles, and regions defined by the point list provided by the \ncnt\n and \npnts\n arguments are within the mathematical domain and useful range of the coordinate system provided by the \ncsprm\n argument. All points in the point list are expected to be geographic coordinates. Use \nCS_xychk\n to check a list of cartesian coordinates.\n\n\nCS_llchk\n returns \ncs_CNVRT_OK\n if all coordinate subject to the determination are both within the mathematical domain of the coordinate system and the useful range of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more coordinates is outside of the mathematical domain of the coordinate system. \ncs_CNVRT_USFL\n is returned if all coordinates subject to the determination are within the mathematical domain of the coordinate system, but one or more coordinates are outside of the useful range of the coordinate system.\n\n\nThe useful range of a coordinate system may be defined by the user as part of the coordinate system definition. In the absence of such a definition, the setup function for each projection computes a useful range based on the parameters for the projection. In some cases, this computed useful range will be too liberal; in others it may be too conservative. In any case, checking coordinates to be converted against the useful range is a good way to alert users of a possible problem, such as using the wrong coordinate system for a set of coordinates.\n\n\nCS_ludflt linear unit default\n\n\nchar *CS_ludlt (Const char *new_dflt);\n\n\n\n\nUse \nCS_ludflt\n to control the status of the \"defaultable\" linear unit reference feature of CS-MAP. \nNew_dflt\n must be either a pointer to a valid linear unit name, a pointer to the null string, or the \nNULL\n pointer. In the case where \nnew_dflt\n is a pointer to a valid linear unit name, \nCS_ludflt\n causes the default linear unit feature to be activated, using the linear unit name provided as the, possibly new, default value. When \nnew_dflt\n is a pointer to the null string, \nCS_ludflt\n disables the default linear unit feature. When \nnew_dflt\n is the \nNULL\n pointer, the status of the linear unit default feature remains unchanged.\n\n\nIn all cases, \nCS_ludflt\n returns the previous status (or in the case of \nnew_dflt == NULL\n, the current status) in the form of a pointer to a static character array which shall contain the name of the previous default linear unit. Should the returned pointer point to a null string, the indicated status is disabled.\n\n\nERRORS\n\n\nCS_ludflt\n will return the \nNULL\n pointer if the key name provided is not that of a valid linear unit. In this event, the status of the default linear unit feature remains unchanged.\n\n\nCS_xychk X and Y limits check\n\n\nint CS_xychk (Const struct cs_Csprm_ *csprm, int cnt, Const double pnts[][3]);\n\n\n\n\nCS_xychk\n determines if the points, line segments, and regions defined by the point list provided by the \ncnt\n and \npnts\n arguments are within the mathematical domain and useful range of the coordinate system provided by the \ncsprm\n argument. All points in the point list are expected to be cartesian coordinates. Use \nCS_llchk\n to check a list of geographic coordinates.\n\n\nCS_xychk\n returns \ncs_CNVRT_OK\n if all coordinate subject to the determination are both within the mathematical domain of the coordinate system and the useful range of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more coordinates is outside of the mathematical domain of the coordinate system. \ncs_CNVRT_USFL\n is returned if all coordinates subject to the determination are within the mathematical domain of the coordinate system, but one or more coordinates are outside of the useful range of the coordinate system.\n\n\nThe useful range of a coordinate system may be defined by the user as part of the coordinate system definition. In the absence of such a definition, the setup function for each projection computes a useful range based on the parameters for the projection. In some cases, this computed useful range will be too liberal; in others it may be too conservative. In any case, checking coordinates to be converted against the useful range is a good way to alert users of a possible problem, such as using the wrong coordinate system for a set of coordinates.\n\n\nCS_usrUnitPtr - Units look up hook function\n\n\ndouble CS_usrUnitPtr (short type, Const char *unitName);\n\n\n\n\nThis name, \nCS_usrUnitPtr\n , does not refer to a function. Rather, it refers to a global variable which is defined as a pointer to a function which is defined as the above given prototype declares. Applications can use a function as declared above, and the related global pointer variable, to implement unit definitions in a dynamic manner.\n\n\nIf the global variable \nCS_usrUnitPtr\n (defined in \nCSdata.c\n) is not null, the indicated function is called whenever the CS-MAP library is asked to access a specific unit definition. This function, then, can be used to dynamically supply a unit conversion value which does not exist in the compiled unit table. Applications can use this to implement their own unit definition table or dynamically generate such a definition based on the unit name provided.\n\n\nCS-MAP passes the \nunitName\n argument to the hook function prior to any validation, thus dynamic definition names need not adhere to the CS-MAP key name conventions. In the event that the hook function determines that it wishes to supply the definition, the desired conversion value must be returned. CS-MAP passed the unit type requested to the hook function using the \ntype\n argument.\n\n\nThe hook function returns an integer value:\n\n\n\n\na positive non-zero value to indicate that a conversion value is being supplied by the hook function, and the value returned is indeed the conversion value.\n\n\nzero is returned to indicate that normal CS-MAP unit table access is to be performed.\n\n\na negative value is returned to indicate that an error is to be reported. It is expect that the nature of the error would have already reported through the use of CS_erpt.\n\n\n\n\nCS_unitAdd - Add  unit to table\n\n\nint CS_unitAdd (struct cs_Unittab_ *unitPtr);\n\n\n\n\nUse this function to add a new unit to the unit table at run time. Essentially, the unit definition pointed to by the \nunitPtr\n argument is copied to a disabled entry in the compiled unit table. This function does not check any of the entries in the provided unit definition, so use this function with great care.\n\n\nERRORS\n\n\nCS_unitAdd\n returns a zero value for success. A negative return value indicates a failure. In this case, one of the following error conditions will have been reported through the use of \nCS_erpt\n:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_UADD_TYP\n\n\nThe type of unit specified in the provided definition was invalid. Must be either \ncs_UTYP_LIN\n or \ncs_UTYP_ANG\n.\n\n\n\n\n\n\ncs_UADD_DUP\n\n\nA unit definition with the (singular) name of given in the provided definition already exists in the unit table.\n\n\n\n\n\n\ncs_UADD_FULL\n\n\nAll of the disabled slots in the unit table have been filled; thus the unit table is currently full.\n\n\n\n\n\n\n\n\nCS_unitDel -- Delete unit from table\n\n\nint CS_unitDel (short type, Const char *name);\n\n\n\n\nUse this function to disable an entry in the unit table. The specific unit is identified by the \ntype\n and \nname\n arguments. Type must be given as either \ncs_UTYP_LIN\n or \ncs_UTYP_ANG\n. Note that compiled (i.e. not necessarily added) unit entries can also be disabled. This will remove them from subsequent unit enumerations performed by \nCS_unEnum\n.\n\n\nErrors\n\n\nCS_unitDel\n will return a zero for success. A negative 1 is return to indicate failure. In the event of failure, one of the following error conditions will have been reported through \nCS_erpt\n:\n\n\n\n\n\n\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncs_UDEL_NONE\n\n\nThe named unit, of the provided type, did not exist in the unit table.\n\n\n\n\n\n\n\n\nLow level interface functions\n\n\nFunctions which are considered part of the Low Level Interface are described in this section. Several of these functions require geographic arguments. Remember that these are required to be:\n\n\n\n\nin longitude, latitude, and height order, and\n\n\ngiven in degrees, and\n\n\nreferenced to Greenwich meridian, and\n\n\nwhere west lonigtude and south latitude are represented by negative values.\n\n\n\n\nFunction prototype definitions are given in the C syntax only.", 
            "title": "Library Functions"
        }, 
        {
            "location": "/userguide/libraryfunctions/#library-functions", 
            "text": "This section includes a technical description of 500+ functions in the CS-MAP library. The descriptions are organized by the interface of which they are a part. An index is provided elsewhere in this document.", 
            "title": "Library Functions"
        }, 
        {
            "location": "/userguide/libraryfunctions/#high-level-interface-functions", 
            "text": "Functions described in this section are designed to be called from high level languages such as Visual Basic. Therefore, descriptions of most functions in this section also include a function declaration appropriate for use in Visual Basic and Delphi in addition to the standard C prototype.", 
            "title": "High Level Interface Functions"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_altdr-alternate-directory", 
            "text": "Function CS_altdr (ByVal new_dir As String) As Integer function CS_altdr (alt_dr :PChar):Integer;\nint CS_altdr (Const char alt_dir);  Normally, all functions in the Coordinate System Mapping Package library expect to find data files in the  C:\\MAPPING  directory as defined in  CSdata .  CS_altdr  can be used to specify an alternate directory at run time; that indicated by the  alt_dir  argument.  CS_altdr  returns zero if a coordinate system dictionary was indeed found in the directory provided; otherwise, it returns -1.  Calling  CS_altdr  with the  NULL  pointer as its argument instructs  CS_altdr  to use the value of the environmental variable  CS_MAP_DIR  as the location of the CS-MAP data files. Again a zero is returned if this was successful, -1 if not. (The string defining the name of the environmental variable name is defined in the  cs_map.h  header file.)  Calling  CS_altdr  with the  alt_dir  argument pointing to the null string instructs  CS_altdr  to use the current directory on the current drive as the location of CS-MAP data files. Again a zero is returned if this selection produces a directory which contains a Coordinate System Dictionary File. Otherwise -1 is returned.  Notice, that using the return status as a guide, several attempts at locating the CS-MAP data directory can be made in any application.  The name of the directory which is searched for all data files is maintained in a global character array  cs_Dir , which is defined in the  CSdata  module. The  cs_Dir  array must, initially, contain a null terminated string, the last non-null character of which must be the directory separator character. The global character pointer  cs_DirP  (also defined in  CSdata ) is expected to point to the terminating null character of the string in  cs_Dir . Under this scheme, Coordinate System Mapping Package data files\nare accessed as follows:  extern char cs_Dir [];\nextern char *cs_DirP;\n:\nstrcpy (cs_DirP, file_name );\nfd = open (cs_Dir,O_MODE);\n:  Achieving this particular setup is relatively easy using  CS_stcpy :  cs_DirP = CS_stcpy (cs_Dir, C:\\\\MAPPING\\\\ );", 
            "title": "CS_altdr Alternate Directory"
        }, 
        {
            "location": "/userguide/libraryfunctions/#bugs", 
            "text": "The purpose of this function is to insulate the library from system implementation issues. Without a function of this nature, all applications using CS-MAP would have to implement a specific directory on a specific drive. Not very pleasant. There does not appear to be a nice clean solution to this problem.", 
            "title": "BUGS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_atof-ascii-to-floating-point", 
            "text": "Function CS_atof (ByRef result As Double,ByVal value As String) As Long\nfunction CS_atof (var result :double;value: PChar) :LongInt;\nlong CS_atof (double *result,Const char *value);  CS_atof  will convert the ASCII, null terminated string provided by the  value  argument to double precision floating point form, returning this result in the location pointed to by the  result  argument. Obviously, the string provided by  value  is expected to be an ASCII representation of a numeric value.  CS_atof  has several features built into it for handling numeric formats that are commonly used in mapping, specifically, large numbers, and values in degrees, minutes, and seconds format. Use of thousands separators is supported and, when present, their improper use is reported. Other than leading white space, spaces in the input value are interpreted to indicate degrees, minutes, and seconds format. Values can be entered using minutes only (a single space) or minutes and seconds (two spaces encountered). Use of either directional characters (i.e. N, S, E, W) or plus and hyphen characters for sign is also supported.  CS_atof  returns a long that carries a complete specification of the format used to enter the value, suitable for use by  CS_ftoa  for formatting the value for output.  CS_atof  will also correctly process scale factors entered as ratios, and this feature can be mixed with the thousands separator feature. Thus, scale reduction for state plane coordinate systems can be entered as \"1:17,000.\"  The return value is a bitmap of information used to contain precision, formatting specifications, and error status values. The following descriptions refer to constants defined in the various header files. Construct a format specification by inclusively or'ing the desired options:     Constant  Description      cs_ATOF_PRCMSK  The least significant five bits are used to indicate the number of digits found after the decimal point. The value is actually the number of digits plus one. (Zero is reserved to indicate automatic precision determination on output.) This constant is a mask that will mask out the precision value.    cs_ATOF_VALLNG  The value processed is acceptable for a longitude value.    cs_ATOF_VALLAT  The value processed is acceptable for a latitude value.    cs_ATOF_MINSEC  The value processed was in degrees, minutes, and seconds form.    cs_ATOF_MINUTE  The value processed was in degrees and minutes form.    cs_ATOF_EXPNT  The value processed was in scientific notation form.    cs_ATOF_COMMA  The value processed included thousands separators to the left of the decimal point.    cs_ATOF_DIRCHR  The value processed included directional characters to indicate sign.    cs_ATOF_XEAST  The directional characters used to indicate the sign came from the E and W set, as opposed to the N and S set.    cs_ATOF_MINSEC0  The value processed included leading zeros in the minutes or seconds fields.    cs_ATOF_DEG0  The value processed included leading zeros in the degrees field.    cs_ATOF_0BLNK  The value processed was the null string.    cs_ATOF_FORCE3  The value processed used minutes or minutes and seconds format, and 3 digits of degrees were encountered; implying a longitude value.    cs_ATOF_RATIO  The processed value was provided in the form of a ratio, e.g. 1:2500, to indicate a value such as, for example, 0.9996.     Bits defined by the following constants are set to indicate the associated error condition. The  cs_ATOF_FMTERR  bit is set if any error condition is detected and forces the return value to negative. In all such cases,  CS_atof  will report the error condition and a subsequent call to  CS_errmsg  will return an appropriate error message.     Constant  Description      cs_ATOF_SECS60  What was interpreted to be the seconds field of the processed value produced a value greater than or equal to 60.    cs_ATOF_MINS60  What was interpreted to be the minutes field of the processed value produced a value greater than or equal to 60.    cs_ATOF_MLTPNT  More than one decimal point was encountered in the input value.    cs_ATOF_MLTSGN  More than one sign indication was encountered in the input value.    cs_ATOF_ERRCMA  Improper positioning of the thousands separator character was detected in the input value.    cs_ATOF_RATERR  A string that contained the ratio character, usually ':', did not conform to the normal convention for a ratio. Usually, the character immediately left of the colon was not a '1'.    cs_ATOF_FMTERR  A general format error, not covered by the above, was encountered in the input value.    cs_ATOF_ERRFLG  This bit is set, producing a negative return value, if any of the above error conditions are encountered during processing. Whenever this bit is set, the error condition will have been reported to  CS_erpt , and a subsequent call to  CS_errmsg  will produce an appropriate error message.", 
            "title": "CS_atof Ascii to floating point"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_azddll-latlong-azimuth-distance-calculator", 
            "text": "Function CS_azddll ( ByVal e_rad As Double, ByVal e_sq As Double, ByRef ll_fromAs Double,\n                      ByVal azimuth As Double,\n                      ByVal distance As Double,\n                      ByRef ll_to As Double) As Integer\nfunction CS_azddl (e_rad, e_sq: Double; var ll_from: Double; azimuth, distance : Double; var ll_to: Double): Integer;\nint CS_azddl (double e_rad, double e_sq, double ll_from[3], double azimuth, double dist, double ll_to[3]);  CS_azddll  calculates the latitude and longitude of a target point given an initial point, an azimuth from the initial point, and a distance. The initial point and the result are in degrees, where the longitude occupies the first element in the array and latitude the second element. The reference of the longitude is immaterial, as both (the initial point and the calculated point) will share the same reference whatever it is. Currently, the third element in each array is unused (i.e. un-referenced and unmodified). This may change in future releases.  e_rad  is the equatorial radius, and  e_sq  the eccentricity squared, of the ellipsoid to be used. The units of the radius are immaterial other than they must be the same as that used to specify the  distance .  Azimuth  is the azimuth at the initial point given in degrees east of north.  distance  is the distance traveled in the same units as used to specify the equatorial radius of the ellipsoid. The result is returned in the array pointed to by the  ll_to  argument.  CS_azddll  returns a zero to indicate success, -1 for failure. Failure of the internal Newton Rhapson iterative calculation is the only possible cause of failure. This can be caused by rather strange input values, specifically values that would produce results that are antipodal to the initial point.  The algorithm used is known as: \"Solution of the geodetic inverse problem after T. Vincenty modified Rainsford's Method with Helmert's elliptical terms,\" whatever all that means. This algorithm is appropriate for any combination of points that are not antipodal.", 
            "title": "CS_azddll LatLong Azimuth Distance calculator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_azsphr-azimuth-on-a-sphere", 
            "text": "Function CS_azsphr (ByRef ll_1 As Double, ByRef ll_2 As Double) As Double\nfunction CS_azsphr (var ll_1, ll_2 :Double) : Double;\ndouble CS_azshpr (Const double ll0 [2],Const double ll1 [2]);  CS_azsphrl  returns the azimuth, in degrees east of north, from the geographic location given by  ll0  to the geographic location given by  ll1 . The calculation assumes a spherical earth, so a radius and eccentricity is not required.", 
            "title": "CS_azsphr Azimuth on a Sphere"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_cnvrg-convergence-function", 
            "text": "Function CS_cnvrg (ByVal cs_name As String, ByRef ll_ary As Double) As Double\nfunction CS_cnvrg (cs_name :PChar;var ll_ary :double) :Double;\ndouble CS_cnvrg (Const char *cs_name, Const double ll_ary [2]);  CS_cnvrg  returns the convergence angle of the coordinate system whose key name is provided by the  cs_name  argument, at the location provided by the  ll_ary  argument. The position provided by the  ll_ary  argument must be in longitude and latitude form, in degrees, where the first element of the array is the longitude and the second element of the array is the latitude. Use negative values for west longitude and south latitude. The returned value is in degrees, east of north.  CS_cnvrg  uses the same cache of coordinate system definitions as does  CS_cnvrt , therefore, the performance penalty of using this very simple function is not as great as one might expect.", 
            "title": "CS_cnvrg Convergence function"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors", 
            "text": "CS_cnvrg  will return a value of -360.0 (clearly a bogus value for a convergence angle) if an error is detected during the calculation. The most common cause of errors is an invalid coordinate system name.", 
            "title": "Errors"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_cnvrt-generalized-convert-function", 
            "text": "Function CS_cnvrt (ByVal src_cs As String,ByVal trg_cs As String, ByRef coord As Double) As Integer\nfunction CS_cnvrt (src_cs,trg_cs :PChar;var coord :double) :Integer;\nint CS_cnvrt (Const char *src_cs,Const char *trg_cs,double coord [3]);  CS_cnvrt  is in essence a High Level Interface to the CS_MAP library. Using this single function, one can convert coordinates from any defined system to any other. Simply provide the key name of the source system via the  src_cs  argument, and the key name of the destination coordinate system via the  trg_cs  argument, and  CS_cnvrt  will cause the coordinate in the array given by the  coord  argument is converted from the source system to the destination system.  CS_cnvrt  returns zero if the conversion completed successfully without incident. Otherwise, a CS-MAP error code value is returned (see  cs_map.h ).  CS_cnvrt  relies on a cache of coordinate systems, and for each conversion linearly searches the cache for the definitions of the two coordinate system definitions, and the datum conversion definition, it needs to perform its function. Thus, the performance penalty incurred from using this High Level Interface is not as great as one may think.  Currently, the third element of the  coord  argument is unused; but may be used in the future.", 
            "title": "CS_cnvrt generalized convert function"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_cnvrt3d-3d-generalized-convert-function", 
            "text": "Function CS_cnvrt3D (ByVal src_cs As String, ByVal dst_cs As String, ByRef coor d As Doubl e) As Integer\nfunction CS_cnvrt3D (src_cs,dst_cs :PChar; var coord :Double):Integer\nint CS_cnvrt3D (Const char *src_cs, Const char *dst_cs, double coord [3]);  CS_cnvrt3D  is in essence a High Level Interface with regard to three dimensional conversions. Using this single function, one can convert three dimensional coordinates from any defined system to any other. Simply provide the key name of the source system via the  src_cs  argument, and the key name of the destination coordinate system via the  dst_cs  argument, and  CS_cnvrt3D  will cause the coordinate in the array given by the  coord  argument to be converted from the source system to the destination system.  CS_cnvrt3D  returns a zero if the conversion completed successfully without incident. Otherwise, a CS_MAP error code value is returned.  CS_cnvrt3D  relies on a cache of coordinate systems, and for each conversion linearly searches the cache for the definitions of the two coordinate system definitions, and the datum conversion definition, it needs to perform its function. Thus, the performance penalty incurred from using this High Level Interface is not as great as one may think.  Use  CS_cnvrt3D  only when converting data maintained in a three dimensional database. Note that if the application is able to supply the returned Z value during an inverse calculation, the inverted result may not match the original values.", 
            "title": "CS_cnvrt3D 3D generalized Convert function"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csenum-coordinate-system-enumerator", 
            "text": "Function CS_csEnum ( ByVal index As Integer , ByVal key_name As String, ByVal size As Integer) As Integer\nfunction CS_csEnum(index: Integer; key_name: Pchar; size: Integer):Integer;\nint CS_csEnum(int index, char *key_name, int size);  CS_csEnum  is used to enumerate all coordinate systems in the Coordinate System Dictionary.  CS_csEnum  returns in the memory buffer pointer to by the  key_name  argument the key name of the  index 'th entry in the Coordinate System Dictionary.  CS_csEnum  will never write more than size bytes to the indicated location.  Index  is a zero based index; the index of the first entry in the Coordinate System Dictionary is zero.  CS_csEnum  returns a positive 1 to indicate success. If  index  is too large, a zero is returned.", 
            "title": "CS_csEnum Coordinate System Enumerator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_1", 
            "text": "CS_csEnum  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_CSDICT  The Coordinate System Dictionary could not be found or otherwise opened. See CS_altdr.    cs_IOERR  A physical I/O error occurred in accessing the Coordinate System Dictionary.    cs_CS_BAD_MAGIC  The file assumed to be the Coordinate System Dictionary by virtue of its name was not a Coordinate System Dictionary; it had an invalid magic number or was of an incompatible release level.    cs_INV_INDX  The index argument was negative.", 
            "title": "Errors"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csisvalid-coordinate-system-key-name-is-valid", 
            "text": "Function CS_csIsValid (ByVal key_name As String) As Integer\nfunction CS_csIsValid (key_name: PChar) :Integer;\nint CS_csIsValid (Const char *key_name);  CS_csIsValid  is used to validate coordinate system key names.  CS_csIsValid  returns a positive 1 if  key_name  is a valid coordinate system key name, a zero if not.", 
            "title": "CS_csIsValid Coordinate System key name Is Valid"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_2", 
            "text": "CS_csEnum  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_CSDICT  The Coordinate System Dictionary could not be found or otherwise opened. (See  CS_altdr .)    cs_IOERR  A physical I/O error occurred in accessing the Coordinate System Dictionary.    cs_CS_BAD_MAGIC  The file assumed to be the Coordinate System Dictionary by virtue of its name was not a Coordinate System Dictionary; it had an invalid magic number. This can also be caused by an incompatible release.", 
            "title": "Errors"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csrangeenum-coordinate-system-useful-range-enumerator", 
            "text": "Function CS_csRangeEnum (ByVal index As Integer, ByVal csKeyName As String,\nByVal size As Integer) As Integer\nfunction CS_csRangeEnum(index: Integer; csKeyName: Pchar; size: Integer):Integer;\nint CS_csRangeEnum (int index, char * csKeyName, int size);  CS_csRangeEnum  is used to enumerate all coordinate systems which were located by the last call to the  CS_csRangeEnumSetup  function. Using these two functions, it is possible to obtain a list of only those coordinate systems whose useful range include a specific point.  CS_csRangeEnum  returns in the memory buffer pointer to by the key_name argument the key name of the  index 'th entry in the list generated by  CS_csRangeEnumSetup .  CS_csRangeEnum  will never write more than  size  bytes to the indicated location.  Index  is a zero based index; the index of the first entry in the Coordinate System Dictionary is zero.  CS_csEnum  returns a positive 1 to indicate success. If  index  is too large, a zero is returned. A negative value is returned for a serious error, such as failure to call  CS_csRangeEnumSetup  prior to calling this function.", 
            "title": "CS_csRangeEnum Coordinate System Useful Range Enumerator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csrangeenumsetup-coordinate-system-range-enumeration-setup", 
            "text": "Function CS_csRangeEnumSetup (ByVal longitude As Double, ByVal latitude As Double) As Integer\nfunction CS_csRangeEnumSetup (longitude, latitutde :Double) : Integer\nint CS_csRangeEnumSetup (double longitude, double latitude);  Use this function to set the base location for subsequent  CS_csEnumRange  usage. That is, use this function to produce (internally) a list of all coordinate systems whose useful range includes the given location. Essentially, this function will generate the list, and the application programmer then uses the  CS_csEnumRange  function to enumerate the list.  The location is specified in geographical terms (i.e. latitude and longitude). These values must be in degrees, relative to Greenwich. Since datum differences are on the order of, at most, a few hundred meters, the datum upon which these coordinates are based is immaterial for the purpose of this function.  CS_csRangeEnumSetup  will return a negative value in the event of a serious error, such as being unable to access the Coordinate System Dictionary. Use  CS_errmsg  to get a textual description of the error which can be reported to the application user. Otherwise,  CS_csRangeEnumSetup  will return the number of coordinate systems located, which can be zero.  Finally, note that the  CS_recvr  function will recover all allocated resources, including the list of coordinate systems generated by the last call to this function.", 
            "title": "CS_csRangeEnumSetup Coordinate System Range Enumeration Setup"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_dtenum-datum-enumerator", 
            "text": "Function CS_dtEnum(ByVal index As Integer, ByVal key_name As String, ByVal size As Integer) As Integer\nfunction CS_dtEnum(index: Integer; key_name: Pchar; size: Integer) :Integer;\nint CS_dtEnum(int index, char *key_name, int size);  CS_dtEnum  is used to enumerate all datums in the Datum Dictionary.  CS_dtEnum  returns in the memory buffer pointer to by the  key_name  argument the key name of the  index 'th entry in the Datum Dictionary.  CS_dtEnum  will never write more than  size  bytes to the indicated location.  Index  is a zero based index; the index of the first entry in the Datum Dictionary is zero.  CS_dtEnum  returns a positive 1 to indicate success. If  index  is too large, a zero is returned.", 
            "title": "CS_dtEnum Datum Enumerator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_3", 
            "text": "CS_dtEnum  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_DTDICT  The Datum Dictionary could not be found or otherwise opened. (See  CS_altdr .)    cs_IOERR  A physical I/O error occurred in accessing the Datum Dictionary.    cs_DT_BAD_MAGIC  The file assumed to be the Datum Dictionary by virtue of its name was not a Datum Dictionary; it had an invalid magic number. This can also be caused by a dictionary file of an incompatible release.    cs_INV_INDX  The index argument was negative.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_dtisvalid-datum-key-name-is-valid", 
            "text": "Function CS_dtIsValid (ByVal key_name As String) As Integer\nfunction CS_dtIsValid (key_name: PChar): Integer;\nint CS_dtIsValid (Const char *key_name);  CS_dtIsValid  is used to validate datum key names.  CS_dtIsValid  returns a positive 1 if  key_name  is a valid datum key name, a zero if not.", 
            "title": "CS_dtIsValid Datum key name is valid"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_4", 
            "text": "CS_dtIsValid  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_DTDICT  The Datum Dictionary could not be found or otherwise opened. (See  CS_altdr .)    cs_IOERR  A physical I/O error occurred in accessing the Datum Dictionary.    cs_DT_BAD_MAGIC  The file assumed to be the Datum Dictionary by virtue of its name was not a Datum Dictionary; it had an invalid magic number. This can also be caused by a dictionary file of an incompatible release.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_elenum-ellipsoid-enumerator", 
            "text": "Function CS_elEnum(ByVal index As Integer, ByVal key_name As String, ByVal size As Integer) As Integer\nfunction CS_elEnum(index: Integer; key_name: Pchar; size: Integer): Integer;\nint CS_elEnum(int index, char *key_name, int size);  CS_elEnum  is used to enumerate all ellipsoids in the Ellipsoid Dictionary.  CS_elEnum  returns in the memory buffer pointer to by the  key_name  argument the key name of the  index 'th entry in the Ellipsoid Dictionary.  CS_elEnum  will never write more than size bytes to the indicated location.  Index  is a zero based index; the index of the first entry in the Ellipsoid Dictionary is zero.  CS_elEnum  returns a positive 1 to indicate success. If  index  is too large, a zero is returned.", 
            "title": "CS_elEnum Ellipsoid Enumerator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_5", 
            "text": "CS_elEnum  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_ELDICT  The Ellipsoid Dictionary could not be found or otherwise opened. (See  CS_altdr .)    cs_IOERR  A physical I/O error occurred in accessing the Ellipsoid Dictionary.    cs_DT_BAD_MAGIC  The file assumed to be the Ellipsoid Dictionary by virtue of its name was not an Ellipsoid Dictionary; it had an invalid magic number. Note that dictionary magic numbers can be different for different releases.    cs_INV_INDX  The index argument was negative.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_elisvalid-ellipsoid-key-name-is-valid", 
            "text": "Function CS_elIsValid (ByVal key_name As String) As Integer\nfunction CS_elIsValid (key_name: PChar): Integer;\nint CS_elIsValid (Const char *key_name);  CS_elIsValid  is used to validate ellipsoid key names.  CS_elIsValid  returns a positive 1 if  key_name  is a valid ellipsoid key name, a zero if not.", 
            "title": "CS_elIsValid Ellipsoid key name is valid"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_6", 
            "text": "CS_elIsValid  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_ELDICT  The Ellipsoid Dictionary could not be found or otherwise opened. (See  CS_altdr .)    cs_IOERR  A physical I/O error occurred in accessing the Ellipsoid Dictionary.    cs_EL_BAD_MAGIC  The file assumed to be the Ellipsoid Dictionary by virtue of its name was not a Ellipsoid Dictionary; it had an invalid magic number. Note that magic numbers can be different for different releases.", 
            "title": "Errors"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_errmsg-error-message", 
            "text": "Sub CS_errmsg (ByVal my_bufr As String, ByVal bufr_size As Integer)\nprocedure CS_errmsg (msg_bufr: PChar; bufr_size: Integer);\nvoid CS_errmsg (char msg_bufr, int bufr_size);  CS_errmsg  returns to the calling function a null terminated string which describes the last error condition detected by the CS_MAP library. The result is returned in the buffer pointed to by the  msg_bufr  argument, which is assumed to be  bufr_size  bytes long. The message is returned in one character per byte ANSI code characters.  CS_errmsg  will return the null string if called before any error condition is detected.", 
            "title": "CS_errmsg Error Message"
        }, 
        {
            "location": "/userguide/libraryfunctions/#bugs_1", 
            "text": "After returning an error message to the user,  CS_errmsg  should reset itself to the null string preventing the same error message from being returned a second time. It should, but it doesn't.", 
            "title": "BUGS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_erpt-error-report", 
            "text": "extern int cs_Error,cs_Errno;\nvoid CS_erpt (int err_num);  CS_erpt  is called by all functions in the Coordinate System Mapping Package whenever an error condition is detected. The value of  err_num  indicates the specific error condition detected and  must  be one of the manifest constants defined in  cs_map.h .  At the current time,  CS_erpt  does nothing other than set the value of global variable  cs_Error  to the supplied value of  err_num  and set the global variable of  cs_Errno  to the current value of the system's global variable  errno .  It is expected that users will want to write their own  CS_erpt  function that will properly inform the operator of the nature of the problem encountered.  Each function in the Coordinate System Mapping Package is programmed to clean up after itself after return from  CS_erpt . That is, upon return from  CS_erpt , all memory  malloc 'ed by the function detecting the error is  free 'ed and any temporary file created by the function detecting the error is removed.", 
            "title": "CS_erpt Error Report"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_fast-fast-mode", 
            "text": "Sub CS_fast(ByVal fast As Integer)\nprocedure CS_fast(fast: Integer);\nvoid CS_fast(int fast);  CS_fast  can be used to improve the performance of applications using the High Level Interface. When incorporated into a DLL, the High Level Interface normally verifies the veracity of each pointer argument provided by the application. This is convenient, of course, but also somewhat time consuming. Calling  CS_fast  with a non-zero value for the fast argument will disable this checking. It is recommended that calling  CS_fast  be added to your application only after it has been debugged. Fast mode can be turned off by calling  CS_fast  with\nargument fast set to zero.", 
            "title": "CS_fast FAST mode"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_ftoa-floating-point-to-ascii", 
            "text": "Function CS_ftoa(ByVal buffer As String, ByVal size As Integer, ByVal value As Double, ByVal format As Long) As Long\nfunction CS_ftoa buffer: Pchar; size: Integer; value: Double; format: Longint) :Longint;\nlong CS_ftoa(char *buffer, int size, double value, long format);  CS_ftoa  formats the double precision floating point value provided by the  value  argument into ASCII form returning the result in the character array pointed to by the  buffer  argument. The result is always a null terminated string, and the length of the string is never longer than  size  - 1 characters. The format of the character string is controlled by the  format  argument.  CS_ftoa  returns a long that indicates the actual format used to format the value. The returned format specification may be different from the requested format if the buffer provided was not large enough, or if the requested format is not appropriate for the value provided.  CS_ftoa  is intended to be a generalized formatting function that accommodates the formats commonly used in mapping. That is, large numbers and values in degrees minutes and seconds form. The somewhat awkward  format  argument is designed such that the value returned by  CS_atof  is suitable for use by  CS_ftoa .  The original intent behind the design of the format specification was to enable users to indicate the desired format of output by simply entering a suitable value in the form they desire. The application would then use  CS_atof  to convert the value to binary form. If no errors occurred during the conversion, the returned long could then be used to format output. Experience will determine the success of this approach.  The  format  argument is a bitmap of information used to contain precision, formatting specifications, and error status values. The following descriptions refer to constants defined in the various header files. Construct a format specification by inclusively or'ing the desired options.     Constant  Description      cs_ATOF_PRCMSK  The least significant five bits are used to indicate the number of digits to be produced after the decimal point. The value is actually the number of desired digits plus one. Zero indicates that the precision is to be calculated automatically. This constant is a mask that will mask out the precision value.    cs_ATOF_MINSEC  Output is to be in degrees, minutes, and seconds form.    cs_ATOF_MINUTE  Output is to be in degrees and minutes form.    cs_ATOF_EXPNT  This bit is set in the returned value if  CS_ftoa  had to resort to scientific notation in order to format the value in the space provided.    cs_ATOF_OVRFLW  This bit is set in the returned value if  CS_ftoa  could only output the overflow indication (i.e.  . ) in the space provided.    cs_ATOF_COMMA  Output is to include thousands separators to the left of the decimal point as appropriate.    cs_ATOF_DIRCHR  Output is to include directional characters to indicate the sign of the numbers rather than plus or minus signs.    cs_ATOF_XEAST  Meaningful only when the  cs_ATOF_DIRCHR  bit is set. Indicates that character set used to indicate positive or negative are E and W as opposed to N and S.    cs_ATOF_MINSEC0  Output is to include leading zeros in the minutes and seconds fields instead of leading spaces.    cs_ATOF_DEG0  Output is to include leading zeros in the degrees field rather than spaces.    cs_ATOF_0BLNK  Output a null string if the provided value is zero.    cs_ATOF_FORCE3  Used to force at least three character output in the degree field. Usually used when formatting a longitude.    cs_ATOF_RATIO  Output the result in a ratio format, e.g. 1:2500. Can be used in conjunction with  cs_ATOF_COMMA  to get something like 1:2,500.", 
            "title": "CS_ftoa floating point TO Ascii"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_geoctrsetup-geocentric-setup", 
            "text": "Function CS_geoctrSetUp (ByVal ellipsoid As String) As Integer\nfunction CS_geoctrSetUp (ellipsoid: PChar): Integer;\nint CS_geoctrSetUp (const char *ellipsoid);  Use this function to specify the ellipsoid definition that is to be used in geocentric coordinate calculations. The ellipsoid argument must be the key name of an  ellipsoid  defined in the ellipsoid dictionary. Zero is returned on success, -1 on error. Errors are usually caused by invalid ellipsoid names.", 
            "title": "CS_geoctrSetUp Geocentric setup"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_geoctrgetxyz-geocentric-get-xyz", 
            "text": "Function CS_geoctrGetXyz (ByRef xyz As Double, ByRef llh As Double) As Integer\nfunction CS_geoctrGetXyz (var xyz, llh: Double): Integer;\nint CS_geoctrGetXyz (double xyz[3], double llh[3]);  Given the geographic coordinates of a point via the  llh  argument,  CS_geoctrGetXyz  returns the corresponding geographic coordinate in the array indicated by the  xyz  argument. Use the  CS_geoctrSetUp  to specify the ellipsoid that is to be used in the calculation. Note that the returned geocentric coordinates will be in meters, and the third element of the  llh  argument is considered to be the ellipsoidal height in meters.  CS_geoctrGetXyz  returns zero on success and \u20131 on failure. Failure can be caused by failing to specify an ellipsoid by calling  CS_geoctrSetUp , or providing a bogus set of geographic coordinates.", 
            "title": "CS_geoctrGetXyz Geocentric get XYZ"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_geoctrgetllh-geocentric-get-latlonghgt", 
            "text": "Function CS_geoctrGetLlh (ByRef llh As Double, ByRef xyz As Double) As Integer\nfunction CS_geoctrGetLlh (var llh, xyz :Double): Integer;\nint CS_geoctrGetLlh (double llh[3], double xyz[3]);  Given the geocentric coordinates of a point via the  xyz  argument,  CS_geoctrGetLlh  returns the corresponding geographic coordinate in the array indicated by the  llh  argument. Use the  CS_geoctrSetUp  to specify the ellipsoid that is to be used in the calculation. Note that the geocentric coordinates must be in meters, and the height (i.e. the third element of the  llh  result) is the ellipsoidal height in meters.  CS_geoctrGetLlh  returns zero on success and \u20131 on failure. Failure can be caused by failing to specify an ellipsoid by calling  CS_geoctrSetUp , or providing a bogus set of geocentric coordinates.", 
            "title": "CS_geoctrGetLlh Geocentric get LatLongHgt"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_getcountyfips-get-county-federal-information-processing-standard-code", 
            "text": "Function CS_getCountyFips ( ByVal stateFips As Integer , ByVal count yName As String) As Integer\nfunction CS_getDataDirectory (stateFips :Integer; countyName :PChar) : Integer;\nint CS_getCountyFips ( int stateFips, Const char * count yName);  This function returns the Federal Information Processing Standard code value assigned to a county indicated by the  countyName  argument. This is appropriate for the US only. You can obtain the appropriate value for the  stateFips  argument by using  CS_getStateFips . Note, that countyName must be the complete official name of the county without any punctuation. The lookup procedure is NOT case sensitive. The function returns zero if the information provided by the two arguments fails to produce a county code.", 
            "title": "CS_getCountyFips Get County Federal Information Processing Standard code"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_getdatadirectory-get-data-directory", 
            "text": "Function CS_getDataDirectory (ByVal data_dir As String, ByVal dir_sz As Integer) As Integer\nfunction CS_getDataDirectory (data_dir: PChar; dir_sz: Integer): Integer;\nint CS_getDataDirectory (char *data_dir, int dir_sz);  CS_getDataDirectory  will return in the character array pointed to by the  data_dir  argument the full path to the directory it is searching for supporting data file. It will always return a null terminated string, but never write more than  dir_sz  characters to the array.  CS_getDataDirectory  will return  TRUE  if the directory returned does indeed contain a Coordinate System Dictionary file (i.e. a file named COORDSYS).", 
            "title": "CS_getDataDirectory GET DATA DIRECTORY"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_getdatumof-get-datum-of-a-coordinate-system", 
            "text": "Function CS_getDatumOf ( ByVal csKeyName As String, ByVal datumName As String, ByVal size As Integer) As Integer\nfunction CS_getDatumOf (csKeyName, datumName: PChar; size: Integer) : Integer;\nint CS_get DatumOf ( Const char * csKeyName, char * datumName, int size);  Use this function to obtain the key name of the datum assigned to the coordinate system whose key name is provided by the  csKeyName  argument. The datum key name is returned in the string pointed to by the  datumName  argument.  CS_getDatumOf  will never write more than size characters to the  datumName  string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. The string at  datumName  will be the empty string if the coordinate system referred to is cartographically referenced (i.e. referenced directly to an ellipsoid).", 
            "title": "CS_getDatumOf Get Datum of a Coordinate System"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_getdescriptionof-get-description-of-a-coordinate-system", 
            "text": "Function CS_getDescriptionOf ( ByVal csKeyName As String, ByVal description As String,\nByVal size As Integer) As Integer\nfunction CS_getDescriptonOf (csKeyName, description :PChar; size :Integer) : Integer;\nint CS_getDescriptionOf (Const char *csKeyName, char *description, int size);  Use this function to obtain the description the coordinate system whose key name is provided by the  csKeyName  argument. The description is returned in the string pointed to by the description argument.  CS_get DescriptionOf  will never write more than  size  characters to the  datumName  string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. Note that description field of a coordinate system definition is limited to 63 characters, and  size  is typically 64 (to accommodate for the null terminating character used in C).", 
            "title": "CS_getDescriptionOf Get Description of a Coordinate System"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_getellipsoidof-get-ellipsoid-of-a-coordinate-system", 
            "text": "Function CS_getEllipsoidOf ( ByVal csKeyName As String, ByVal ellipsoidName As String, ByVal size As Integer) As Integer\nfunction CS_getEllipsoidOf (csKeyName, ellipsoidName: PChar; size :Integer) :Integer;\nint CS_getEllipsoidOf (Const char *csKeyName, char *ellipsoidName, int size);  Use this function to obtain the ellipsoid referenced by the coordinate system whose key name is provided by the  csKeyName  argument. The ellipsoid key name is returned in the string pointed to by the  ellipsoidName  argument.  CS_getEllipsoidOf  will never write more than size characters to the  ellipsoidName  string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. Note that key names are limited to 23 characters, and  size  is typically 24 (to accommodate for the null terminating character used in  This function usually returns the empty string as most coordinate systems are referenced to a datum rather than an ellipsoid. Use this function only in those cases where the  CS_getDatumOf  function returns the empty string, indicating a coordinate system which is cartographically referenced.", 
            "title": "CS_getEllipsoidOf Get Ellipsoid Of a Coordinate System"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_getreferenceof-get-reference-of-a-coordinate-system", 
            "text": "Function CS_getReferenceOf ( ByVal csKeyName As String, ByVal reference As String, ByVal size As Integer) As Integer\nfunction CS_getReferenceOf ( csKeyName, reference : PChar; size :Integer) :Integer;\nint CS_getReferenceOf (Const char *csKeyName, char *reference, int size);  Use this function to obtain an ASCII representation of what the coordinate system referenced by the  csKeyName  argument is referenced to. This operates correctly for both geodetic and cartographic references. The returned ASCII string will include an indication of the type of reference, and also the keyname involved. The reference description is returned in the string pointed to by the  reference  argument. CS_getRefernceOf will never write more than  size  characters to the  reference  string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. 32 is a customary value for the  size  argument. A geodetic reference looks something like:  Datum: WGS84 .", 
            "title": "CS_getReferenceOf Get Reference Of a Coordinate System"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_getsourceof-get-source-of-coordinate-system", 
            "text": "Function CS_getSourceOf ( ByVal csKeyName As String, ByVal source As String, ByVal size As Integer) As Integer\nfunction CS_getSourceOf (csKeyName, source: PChar; size: Integer): Integer;\nint CS_getSourceOf (Const char *csKeyName,char *source,int size);  Use this function to obtain the source of information field of the coordinate system definition whose key name is provided by the  csKeyName  argument. The source information is returned in the string pointed to by the source argument.  CS_getSourceOf  will never write more than  size  characters to the  source  string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. Note that source of information field of a coordinate system definition is limited to 63 characters, and  size  is typically 64 (to accommodate for the null terminating character used in C).", 
            "title": "CS_getSourceOf Get Source Of Coordinate System"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_getunitsof-get-units-of-a-coordinate-system", 
            "text": "Function CS_getUnitsOf (ByVal csKeyName As String,ByVal units As String, ByVal size As Integer) As Integer\nfunction CS_getUnitsOf (csKeyName, units: PChar; size: Integer) :Integer;\nint CS_getUnitsOf (Const char *csKeyName, char *units, int size);  Use this function to obtain the key name of the units of the coordinate system definition whose key name is provided by the  csKeyName  argument. The unit key name is returned in the string pointed to by the  units  argument.  CS_ge UnitsOf  will never write more than  size  characters to the  units  string. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid coordinate system key name. Note that unit key name field of a coordinate system definition is limited to 23 characters, and  size  is typically 24 (to accommodate for the null terminating character used in C).", 
            "title": "CS_getUnitsOf Get Units of a Coordinate System"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_getelvalues-get-ellipsoid-values", 
            "text": "Function CS_getElValues ( ByVal elKeyName As String, ByRef eRadius As Double, ByRef eSquared As Double) As Integer\nfunction CS_getElVal ues ( elKeyName: PChar ; var eRadius, eSquared : Double) : Integer;\nint CS_getElValues ( Const char * el KeyName, double * eRadius, double * eSquared ;  Use this function to obtain the equatorial radius and the eccentricity squared values for the ellipsoid referenced by  elKeyName  argument. The appropriate values are returned in the double variables pointed to by the  eRadius  and  eSquared  arguments.. A zero value is returned for success, and -1 for failure. Failure is almost always caused by providing an invalid ellipsoid key name. Note that the value returned in  eRadius  is the equatorial radius and is always in meters. The value returned in the  eSquared  variable is unit less, and will be zero if the ellipsoid definition referenced by the  elKeyName  argument is actually the definition of a sphere.", 
            "title": "CS_getElValues Get Ellipsoid Values"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_getcurvatureat-get-curvature-at-specified-latitude", 
            "text": "Function CS_getCurvatureAt ( ByVal csKeyName As String, ByVal latitude As Double) As Double\nfunction CS_getCurvatureAt (csKeyName, source: PChar; latitude: double) : Double;\ndouble CS_getCurvatureAt ( Const char * csKeyName, double latitude);  This function uses the ellipsoid underlying the coordinate system definition indicated by the  csKeyName  argument, and computes the Gaussian curvature at the specified  latitude . The key name argument must be that of a coordinate system definition, and the latitude argument is specified in degrees.  The function returns a hard zero in the event of an error, which can be caused by providing an invalid coordinate system key name. The latitude argument is not checked and used as is, since only the sine of the latitude is necessary for the calculation (and all real values have, technically, a sine value).", 
            "title": "CS_getCurvatureAt get curvature at specified latitude"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_isgeo-is-geographic", 
            "text": "Function CS_isgeo (ByVal key_nmAs String) As Integer\nfunction CS_isgeo (key_nm: PChar): Integer;\nint * CS_isgeo (Const char * key_nm);  CS_isgeo  will check the coordinate system definition with the key name indicated by the  key_nm  argument and return +1 (i.e. TRUE) if the coordinate system does return geographic coordinates. A zero is returned if the named coordinate system is not geographic. CS_isgeo  returns a negative value in the event of a hard error. The most frequent cause of a hard error is providing an invalid coordinate system name.", 
            "title": "CS_isgeo is geographic"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_llazdd-latlong-to-azimuth-and-distance-calculator", 
            "text": "Function CS_llazdd(ByVal e_rad As Double, ByVal e_sq As Double, ByRef ll_from As Double, ByRef ll_to As Double, ByRef dist As Double) As Double\nfunction CS_llazdd(e_rad, e_sq: Double; var ll_from, ll_to: Double; var dist: Double): Double;\ndouble CS_llazdd (double e_rad, double e_sq, Const double ll_from[2], Const double ll_to [2], double *dist);  CS_llazdd  returns the ellipsoidal azimuth and distance between two points on the surface of an ellipsoid specified in terms of latitude and longitude.  e_rad  specifies the equatorial radius and  e_sq  specifies the square of the eccentricity of the ellipsoid. The returned azimuth is calculated from the location specified by  ll_from  to that specified by  ll_to , and the distance between the two points is returned at the location pointed to by  dist . The units of the returned distance are the same as those used to specify the equatorial radius.  Latitude and longitude values are in degrees where the first element in each array is the longitude and the second element is the latitude. West longitude and south latitude are negative.  The algorithm used is known as: \"Solution of the geodetic inverse problem after T. Vincenty modified Rainsford's Method with Helmert's elliptical terms.\"", 
            "title": "CS_llazdd Lat/Long to Azimuth and Distance calculator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_7", 
            "text": "CS_llazdd  makes no checks for possible errors. The algorithm used is appropriate for any combination of points that are not antipodal. That is, the points used must not be exactly opposite each other, i.e. on the endpoints of a straight line that passes through the center of the earth.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_llfrommgrs-calculate-latlong-from-mgrs", 
            "text": "Function CS_mgrsFromLl(ByRef latLng As Double, ByVal mgrs As String) As Integer\nfunction CS_mgrsFromLl(var latLng: Double; mgrs: PChar) :Integer;\ndouble CS_mgrsFromLl (double latLng[2], const char *mgrs);  CS_llFromMgrs  returns in the array indicated by the  latLng  argument the geographic coordinate equivalent of the MGRS (Military Grid Reference System) string provided by the  mgrs  argument. This function is aware of the poles and the rather strange stuff that happens in the northern Europe.  CS_llFromMgrs  returns a zero for success, and \u20131 for failure. Failure can be caused by failing to call the  CS_mgrsSetUp  prior to calling  CS_llFromMgrs  or providing an invalid MGRS string.", 
            "title": "CS_llFromMgrs calculate Lat/Long from MGRS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_mgrsfromll-calculate-mgrs-from-latlong", 
            "text": "Function CS_mgrsFromLl(ByVal mgrs As String, ByRef latLng As Double, ByVal precision As Integer) As Integer\nfunction CS_mgrsFromLl(mgrs :PChar; var latLng :Double; precision :Integer) : Integer;\ndouble CS_mgrsFromLl (char *mgrs, double latLng [2], int precision);  CS_mgrsFromLl  returns the MGRS (Military Grid Reference System) equivalent of the geographic position provided by the  latLng  argument in the character array (string) indicated by the  mgrs  argument. The  precision  of the result is controlled by the precision argument that must have a value between 1 and 5 (inclusive). The result array is assumed to be at least 16 bytes in length. The  latLng  argument must adhere to the convention established for internal coordinates. This function is aware of the poles and the rather strange stuff that happens in the northern Europe.  CS_mgrsFromLl  returns a zero for success, and \u20131 for failure. Failure can be caused by failing to call the  CS_mgrsSetUp  prior to calling  CS_mgrsFromLl  or providing an invalid geographic coordinate.", 
            "title": "CS_mgrsFromLl calculate MGRS from Lat/Long"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_mgrssetup-mgrs-setup", 
            "text": "Function CS_mgrsSetUp (ByVal ellipsoid As String, ByVal bessel As Integer) As Integer\nfunction CS_mgrsSetUp (ellipsoid: PChar; bessel: Integer): Integer;\ndouble CS_mgrsSetUp (const char* ellipsoid, int bessel);  Use the  CS_mgrsSetUp  to specify the ellipsoid that is to be used in the MGRS (Military Grid Reference System) calculations. Use the  ellipsoid  argument to provide the key name of the ellipsoid definition that is to be used. There are two alphabetic code sequences used with MGSR. A zero value for the  bessel  argument causes the normal code sequence to be used, a value of +1 indicates that the code sequence associated with the Bessel ellipsoid is to be used.  CS_mgrsFromLl  returns a zero for success, and \u20131 for failure. Failure is usually caused by a invalid ellipsoid name.", 
            "title": "CS_mgrsSetUp MGRS setup"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_recvr-recover-resources", 
            "text": "Sub CS_recvr\nprocedure CS_recvr;\nvoid CS_rcvr (void);  CS_rcvr  will release all system resources allocated by use of the single function user interface functions  CS_cnvrt ,  CS_cnvrg , and  CS_scale . It essentially frees up the coordinate system cache and the datum conversion cache established by these functions to enhance performance.", 
            "title": "CS_recvr recover resources"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_scale-grid-scale-factor-function", 
            "text": "Function CS_scale (ByVal cs_name As String, ByRef ll As Double) As Double\nfunction CS_scale (cs_name: PChar; var ll :Double): Double;\ndouble CS_scale (Const char *cs_name, double ll[2]);  CS_scale  returns the grid scale factor of the coordinate system whose key name is provided by the  cs_name  argument, at the location provided by the  ll  argument. The position provided by the  ll  argument  must  be in longitude and latitude form, in degrees, where the first element of the array is the longitude and the second element of the array is the latitude. Use negative values for west longitude and south latitude. The returned value is the grid scale factor.  CS_scale  uses the same cache of coordinate system definitions as does  CS_cnvrt , therefore, the performance penalty of using this very simple function is not as great as one might expect.  In the case of a conformal projection, the K and H scale factors are the same; there is no ambiguity. For non-conformal projections, however, the K and H functions are not the same. In these cases, this function will return the more interesting of the two factors. For example, for the Equidistant Conic, the K factor is always 1.0, and this function would return the H factor for this projection.", 
            "title": "CS_scale grid SCALE factor function"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_8", 
            "text": "CS_scale  will return a negative one (i.e. -1.0) if an error occurs. Providing an invalid coordinate system name is the most common source of error.  C## S_scalh grid scale factor(H) function  Function CS_scalh (ByVal cs_name As String, ByRef ll As Double) As Double\nfunction CS_scalh (cs_name: PChar; var ll: Double) :Double;\ndouble CS_scalh (Const char *cs_name, double ll[2]);  CS_scalh  returns the grid scale factor along a meridian of the coordinate system whose key name is provided by the  cs_name  argument, at the location provided by the  ll  argument. The position provided by the  ll  argument  must  be in longitude and latitude form, in degrees, where the first element of the array is the longitude and the second element of the array is the latitude. Use negative values for west longitude and south latitude. The returned value is the grid scale factor.  CS_scalh  uses the same cache of coordinate system definitions as does  CS_cnvrt , therefore, the performance penalty of using this very simple function is not as great as one might expect.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_9", 
            "text": "CS_scalh  will return a negative one (i.e. -1.0) if an error occurs. Providing an invalid coordinate system name is the most common source of error.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_scalk-grid-scale-factork-function", 
            "text": "Function CS_scalk (ByVal cs_name As String, ByRef ll As Double) As Double\nfunction CS_scalk (cs_name: PChar; var ll: Double): Double;\ndouble CS_scalk (Const char *cs_name, double ll[2]);  CS_scalk  returns the grid scale factor along a parallel of the coordinate system whose key name is provided by the  cs_name  argument, at the location provided by the  ll  argument. The position provided by the  ll  argument  must  be in longitude and latitude form, in degrees, where the first element of the array is the longitude and the second element of the array is the latitude. Use negative values for west longitude and south latitude. The returned value is the grid scale factor.  CS_scalk  uses the same cache of coordinate system definitions as does  CS_cnvrt , therefore, the performance penalty of using this very simple function is not as great as one might expect.", 
            "title": "CS_scalk grid SCALE factor(K) function"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_10", 
            "text": "CS_scalk  will return a negative one (i.e. -1.0) if an error occurs. Providing an invalid coordinate system name is the most common source of error.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_sethelppath-set-help-path", 
            "text": "Function CS_setHelpPath (ByVal helpPath As String) As Integer\nfunction CS_setHelpPath (helpPath: PChar): Integer;\nint CS_setHelpPath (const char *helpPath);  Use the  CS_setHelpPath  function to set the directory that you desire to have CS-MAP search when seeking the MFC dialog help file. The  helpPath  argument must point to a null terminated string that carries the full path to the desired directory.  CS_setHelpPath  returns +1 (i.e. TRUE) if a properly named file exists in the indicated directory. Zero (i.e. FALSE) is returned if such a file does not exist.", 
            "title": "CS_setHelpPath SET HELP PATH"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_spzonenbrmap-state-plane-zone-number-mapper", 
            "text": "Function CS_spzone (ByValue csKeyName As String,ByVal is83 As Integer) As Integer\nfunction CS_spzone (csKeyName: PChar; is83: Integer): Integer\nint CS_spzone (char *csKeyName, int is83);  CS_spZoneNbrMap  examines the character array provided by the  csKeyName  argument and if it determines that the array contains a valid state plane zone number specification, the contents of the array is replaced with the appropriate corresponding coordinate system key name. If the  is83  parameter is non-zero, the zone number is interpreted as a NAD83 zone number. Otherwise, the zone number is interpreted as a NAD27 zone number.  If the original content of the character array pointed to be the  csKeyName  argument is not a valid state plane zone number, the contents of the array remains unchanged.  CS_spZoneNbrMap  returns 0 if a substitution was made. A positive one is returned if a substitution was not made because the value passed was not considered to be a valid state plane zone number. Minus one is returned if the original passed value is close to a state plane zone number (i.e. consisted of three or four digits), but did not match a valid state plane zone number.", 
            "title": "CS_spZoneNbrMap State Plane Zone Number Mapper"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_unenum-units-enumerator", 
            "text": "Function CS_unEnum(ByVal ByVal ByVal index As Integer,ByVal type As Integer, key_name As String, name_sz As Integer) As Integer\nfunction CS_unEnum(index, type: Integer; key_name: Pchar; name_sz: Integer): Integer;\nint CS_unEnum(int index, int type, char *key_name, int nm_size);  CS_unEnum  is used to enumerate all units of a specific type in the CS-MAP units table.  CS_unEnum  returns in the memory buffer pointer to by the  key_name  argument the name of the  index 'th entry in the unit table of the type specified by the type argument.  CS_unEnum  will never write more than  nm_size  bytes to the indicated location. Index is a zero based index; the index of the first entry in the unit table is zero.  Currently, only two types of units supported, length and angular measure. Manifest constants defined in the  cs_map.h  header file are used to distinguish the desired type. These are  cs_UTYP_LEN , for linear units, and  cs_UTYP_ANG , for angular units. The  type  argument must be one of these values.  CS_unEnum  returns a positive 1 to indicate success. If  index  is too large, a zero is returned.", 
            "title": "CS_unEnum Units Enumerator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_11", 
            "text": "CS_unEnum  will return a -1 and set  csError  appropriately if any of the following conditions are encountered:     Constant  Description      cs_INV_INDX  The index argument was negative.", 
            "title": "Errors"
        }, 
        {
            "location": "/userguide/libraryfunctions/#bugs_2", 
            "text": "If called with an invalid type,  CS_unEnum  should probably return an error condition, but it doesn't. Calling  CS_unEnum  with an invalid type causes a return value of zero for all positive values of the  index  argument.", 
            "title": "BUGS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_unitlu-unit-look-up", 
            "text": "Function CS_unitlu (ByVal type As Integer, ByVal unit_nmAs String) As Double\nfunction CS_unitlu (type: Integer; unit_nm: PChar): Double;\ndouble CS_unitlu (short type, Const char *unit_nm);  Given the type of measurement, either length or angular, as specified by the  type  argument and the unit name as specified by the  unit_nm  argument,  CS_unitlu  will return a double which represents the multiplier required to convert a value in the unit system indicated by  unit_nm  to units of meters or degrees.  Currently, only two types of units supported, length and angular measure. Manifest constants defined in the  cs_map.h  header file are used to distinguish the desired type. These are  cs_UTYP_LEN  and  cs_UTYP_ANG . The  type  argument must be one of these values.  unit_nm  must be a null terminated string matching one of the supported units as defined in  CSdataU .  CS_unitlu  returns zero in the event the provided unit name is not known.  unit_nm  may be one of the supported abbreviations for any of the units defined in the unit table.  For example, to convert a value in feet to meters, one could code:  double CS_unitlu(); {\n  meters = feet * CS_unitlu(cs_UTYP_LEN,  FOOT );\n}  Or to convert degrees to grads:  double CS_unitlu (); {\n  grads = degrees / CS_unitlu (cs_UTYP_ANG,  GRAD );\n}  CS_unitlu  knows about the first and second abbreviations provided for in the  cs_Unittab_  structure.\nTherefore, the following are equivalent to the above:  double CS_unitlu(); {\n  meters = feet * CS_unitlu (cs_UTYP_LEN, FT );\n}\n\ndouble CS_unitlu(); {\n  grads = degrees / CS_unitlu (cs_UTYP_ANG, GR );\n}", 
            "title": "CS_unitlu unit look up"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_12", 
            "text": "CS_unitlu  will return zero and set  cs_Error  to  cs_INV_UNIT  if the unit name pointed to by  unit_nm  is not defined in  cs_Unittab  for the specified type, or the specified type is not valid.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#high-performance-interface", 
            "text": "Functions which are considered part of the High Performance Interface are described in this section. Several of these functions return addresses (i.e. pointers to) malloc'ed memory, and therefore these functions are not suitable for all languages. Function prototype definitions are given in the C syntax only.", 
            "title": "High Performance Interface"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_audflt-angular-unit-default", 
            "text": "char *CS_audlt (Const char *new_dflt);  Use  CS_audflt  to control the status of the \"defaultable\" angular unit reference feature of CS-MAP. new_dflt must be either a pointer to a valid angular unit name, a pointer to the null string, or the  NULL  pointer. In the case where  new_dflt  is a pointer to a valid angular unit name,  CS_audflt  causes the default angular unit feature to be activated, using the angular unit name provided as the, possibly new, default value. When  new_dflt  is a pointer to the null string,  CS_audflt  disables the default angular unit feature. When  new_dflt  is the  NULL  pointer, the status of the angular unit default feature remains unchanged.  In all cases,  CS_audflt  returns the previous status (or in the case of  new_dflt == NULL , the current status) in the form of a pointer to a static character array that contains the name of the previous default angular unit. Should the returned pointer point to a null string, the indicated previous status is disabled.", 
            "title": "CS_audflt Angular unit default"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_13", 
            "text": "CS_audflt  will return the  NULL  pointer if the key name provided is not that of a valid angular unit. In this event, the current status of the default angular unit feature remains unchanged.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_cs2ll-coordinate-system-to-latitudelongitude", 
            "text": "void CS_cs2ll(Const struct cs_Csprm_ *csprm,double ll[2], Const double xy[2]);  Given the definition of the coordinate system,  csprm , such as returned by  CS_csloc ,  CS_cs2ll  will convert the coordinates  xy  to latitude and longitude, returning the results in  ll . The  ll  and  xy  arguments may point to the same array.  In the array arguments, the X coordinate and the longitude occupy the first element, the Y coordinate and the latitude the second element. West longitudes and south latitudes are negative. The returned values are in degrees.", 
            "title": "CS_cs2ll Coordinate System to Latitude/Longitude"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_cscnv-coordinate-system-convergence", 
            "text": "double CS_cscnv(Const struct cs_Csprm_ *csprm, Const double ll[2]);  Given the definition of the coordinate system,  csprm , such as returned by  CS_csloc ,  CS_cscnv  will return the convergence angle in degrees east of north at the location given by  ll .  The location, as given by  ll  is in terms of latitude and longitude. The longitude is the first element of the  ll  array, latitude is the second, and both must be given in degrees. Positive values are used to specify north latitude and east longitude, negative values are used to specify south latitude and west longitude.", 
            "title": "CS_cscnv Coordinate System Convergence"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csdef-coordinate-system-definition-locator", 
            "text": "struct cs_Csdef_ * CS_csdef (Const char* key_nm);  CS_csdef  will return a pointer to a  malloc 'ed  cs_Csdef_  structure that contains the definition of the coordinate system indicated by  key_nm .  Key_nm  must point to an array that contains the null terminated key name of the desired coordinate system. The memory allocated for the coordinate system definition may be released by calling  CS_free  when no longer needed.", 
            "title": "CS_csdef Coordinate System definition locator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_14", 
            "text": "CS_csdef  will return a  NULL  pointer and set  cs_Error  if any of the following conditions are detected:     Constant  Description      cs_CSDICT  The Coordinate System Dictionary file could not be found or otherwise opened. (See  CS_altdr ).    cs_IOERR  A physical I/O error occurred during access to the Coordinate System Dictionary file.    cs_CS_BAD_MAGIC  The file accessed under the assumption that it was a Coordinate System Dictionary wasn't a Coordinate System Dictionary after all; it had an invalid magic number on the front end.    cs_CS_NOT_FND  A coordinate system definition with the name given by key_nm was not found in the Coordinate System Dictionary.    cs_NO_MEM  Insufficient dynamic memory was available to allocate space for the  cs_Csdef_  structure.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csdel-coordinate-system-definition-delete", 
            "text": "int CS_csdel(struct cs_Csdef_ *csdef);  CS_csdel  will delete from the Coordinate System Dictionary the definition of the coordinate system pointed to by  csdef .  The delete is accomplished by creating a new Coordinate System Dictionary file and copying all but the referenced coordinate system definitions from the existing dictionary to the new one. This implies that sufficient disk space must exist to perform the copy. A zero is returned if the delete was successfully completed, a -1 if a problem occurred. An attempt to delete a non-existent coordinate system definition is  NOT  considered an error.  If the value of the global variable  cs_Protect  is greater than or equal to zero,  CS_csdel  will not delete a coordinate system which is marked as being a distribution coordinate system (i.e.  cs_Csdef_.protect == 1 ). If the value of  cs_Protect  is greater than zero, it is interpreted as the number of days after which a user defined coordinate system is protected. For example, is cs_Protect  is 60, a user-defined coordinate system becomes protected 60 days after it is last modified.", 
            "title": "CS_csdel Coordinate System definition delete"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_15", 
            "text": "CS_csdel  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_CSDICT  The Coordinate System Dictionary could not be found or otherwise opened. (See  CS_altdr )    cs_IOERR  A physical I/O error occurred in copying the Coordinate System Dictionary to the new file.    cs_CS_BAD_MAGIC  The file assumed to be the Coordinate System Dictionary by virtue of its name was not a Coordinate System Dictionary; it had an invalid magic number.    cs_TMP_CRT  The attempt to create a new file, to which the modified Coordinate System Dictionary was to be copied, failed.    cs_DISK_FULL  Insufficient disk space was available to accommodate the copying of the Coordinate System Dictionary to the new file.    cs_UNLINK  The request to remove the old copy of the Coordinate System Dictionary failed.    cs_RENAME  The request to rename the new Coordinate System Dictionary file from its temporary name to COORDSYS failed.    cs_CS_PROT  The coordinate system to be deleted is a distribution coordinate system and may not be deleted.    cs_CS_UPROT  The coordinate system is a user defined coordinate system that has not been modified for 60 days and is therefore protected.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csenumbygroup-coordinate-system-enumerator-by-group", 
            "text": "int CS_csEnumByGroup (int index, Const char * grp_name, struct cs_Csgrplst_ * cs_descr);  CS_csEnumByGroup  is used to enumerate a specific group of coordinate systems in the Coordinate System Dictionary.  CS_csEnumByGroup  returns a completed  cs_Csgrplst_  structure at the location given by the  cs_descr  argument containing information that describes the  index 'th entry in the coordinate system group named by the  grp_name  argument.  Index  is a zero based index; the index of the first coordinate system in any group is zero. The next element of the returned  cs_Csgrplst_  structure is always set to the NULL pointer.  CS_csEnumByGroup  returns a positive 1 to indicate success. If  index  is too large, a zero is returned.", 
            "title": "CS_csEnumByGroup Coordinate System Enumerator By Group"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_16", 
            "text": "CS_csEnumByGroup  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_CSDICT  The Coordinate System Dictionary could not be found or otherwise opened. (See  CS_altdr )    cs_IOERR  A physical I/O error occurred in accessing the Coordinate System Dictionary.    cs_CS_BAD_MAGIC  The file assumed to be the Coordinate System Dictionary by virtue of its name was not a Coordinate System Dictionary; it had an invalid magic number.    cs_CSGRP_INVKEY  The  grp_name  argument was not that of a valid group name.    cs_INV_INDX  The index argument was negative.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csgrpenum-coordinate-system-grour-enumerator", 
            "text": "int CS_csGrpEnum(int index, char *grp_name, int name_sz, char *grp_dscr, int dscr_sz);  CS_csGrpEnum  is used to enumerate all groups in the Coordinate System Group table.  CS_csGrpEnum  returns in the memory buffer pointer to by the  grp_name  argument the key name of the  index 'th entry in the Coordinate System Group Table.  CS_csGrpEnum  will never write more than  name_sz  bytes to the indicated location. Similarly,  CS_csGrpEnum  returns the Coordinate System Group description in the buffer pointed to be  grp_dscr  and whose size in indicated by  dscr_sz . The  grp_name  and/or the  grp_dscr  arguments may be the  NULL  pointer to suppress return of the indicated item.  Index  is a zero based index; the index of the first entry in the Coordinate System Group Table is zero.  CS_dtEnum  returns a positive 1 to indicate success. If  index  is too large, a zero is returned. Inactive groups (a feature planned for a future release) are ignored, and are not considered to exist as far as  index  is concerned.", 
            "title": "CS_csGrpEnum Coordinate System grour enumerator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_17", 
            "text": "CS_csGrpEnum  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_INV_INDX  The index argument was negative.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csloc-coordinate-system-locate-and-initialize", 
            "text": "struct cs_Csprm_ *CS_csloc(Const char *cs_nam);\nstruct cs_Csprm_ *Cscsloc1(Const struct cs_Csdef_ *cs_ptr);\nstruct cs_Csprm_ *Cscsloc2(Const struct cs_Csdef_ *csPtr,\n                          Const struct cs_Dtdef_ *dtPtr,\n                          Const struct cs_Eldef_ *elPtr);\nstruct cs_Csprm_ *Cscsloc(Const struct cs_Csdef_ *csPtr,\n                          Const struct cs_Dtdef_ *dtPtr);  CS_csloc  locates the coordinate system definition indicated by  cs_nam  and returns a pointer to a  malloc 'ed, coordinate system parameter structure initialized for the specified coordinate system. The return value is the argument required by  CS_cs2ll ,  CS_ll2cs ,  CS_csscl , and  CS_cscnv . When no longer needed, the memory pointed to by the returned pointer should be released using  CS_free .  CS_csloc  accesses the definition dictionaries as is necessary to accomplish its task. The alternative functions enable applications to create coordinate system parameter structures using definitions that may have been obtained from sources other than the dictionaries. For example, certain applications may store definitions in vehicles other than the dictionaries, and then desire to construct a coordinate system parameter structure from these definitions.  Note that  Cscsloc1  does not need to access the coordinate system dictionary as the coordinate system definition is provided by the  cs_ptr  argument. However, it will need to access the datum and ellipsoid dictionaries to resolve datum and ellipsoid references.  Cscsloc2  is completely independent of all dictionaries as all three definitions must be provided.  CScsloc  is simply a basic function is encapsulates the basic functions of  CS_csloc  and its alternatives, and thus prevents duplication of large amounts of code.", 
            "title": "CS_csloc Coordinate System locate and initialize"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_18", 
            "text": "CS_csloc ,  CScsloc1 ,  CScsloc2 , and  CScsloc  return a  NULL  pointer and set  cs_Error  through the use of  CS_erpt  if any of the following conditions occur:     Constant  Description      cs_UNKWN_PROJ  The projection specified in the coordinate system definition is unknown to the system.     CS_csloc  uses the following functions that detect a majority of the exceptional conditions that may occur:     Constant  Description      CS_csdef  Locates and fetches the coordinate system definition from the Coordinate System Dictionary.    CS_dtloc  Locates and fetches the datum definition from the Datum Dictionary.    CS_eldef  Locates and fetches the ellipsoid definition from the Ellipsoid Dictionary.     CScsloc1  uses the following functions that detect a majority of the exceptional conditions that may occur:     Constant  Description      CS_dtloc  Locates and fetches the datum definition from the Datum Dictionary.    CS_eldef  Locates and fetches the ellipsoid definition from the Ellipsoid Dictionary.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_cssch-coordinate-system-scale-h-along-a-meridian", 
            "text": "double CS_cssch (Const struct cs_Csprm_ *csprm, Const double ll[2]);  Given the definition of the coordinate system,  csprm , such as returned by  CS_csloc ,  CS_cssch  will compute the grid scale factor along a meridian at the location given by  ll  and return this value. See  CS_cssck  for the grid scale factor along a parallel. Note that in conformal projections, the grid scale along a parallel equals the grid scale along a meridian at any point.  The location, as given by  ll , is in terms of latitude and longitude. The longitude is the first element of the  ll  array, latitude is the second, and both must be given in degrees. Positive values are used to specify north latitude and east longitude, negative values are used to specify south latitude and west longitude.", 
            "title": "CS_cssch Coordinate System Scale H, along a meridian"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_cssck-coordinate-system-scale-k-along-a-parallel", 
            "text": "double CS_cssck (Const struct cs_Csprm_ *csprm, Const double ll[2]);  Given the definition of the coordinate system,  csprm , such as returned by  CS_csloc ,  CS_cssck  will compute the grid scale factor along a parallel at the location given by  ll  and return this value. See  CS_cssch  for the grid scale factor along a meridian. Note that in conformal projections, the grid scale along a parallel equals the grid scale along a meridian at any point.  The location, as given by  ll  is in terms of latitude and longitude. The longitude is the first element of the  ll  array, latitude is the second, and both must be given in degrees. Positive values are used to specify north latitude and east longitude, negative values are used to specify south latitude and west longitude.", 
            "title": "CS_cssck Coordinate System Scale K, along a parallel"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csscl-coordinate-system-scale", 
            "text": "double CS_csscl (Const struct cs_Csprm_ *csprm, Const double ll[2]);  Given the definition of the coordinate system,  csprm , such as returned by  CS_csloc ,  CS_csscl  will compute the grid scale factor at the location given by  ll  and return this value.  The location, as given by  ll , is in terms of latitude and longitude. The longitude is the first element of the  ll  array, latitude is the second, and both must be given in degrees. Positive values are used to specify north latitude and east longitude, negative values are used to specify south latitude and west longitude.  Non-conformal projections have two different grid scale factors: the scale along a meridian and the scale along a parallel. In the case of azimuthal projections, the two scale factors are along a radial line from the origin and normal to such radial lines, respectively. In these cases,  CS_csscl  will return the more interesting of the two. For example, in the American Polyconic, the grid scale factor along all parallels is always 1.0; therefore  CS_csscl  return the grid scale factor along a meridian for this projection.", 
            "title": "CS_csscl Coordinate System Scale"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_csupd-coordinate-system-dictionary-update", 
            "text": "int CS_csupd (struct cs_Csdef_ *csdef, int crypt);  CS_csupd  will cause coordinate system definition pointed to by  csdef  to be added to the Coordinate System Dictionary. If a coordinate system with the same key name already exists, it is replaced by the definition provided. If no such definition exists, the new definition is added to the dictionary. If  crypt  is non-zero, the entry will be encrypted before being written to the dictionary.  In the event that the indicated coordinate system already exists,  CS_csupd  will return a 1 to indicate a successful update. In the event that the provided coordinate system had to be added to the Coordinate System Dictionary, a zero is returned. A -1 is returned if the update failed for any reason.  Please note that the addition of a new coordinate system definition requires the sorting of the Coordinate System Definition file. This may take a few seconds to complete, depending upon the size of the Coordinate System Dictionary.  If the value of the global variable  cs_Protect  is greater than or equal to zero,  CS_csupd  will not change a coordinate system which is marked as being a distribution coordinate system (i.e.  cs_Csdef_.protect == 1 ). If the value of  cs_Protect  is greater than zero, it is interpreted as the number of days after which a user defined coordinate system is protected. For example, if  cs_Protect  is 60, a user-defined coordinate system becomes protected 60 days after it is last modified.  Additionally, if the value of the global character variable  cs_Unique  is not the null character,  CS_csupd  will not add a coordinate system definition if its key name does not contain the character indicated. For example, if  cs_Unique  is set to the colon character,  CS_csupd  will not add a coordinate system whose key name does not contain a colon character.", 
            "title": "CS_csupd Coordinate system dictionary update"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_19", 
            "text": "CS_csupd  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered during the update:     Constant  Description      cs_CSDICT  The Coordinate System Dictionary file could not be opened. (See  CS_altdr ).    cs_IOERR  A physical I/O error occurred during the update process.    cs_CS_BAD_MAGIC  The file that, by virtue of its name and location, was supposed to be a Coordinate System Dictionary wasn't a Coordinate System Dictionary; its magic number was invalid.    cs_DISK_FULL  There was insufficient disk space available to add the coordinate system definition to the dictionary.    cs_CS_PROT  The coordinate system to be updated is a distribution coordinate system and may not be updated.    cs_CS_UPROT  The coordinate system is a user defined coordinate system that has not been modified for 60 days and is therefore protected.    cs_UNIQUE  The coordinate system provided does not already exist and would need to be added; but the key name does not contain the unique character.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_dtcls-datum-conversion-close", 
            "text": "void CS_dtcls (struct cs_Dtcprm_ *dtc_ptr);  Initializing a datum conversion can use file descriptors (handles) and allocate memory from the heap. Applications may need to recover these system resources for other use prior to exiting.  CS_dtcls  will release all system resources allocated to the datum conversion indicated by the  dtc_ptr  argument (as returned by  CS_dtcsu ). This function is, essentially, the inverse of  CS_dtcsu .", 
            "title": "CS_dtcls Datum conversion close"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_dtcsu-datum-conversion-set-up", 
            "text": "struct cs_Dtcprm_ *CS_dtcsu (Const struct cs_Csprm_ *src_cs, Const struct cs_Crprm_ *dest_cs, int dat_err, int blk_err);  CS_dtcsu ,  CS_dtcvt , and  CS_dtcls , are designed to provide a generic application interface for datum conversion. The objective is to enable application programmers to incorporate datum conversion capabilities into applications with a minimum of impact. Therefore, application programmers use  CS_dtcsu  to set up a datum conversion and  CS_dtcvt  to perform the actual conversions independently of the number or type of datum conversions that may or may not be supported.  CS_dtcls  provides a means of recovering any system resources that may be allocated by the activation of a datum conversion.  Application programmers use  CS_dtcsu  to initiate a datum conversion process.  Src_cs  points to the coordinate system definition of the source data that is to be converted while  dest_cs  points to the coordinate system definition for the results.  CS_dtcsu  examines the datum references in these coordinate systems, initializes the appropriate datum shift conversion, and returns a pointer to a  malloc 'ed datum conversion parameter block. The returned pointer is a required argument for the  CS_dtcvt  function.  As is often the case, should the source and destination coordinate systems share the same datum, the null datum conversion is activated. That is, source latitudes and longitudes are copied directly to the destination array without modification.  The  dat_err  argument is used to indicate the desired disposition of certain errors that are encountered during the setup of the datum conversion. The error disposition control afforded by  dat_err  applies only to errors indicating that an unsupported datum conversion was requested. System errors, such as physical I/O or insufficient memory for example, are always treated as fatal errors and a  NULL  pointer is returned.  The following values for  dat_err  are recognized:     Constant  Description      cs_DTCFLG_DAT_I  Ignore unsupported datum conversion request errors and, in the event of such an error, silently activate the null conversion.    cs_DTCFLG_DAT_W  In the event of an unsupported datum conversion request error, report the condition as a warning to  CS_erpt  ( cs_DTC_DAT_W ) and activate the null conversion. In this case, the user is notified, but data processing continues.    cs_DTCFLG_DAT_F  In the event of any error, report the condition as a fatal error to  CS_erpt  ( cs_DTC_DAT_F ) and return the NULL pointer.     The  blk_err  argument is used to indicate the desired disposition of certain errors that are encountered during the conversion of individual coordinate values. The error disposition control afforded by  blk_err  applies only to errors indicating that the required data for the geographic region containing the coordinate to be converted is not available. System errors, such as physical I/O or insufficient memory for example, are always treated as fatal errors.  The following values for  blk_err  are recognized:     Constant  Description      cs_DTCFLG_BLK_I  Ignore datum conversion errors caused by data availability problems and silently use the null conversion for the specific coordinate that could not be converted and cause  CS_dtcvt  to return a zero value.    cs_DTCFLG_BLK_W  In the event a datum conversion fails due to data availability, report a warning through  CS_erpt  ( cs_DTC_BLK_W ), convert the coordinate using the null conversion, and cause a  CS_dtcvt  to return a positive non-zero value for the specific coordinate that could not be converted. The warning message is issued for each coordinate that could not be converted.    cs_DTCFLG_BLK_1  In the event a datum conversion fails due to data availability, cause  CS_dtcvt  to return a positive non-zero value for the specific coordinate that could not be converted. That such an error has been reported is recorded in the datum parameter block and this is used to suppress repeated reporting of the error with regard to the same block.    cs_DTCFLG_BLK_F  Report a fatal condition through  CS_erpt  ( cs_DTC_BLK_F ), convert the coordinate using the null conversion, and cause  CS_dtcvt  to return a negative non-zero value to indicate that the expected conversion did not take place.", 
            "title": "CS_dtcsu Datum conversion set up"
        }, 
        {
            "location": "/userguide/libraryfunctions/#special-cases", 
            "text": "Three special cases have been coded into this function. Normally, the geographic coodinates of the source datum are converted to WGS84 values, and the resulting WGS84 values are then converted to the target datum.  There are three cases where this genberal technique proved to be unsatisfactory. In these three cases,  CS_dtcsu  has been expressly coded to look at the source and target datums, and implement direct conversions where appropriate. Note, that in each case, a specific Geodetic Data Catalog file is also involved. Thus, if the required Geodetic Data Catalog file is not present, all of the special processing is disabled.  The following table defines the special cases:     Source Datum  Target Datum  Geodetic Data Catalog  Description      NAD27  ATS77  Nad27ToAts77.gdc  Converts directly from NAD27 to ATS77 using the very special  TRANSFORM  algorithm.    ATS77  CSRS  Ats77ToCsrs.gdc  Converts directly as direct NTv2 format files are generally available.    NAD27  CSRS  Nad27ToCsrs.gdc  Converts directly as direct NTv2 format files are generally available.", 
            "title": "Special cases"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_20", 
            "text": "Should the requested datum conversion requested be unsupported,  CS_dtcsu  will perform as indicated by the  dat_err  argument. Should the initialization of a supported datum conversion fail due to a system error, the  NULL  pointer will be returned and  cs_Error  set to indicate the nature of failure. Should a datum conversion for which appropriate code is present fail because a required data file is not present, the failure is treated as an unsupported datum conversion request.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_dtcvt-datum-convert", 
            "text": "int CS_dtcvt (struct cs_Dtcprm_ *dtc_ptr, Const double src_ll[2], double dest_ll[2]);  CS_dtcvt  performs the datum conversion indicated by  dtc_ptr  returning in the array pointed to by  dest_ll  the result of converting the latitude and longitude values pointed to by  src_ll .  Src_ll  and  dest_ll  may point to the same array. Latitude and longitude values must be given in degrees, where negative values indicate south and west. The longitude is carried in the first element of the array and the latitude is carried in the second element. The  dtc_ptr  argument is that which is returned by  CS_dtcsu .", 
            "title": "CS_dtcvt Datum Convert"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_21", 
            "text": "Should a system error occur during the conversion (e.g. a physical I/O error or insufficient memory)  CS_dtcvt  returns a negative non-zero value and sets  cs_Error  to indicate the cause of the failure.  Conversion failures caused by a lack of data covering the specific coordinate to be converted are handled as indicated by the  blk_err  element of the  cs_Dtcprm_  structure pointed to by the  **tc_ptr** argument. The **blk_err** element is set by CS_dtcsu to the value of its **blk_err** argument prior to returning **dtc_ptr**. Refer to CS_dtcsu` for a detailed description of how such errors are handled.  In all cases, the null conversion is always performed before any other processing is attempted.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#example", 
            "text": "This function, and its companion  CS_dtcsu  have been designed such that the following sequence of code is all that is necessary to perform a complete coordinate conversion, including a datum conversion (error handling omitted):  #define XX 0\n#define YY 1\nstruct cs_Csprm * src_cs, * dest_cs;\nstruct cs_Dtcprm_ *dtc_ptr;\ndouble src_xy [2], ll[2], dest_xy[2];\n.\n.\nsrc_cs = CS_csloc ( src_name) ;\ndest_cs = CS_csloc (dest_name);\ndtc_ptr = CS_dtcsu ( src_cs, dest_cs, cs_DTCFLG_DAT_F, cs_DTCDLG_BLK_1) ; .\n.\nwhile (TRUE)\n{\n.\n.\nsrc_xy[XX] = ???;\nsrc_xy[YY] = ???;\nCS_cs2ll (src_cs,ll,src_xy); CS_dtcvt (dtc_ptr,ll,ll); CS_ll2cs (dest_cs,dest_xy,ll);\n??? = dest_xy[XX]; ??? = dest_xy[YY]; .\n.\n}\nCS_free (src_cs); CS_free (dest_cs); CS_dtcls (dtc_ptr);  Notice, that adding the datum conversion to a simple cartographic conversion requires only the insertion of three lines of code (error handling aside) to the simple High Performance Interface described elsewhere in this manual.", 
            "title": "EXAMPLE"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_dtdef-datum-definition-locator", 
            "text": "struct cs_Dtdef_ * CS_dtdef ( Const char * key_nm) ;  CS_dtdef  will return a pointer to a  malloc 'ed  cs_Dt def_  structure which contains the definition of the datum indicated by  key_nm .  Key_nm  must point to an array that contains the null terminated key name of the desired datum definition. The memory allocated for the datum definition should be released by using  CS_free  when no longer needed.", 
            "title": "CS_dtdef Datum Definition locator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_22", 
            "text": "CS_dtdef  will return a  NULL  pointer and set  cs_Error  if any of the following conditions are detected:     Constant  Description      cs_DTDICT  The Datum Dictionary file could not be found or otherwise opened. (See  CS_altdr )    cs_IOERR  A physical I/O error occurred during access to the Datum Dictionary file.    cs_DT_BAD_MAGIC  The file accessed under the assumption that it was a Datum Dictionary wasn't a Datum Dictionary after all; it had an invalid magic number on the front end.    cs_DT_NOT_FND  A datum definition with the name given by  key_nm  was not found in the Datum Dictionary.    cs_NO_MEM  Insufficient dynamic memory was available to allocate space for the  cs_Dtdef_  structure.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_dtdel-datum-definition-delete", 
            "text": "int CS_dtdel (struct cs_Dtdef_ *dtdef);  CS_dtdel  will delete from the Datum Dictionary the definition of the Datum pointed to by  dtdef .  The delete is accomplished by creating a new Datum Dictionary file and copying all but the referenced datum definition from the existing dictionary to the new one. This implies that sufficient disk space must be available to perform this copy. A zero is returned if the delete was successfully completed, a - 1 if a problem occurred. An attempt to delete a non-existent datum definition is  NOT  considered a problem.  If the value of the global variable  cs_Protect  is greater than or equal to zero,  CS_dtdel  will not delete a datum definition which is marked as being a distribution datum definition (i.e.  cs_Dt def_.protect == 1 ). If the value of  cs_Protect  is greater than zero, it is interpreted as the number of days after which a user defined datum is protected. For example, is  cs_Protect  is 60, a user-defined datum becomes protected 60 days after it is last modified.", 
            "title": "CS_dtdel DaTum definition delete"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_23", 
            "text": "CS_dtdel  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_DTDICT  The Datum Dictionary file could not be found or otherwise opened. (See  CS_altdr )    cs_IOERR  A physical I/O error occurred in copying the Datum Dictionary to the new file.    cs_DT_BAD_MAGIC  The file assumed to be the Datum Dictionary by virtue of its name and location was not a Datum Dictionary; it had an invalid magic number.    cs_TMP_CRT  The attempt to create a new file, to that the modified Datum Dictionary was to be copied, failed.    cs_DISK_FULL  Insufficient disk space was available to accommodate the copying of the Datum Dictionary to the new file.    cs_UNLINK  The request to remove the old copy of the Datum Dictionary failed.    cs_RENAME  The request to rename the new Datum Dictionary file from its temporary name to DATUMS failed.    cs_DT_PROT  The datum definition to be updated is a distribution datum definition and may not be deleted.    cs_DT_UPROT  The datum is a user-defined datum which has not been modified for 60 days and is therefore protected.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_dtdflt-datum-default", 
            "text": "char *CS_dtdflt (Const char *new_dflt);  Use  CS_dtdflt  to control the status of the \"defaultable\" datum reference feature of CS-MAP.  New_dflt  must be either a valid datum key name, a pointer to the null string, or the  NULL  pointer. In the case where  new_dflt  is a pointer to a valid datum definition key name,  CS_dtdflt  causes the default datum feature to be active, using the datum key name provided as the default value. When  new_dflt  is a pointer to the null string,  CS_dtdflt  disables the default datum feature. When  new_dflt  is the  NULL  pointer, the status of the default feature remains unchanged.  In all cases,  CS_dtdflt  returns the previous status (or in the case of  new_dflt == NULL , the current status) in the form of a pointer to a static character array which shall contain the name of the previous default datum. Should the returned pointer point to a null string, the indicated status is disabled.", 
            "title": "CS_dtdflt Datum default"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_24", 
            "text": "CS_dtdflt  will return the  NULL  pointer if the key name provided is not that of a valid datum. In this event, the status of the default datum feature remains unchanged.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_dtloc-datum-locate", 
            "text": "struct cs_Datum_ *CS_dtloc (Const char * key_nm) ;\nstruct cs_Datum_ *Csdtloc1 (Const struct cs_Dtdef_ *dtPtr);\nstruct cs_Datum_ *Csdtloc2 (Const struct cs_Dtdef_ *dtPtr, Const struct cs_Eldef_ *elPtr);  CS_dtloc  will return a pointer to a  malloc 'ed  cs_Datum_  structure which contains the definition of the datum indicated by  key_nm  along with the ellipsoid information referenced by the datum definition.  Key_nm  must point to an array that contains the key name of the desired datum. The memory allocated for the datum definition should be released using  CS_free  when no longer needed.  CSdtloc1  and  CSdtloc2  are alternatives to  CS_dtloc  that enable alternative sources for datum and ellipsoid definitions. These have been provided for applications that may, for example, store the datum, and/or ellipsoid, definitions in an application database.  Note that while  CSdtloc1  will not need to access the Datum Dictionary, it will need to access the Ellipsoid Dictionary to resolve the ellipsoid reference in the datum definition provided.  CSdtloc2  is completely independent of both dictionaries.", 
            "title": "CS_dtloc Datum locate"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_25", 
            "text": "CS_dtloc ,  Csdtloc , and  CSdtloc2  will return a NULL pointer and set  cs_Error  if any of the following conditions are detected:     Constant  Description      cs_NO_MEM  Insufficient dynamic memory was available to allocate space for the  cs_Datum_  structure.     CS_dtloc  uses  CS_dtdef  and  CS_eldef  to obtain definition records from the Datum and Ellipsoid Dictionaries. Therefore, all of the error conditions detected by these functions apply to this function as well.  CSdtloc1  uses  CS_eldef  to obtain definition records from the Ellipsoid Dictionary. Therefore, all of the error conditions detected by this function apply to this function as well.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_dtupd-datum-dictionary-update", 
            "text": "int CS_dtupd (struct cs_Dtdef_ *dt_def, int crypt);  CS_dtupd  will cause the datum definition pointed to by  dt_def  to be added to the Datum Dictionary. If a datum with the same key name exists, it is replaced by the definition provided. If no such definition exists, the new definition is added to the dictionary. If  crypt  is non-zero, the datum entry is encrypted before being written.  In the event that the indicated datum already existed,  CS_dtupd  will return a 1 to indicate a successful update. In the event that the provided datum definition had to be added to the Datum Dictionary, a zero is returned. A -1 is returned if the update failed for any reason.  Please note that the addition of a new datum definition requires the sorting of the Datum Dictionary file. This may take a few seconds to complete, depending upon the size of the Datum Dictionary.  If the value of the global variable  cs_Protect  is greater than or equal to zero,  CS_dtupd  will not change a datum definition which is marked as being a distribution datum definition (i.e. cs_Dtdef_.protect == 1 ). If the value of  cs_Protect  is greater than zero, it is interpreted as the number of days after which a user defined datum is protected. For example, is  cs_Protect  is 60, a user-defined datum becomes protected 60 days after it is last modified.  Additionally, if the value of the global character variable  cs_Unique  is not the null character,  CS_dtupd  will not add a datum definition if its key name does not contain the character indicated. For example, if  cs_Unique  is set to the colon character,  C S_dtupd` will not add a datum definition whose key name does not contain a colon character.", 
            "title": "CS_dtupd Datum dictionary update"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_26", 
            "text": "CS_dtupd  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered during the update:     Constant  Description      cs_DTDICT  The Datum Dictionary file could not be opened. (See  CS_altdr )    cs_IOERR  A physical I/O error occurred during the update process.    cs_DT_BAD_MAGIC  The file which, by virtue of its name and location, was assumed to be a Datum Dictionary wasn't a Datum Dictionary; its magic number was invalid.    Cs_DISK_FULL  There was insufficient disk space available to add the datum definition to the Datum Dictionary.    Cs_DT_PROT  The datum definition to be updated is a distribution datum definition and may not be updated.    cs_DT_UPROT  The datum is a user-defined datum that has not been modified for 60 days and is therefore protected.    cs_UNIQUE  The datum provided does not already exist and would need to be added; but the key name does not contain the unique character.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_eldef-ellipsoid-definition-locator", 
            "text": "struct cs_Eldef_ * CS_eldef ( Const char * key_nm) ;  CS_eldef  will return a pointer to a  malloc 'ed  cs_Eldef_  structure which contains the definition of the ellipsoid indicated by  key_nm .  Key_nm  must point to an array that contains the null terminated key name of the desired ellipsoid definition. The memory allocated for the ellipsoid definition should be released using  CS_free  when no longer needed.", 
            "title": "CS_eldef Ellipsoid definition locator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_27", 
            "text": "CS_eldef  will return a  NULL  pointer and set  cs_Error  if any of the following conditions are detected:     Constant  Description      cs_ELDICT  The Ellipsoid Dictionary file could not be found or otherwise opened. (See  CS_altdr )    cs_IOERR  A physical I/O error occurred during access to the Ellipsoid Dictionary file.    cs_EL_BAD_MAGIC  The file accessed under the assumption that it was an Ellipsoid Dictionary wasn't an Ellipsoid Dictionary after all; it had an invalid magic number on the front end.    cs_EL_NOT_FND  A ellipsoid definition with the name given by key_nm was not found in the Ellipsoid Dictionary.    cs_NO_MEM  Insufficient dynamic memory was available to allocate space for the  cs_Eldef_  structure", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_eldel-ellipsoid-definition-delete", 
            "text": "int CS_eldel (struct cs_Eldef_ *eldef);  CS_eldel  will delete from the Ellipsoid Dictionary the definition of the Ellipsoid pointed to by  eldef .  The delete is accomplished by creating a new Ellipsoid Dictionary file and copying all but the referenced ellipsoid definition from the existing dictionary to the new one. This implies that sufficient disk space must be available to perform this copy. A zero is returned if the delete was successfully completed, a -1 if a problem occurred. An attempt to delete a non-existent ellipsoid definition is  NOT  considered a problem.  If the value of the global variable  cs_Protect  is greater than or equal to zero,  CS_eldel  will not delete an ellipsoid definition which is marked as being a distribution ellipsoid definition (i.e.  cs_El def_.protect == 1 ). If the value of  cs_Protect  is greater than zero, it is interpreted as the number of days after which a user defined ellipsoid is protected. For example, is  cs_Protect  is 60, a user-defined ellipsoid becomes protected 60 days after it is last modified.", 
            "title": "CS_eldel Ellipsoid definition delete"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_28", 
            "text": "CS_eldel  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_ELDICT  The Ellipsoid Dictionary could not be found or otherwise opened. (See  CS_altdr )    cs_IOERR  A physical I/O error occurred in copying the Ellipsoid Dictionary to the new file.    cs_EL_BAD_MAGIC  The file assumed to be the Ellipsoid Dictionary by virtue of its name and location was not an Ellipsoid Dictionary; it had an invalid magic number.    cs_TMP_CRT  The attempt to create a new file, to which the modified Ellipsoid Dictionary was to be copied, failed.    cs_DISK_FULL  Insufficient disk space was available to accommodate the copying of the Ellipsoid Dictionary to the new file.    cs_UNLINK  The request to remove the old copy of the Ellipsoid Dictionary failed.    cs_RENAME  The request to rename the new Ellipsoid Dictionary file from its temporary name to ELIPSOID failed.    cs_EL_PROT  The ellipsoid definition to be updated is a distribution ellipsoid definition and may not be deleted.    cs_EL_UPROT  The ellipsoid is a user-defined ellipsoid which has not been modified for 60 days and is therefore protected.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_eldflt-ellipsoid-default", 
            "text": "char *CS_eldlt (Const char *new_dflt);  Use  CS_eldflt  to control the status of the \"defaultable\" ellipsoid reference feature of CS-MAP. New_dflt  must be either a pointer to a valid ellipsoid key name, a pointer to the null string, or the  NULL  pointer. In the case where  new_dflt  is a pointer to a valid ellipsoid definition key name,  CS_eldflt  causes the default ellipsoid feature to be activated, using the ellipsoid key name provided as the, possibly new, default value. When  new_dflt  is a pointer to the null string,  CS_eldflt  disables the default ellipsoid feature. When  new_dflt  is the  NULL  pointer, the status of the default feature remains unchanged.  In all cases,  CS_eldflt  returns the previous status (or in the case of  new_dflt == NULL , the current status) in the form of a pointer to a static character array that shall contain the name of the previous default ellipsoid. Should the returned pointer point to a null string, the indicated status is disabled.", 
            "title": "CS_eldflt Ellipsoid default"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_29", 
            "text": "CS_eldflt  will return the  NULL  pointer if the key name provided is not that of a valid ellipsoid. In this event, the status of the default ellipsoid feature remains unchanged.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_elenum-ellipsoid-enumerator_1", 
            "text": "int CS_elEnum(int index, char *key_name, int size);  CS_elEnum  is used to enumerate all ellipsoids in the Ellipsoid Dictionary.  CS_elEnum  returns in the memory buffer pointer to by the  key_name  argument the key name of the  index 'th entry in the Ellipsoid Dictionary.  CS_elEnum  will never write more than size bytes to the indicated location.  Index  is a zero based index; the index of the first entry in the Ellipsoid Dictionary is zero.  CS_elEnum  returns a positive 1 to indicate success. If  index  is too large, a zero is returned.", 
            "title": "CS_elEnum Ellipsoid enumerator"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_30", 
            "text": "CS_elEnum  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered:     Constant  Description      cs_ELDICT  The Ellipsoid Dictionary could not be found or otherwise opened. (See  CS_altdr )    cs_IOERR  A physical I/O error occurred in accessing the Ellipsoid Dictionary.    cs_DT_BAD_MAGIC  The file assumed to be the Ellipsoid Dictionary by virtue of its name was not an Ellipsoid Dictionary; it had an invalid magic number.    cs_INV_INDX  The index argument was negative.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_elupd-ellipsoid-dictionary-update", 
            "text": "int CS_elupd (struct cs_Eldef_ *el_def, int crypt);  CS_elupd  will cause the ellipsoid definition pointed to by  el_def  to be added to the Ellipsoid Dictionary. If an ellipsoid with the same key name exists, it is replaced by the definition provided. If no such definition exists, the new definition is added to the dictionary. If  crypt  is non-zero, the ellipsoid entry is encrypted before being written.  In the event that the indicated ellipsoid already existed,  CS_elupd  will return a 1 to indicate a successful update. In the event that the provided ellipsoid had to be added to the Ellipsoid Dictionary, a zero is returned. A -1 is returned if the update failed for any reason.  Please note that the addition of a new ellipsoid definition requires the sorting of the Ellipsoid Dictionary file. This may take a few seconds to complete, depending upon the size of the Ellipsoid Dictionary.  If the value of the global variable  cs_Protect  is greater than or equal to zero,  CS_elupd  will not change an ellipsoid definition which is marked as being a distribution ellipsoid definition (i.e. cs_Elde_.protect == 1 ). If the value of  cs_Protect  is greater than zero, it is interpreted as the number of days after which a user defined ellipsoid is protected. For example, is  cs_Protect  is 60, a user-defined ellipsoid becomes protected 60 days after it is last modified.  Additionally, if the value of the global character variable  cs_Unique  is not the null character,  CS_elupd  will not add an ellipsoid definition if its key name does not contain the character indicated. For example, if  cs_Unique  is set to the colon character,  CS_elupd  will not add an ellipsoid definition whose key name does not contain a colon character.", 
            "title": "CS_elupd Ellipsoid dictionary update"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_31", 
            "text": "CS_elupd  will return a -1 and set  cs_Error  appropriately if any of the following conditions are encountered during the update:     Constant  Description      cs_ELDICT  The Ellipsoid Dictionary file could not be opened. (See  CS_altdr )    cs_IOERR  A physical I/O error occurred during the update process.    cs_EL_BAD_MAGIC  The file which, by virtue of its name and location, was assumed to be an Ellipsoid Dictionary wasn't an Ellipsoid Dictionary; its magic number was invalid.    cs_DISK_FULL  There was insufficient disk space available to add the ellipsoid definition to the Ellipsoid Dictionary.    cs_EL_PROT  The ellipsoid definition to be updated is a distribution ellipsoid definition and may not be updated.    cs_EL_UPROT  The ellipsoid is a user-defined ellipsoid that has not been modified for 60 days and is therefore protected.    cs_UNIQUE  The ellipsoid provided does not already exist and would need to be added; but the key name does not contain the unique character.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_errmsg-error-message_1", 
            "text": "void CS_errmsg (char msg_bufr, int bufr_size);  CS_errmsg  returns to the calling function a null terminated string that describes the last error condition detected by the CS-MAP library. The result is returned in the buffer pointed to by the  msg_bufr  argument, which is assumed to be  bufr_size  bytes long. The message is returned in one character per byte ANSI code characters.  CS_errmsg  will return the null string if called before any error condition is detected.", 
            "title": "CS_errmsg Error message"
        }, 
        {
            "location": "/userguide/libraryfunctions/#bugs_3", 
            "text": "After returning an error message to the user,  CS_errmsg  should reset itself to the null string preventing the same error message from being returned a second time. It should, but it doesn't.", 
            "title": "BUGS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_ll2cs-latitudelongitude-to-coordinate-system", 
            "text": "void CS_ll2cs (Const struct cs_Csprm_ *csprm, double xy[2], Const double ll[2] );  Given the definition of the coordinate system,  csprm , such as returned by  CS_csloc ,  CS_ll2cs  will convert the latitude and longitude given by  ll  to X and Y coordinates, returning the results in  xy . The  ll  and  xy  arguments may point to the same array.  In the arrays, the X coordinate and the longitude occupy the first element, the Y coordinate and the latitude the second element. The latitude and longitude must be given in degrees where negative values are used to indicate west longitude and south latitude.", 
            "title": "CS_ll2cs Latitude/Longitude TO Coordinate System"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_llchk-latlong-limits-check", 
            "text": "int CS_llchk (Const struct cs_Csprm_ *csprm, int cnt, Const double pnts[][3]);  CS_llchk  determines if the points, great circles, and regions defined by the point list provided by the  cnt  and  pnts  arguments are within the mathematical domain and useful range of the coordinate system provided by the  csprm  argument. All points in the point list are expected to be geographic coordinates. Use  CS_xychk  to check a list of cartesian coordinates.  CS_llchk  returns  cs_CNVRT_OK  if all coordinate subject to the determination are both within the mathematical domain of the coordinate system and the useful range of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more coordinates is outside of the mathematical domain of the coordinate system.  cs_CNVRT_USFL  is returned if all coordinates subject to the determination are within the mathematical domain of the coordinate system, but one or more coordinates are outside of the useful range of the coordinate system.  The useful range of a coordinate system may be defined by the user as part of the coordinate system definition. In the absence of such a definition, the setup function for each projection computes a useful range based on the parameters for the projection. In some cases, this computed useful range will be too liberal; in others it may be too conservative. In any case, checking coordinates to be converted against the useful range is a good way to alert users of a possible problem, such as using the wrong coordinate system for a set of coordinates.", 
            "title": "CS_llchk Lat/Long limits check"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_ludflt-linear-unit-default", 
            "text": "char *CS_ludlt (Const char *new_dflt);  Use  CS_ludflt  to control the status of the \"defaultable\" linear unit reference feature of CS-MAP.  New_dflt  must be either a pointer to a valid linear unit name, a pointer to the null string, or the  NULL  pointer. In the case where  new_dflt  is a pointer to a valid linear unit name,  CS_ludflt  causes the default linear unit feature to be activated, using the linear unit name provided as the, possibly new, default value. When  new_dflt  is a pointer to the null string,  CS_ludflt  disables the default linear unit feature. When  new_dflt  is the  NULL  pointer, the status of the linear unit default feature remains unchanged.  In all cases,  CS_ludflt  returns the previous status (or in the case of  new_dflt == NULL , the current status) in the form of a pointer to a static character array which shall contain the name of the previous default linear unit. Should the returned pointer point to a null string, the indicated status is disabled.", 
            "title": "CS_ludflt linear unit default"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_32", 
            "text": "CS_ludflt  will return the  NULL  pointer if the key name provided is not that of a valid linear unit. In this event, the status of the default linear unit feature remains unchanged.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_xychk-x-and-y-limits-check", 
            "text": "int CS_xychk (Const struct cs_Csprm_ *csprm, int cnt, Const double pnts[][3]);  CS_xychk  determines if the points, line segments, and regions defined by the point list provided by the  cnt  and  pnts  arguments are within the mathematical domain and useful range of the coordinate system provided by the  csprm  argument. All points in the point list are expected to be cartesian coordinates. Use  CS_llchk  to check a list of geographic coordinates.  CS_xychk  returns  cs_CNVRT_OK  if all coordinate subject to the determination are both within the mathematical domain of the coordinate system and the useful range of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more coordinates is outside of the mathematical domain of the coordinate system.  cs_CNVRT_USFL  is returned if all coordinates subject to the determination are within the mathematical domain of the coordinate system, but one or more coordinates are outside of the useful range of the coordinate system.  The useful range of a coordinate system may be defined by the user as part of the coordinate system definition. In the absence of such a definition, the setup function for each projection computes a useful range based on the parameters for the projection. In some cases, this computed useful range will be too liberal; in others it may be too conservative. In any case, checking coordinates to be converted against the useful range is a good way to alert users of a possible problem, such as using the wrong coordinate system for a set of coordinates.", 
            "title": "CS_xychk X and Y limits check"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_usrunitptr-units-look-up-hook-function", 
            "text": "double CS_usrUnitPtr (short type, Const char *unitName);  This name,  CS_usrUnitPtr  , does not refer to a function. Rather, it refers to a global variable which is defined as a pointer to a function which is defined as the above given prototype declares. Applications can use a function as declared above, and the related global pointer variable, to implement unit definitions in a dynamic manner.  If the global variable  CS_usrUnitPtr  (defined in  CSdata.c ) is not null, the indicated function is called whenever the CS-MAP library is asked to access a specific unit definition. This function, then, can be used to dynamically supply a unit conversion value which does not exist in the compiled unit table. Applications can use this to implement their own unit definition table or dynamically generate such a definition based on the unit name provided.  CS-MAP passes the  unitName  argument to the hook function prior to any validation, thus dynamic definition names need not adhere to the CS-MAP key name conventions. In the event that the hook function determines that it wishes to supply the definition, the desired conversion value must be returned. CS-MAP passed the unit type requested to the hook function using the  type  argument.  The hook function returns an integer value:   a positive non-zero value to indicate that a conversion value is being supplied by the hook function, and the value returned is indeed the conversion value.  zero is returned to indicate that normal CS-MAP unit table access is to be performed.  a negative value is returned to indicate that an error is to be reported. It is expect that the nature of the error would have already reported through the use of CS_erpt.", 
            "title": "CS_usrUnitPtr - Units look up hook function"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_unitadd-add-unit-to-table", 
            "text": "int CS_unitAdd (struct cs_Unittab_ *unitPtr);  Use this function to add a new unit to the unit table at run time. Essentially, the unit definition pointed to by the  unitPtr  argument is copied to a disabled entry in the compiled unit table. This function does not check any of the entries in the provided unit definition, so use this function with great care.", 
            "title": "CS_unitAdd - Add  unit to table"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_33", 
            "text": "CS_unitAdd  returns a zero value for success. A negative return value indicates a failure. In this case, one of the following error conditions will have been reported through the use of  CS_erpt :     Constant  Description      cs_UADD_TYP  The type of unit specified in the provided definition was invalid. Must be either  cs_UTYP_LIN  or  cs_UTYP_ANG .    cs_UADD_DUP  A unit definition with the (singular) name of given in the provided definition already exists in the unit table.    cs_UADD_FULL  All of the disabled slots in the unit table have been filled; thus the unit table is currently full.", 
            "title": "ERRORS"
        }, 
        {
            "location": "/userguide/libraryfunctions/#cs_unitdel-delete-unit-from-table", 
            "text": "int CS_unitDel (short type, Const char *name);  Use this function to disable an entry in the unit table. The specific unit is identified by the  type  and  name  arguments. Type must be given as either  cs_UTYP_LIN  or  cs_UTYP_ANG . Note that compiled (i.e. not necessarily added) unit entries can also be disabled. This will remove them from subsequent unit enumerations performed by  CS_unEnum .", 
            "title": "CS_unitDel -- Delete unit from table"
        }, 
        {
            "location": "/userguide/libraryfunctions/#errors_34", 
            "text": "CS_unitDel  will return a zero for success. A negative 1 is return to indicate failure. In the event of failure, one of the following error conditions will have been reported through  CS_erpt :     Constant  Description      cs_UDEL_NONE  The named unit, of the provided type, did not exist in the unit table.", 
            "title": "Errors"
        }, 
        {
            "location": "/userguide/libraryfunctions/#low-level-interface-functions", 
            "text": "Functions which are considered part of the Low Level Interface are described in this section. Several of these functions require geographic arguments. Remember that these are required to be:   in longitude, latitude, and height order, and  given in degrees, and  referenced to Greenwich meridian, and  where west lonigtude and south latitude are represented by negative values.   Function prototype definitions are given in the C syntax only.", 
            "title": "Low level interface functions"
        }, 
        {
            "location": "/userguide/cartographicprojections/", 
            "text": "Cartographic Projection Funtions\n\n\nAlbers Equal Area Projection (CSalber)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Alber Equal Area Conic Projection.\n\n\nCSalberF Forward conversion\n\n\nint CSalberF (Const struct cs_Alber_ *alber, double xy[2], Const double ll[ 2]);\n\n\n\n\nGiven a properly initialized \ncs_Alber_\n structure via the \nalber\n argument, \nCSalberF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSalberF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSalberI Inverse conversion\n\n\nint CSalberI (Const struct cs_Alber_ *alber, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Alber_\n structure via the \nalber\n argument, \nCSalberI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSalberI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSalberK grid scale (K) along parallel\n\n\ndouble CSalberK (Const struct cs_Alber_ *alber, Const double ll[2]);\n\n\n\n\nCSalberK\n returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. (The use of the \nll\n array is the same as described above.)\n\n\nCSalberH grid scale (H) along meridian\n\n\ndouble CSalberH(Const struct cs_Alber_ *alber, Const double ll[2]);\n\n\n\n\nCSalberH\n returns the grid scale factor, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSalberC Convergence angle\n\n\ndouble CSalberC(Const struct cs_Alber_ *alber, Const double ll[2]);\n\n\n\n\nCSalberC\n returns the convergence angle in degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSalberQ definition Quality check\n\n\nint CSalberQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSalberQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Alber Equal Area Projection. \nCS_cschk\n examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSalberQ\n only examines those components specific to the Alber Equal Area Projection. \nCSalberQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_lis\nt, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSalberQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSalberL Latitude/longitude check\n\n\nint CSalberL (Const struct cs_Alber_ *alber, int cnt, Const double pnts[][3]);\n\n\n\n\nCSalberL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nalber\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSalbersL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSalberL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSalberX Xy coordinate check\n\n\nint CSalberX (Const struct cs-Alber_ *alber, int cnt, Const double pnts[][3]);\n\n\n\n\nCSalberX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nalber\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSalbersX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSalberL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSalberS Setup\n\n\nvoid CSalberS(struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSalberS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallels, the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once. \nCSalberS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCSalberS\n serves as the source for input and the repository for the results as described below\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the Albers projection are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLatitude, in degrees, of the northern standard parallel. Unlike other conics, it is important to distinguish between the northern and southern standard parallels for the Albers.\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the southern standard parallel. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\nScale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nQuad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the \ndatum\n element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Alber_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nalber\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSalberF\n, \nCSalberI\n, \nCSalberK\n, \nCSalberH\n, and \nCSalberC\n functions require as their first argument.\n\n\nAmerican Polyconic Projection (CSplycn)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the American Polyconic Projection.\n\n\nCSplycnF forward conversion\n\n\nint CSplycnF (Const struct cs_Plycn_ *plycn, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Plycn_\n structure via the \nplycn\n argument, \nCSplycnF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSplycnF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSplycnI inverse conversion\n\n\nint CSplycnI (Const struct cs_Plycn_ *plycn, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Plycn_\n structure via the \nplycn\n argument, \nCSplycnI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSplycnI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nll\n and \nxy\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSplycnK grid scale (K) along parallel\n\n\ndouble CSplycnK (Const struct cs_Plycn_ *plycn, Const double ll[2]);\n\n\n\n\nCSplycnK\n returns the value 1.0 which represents the grid scale along a parallel of any coordinate system based on this projection at any location.\n\n\nCSplycnH grid scale (H) along meridian\n\n\ndouble CSplycnH (Const struct cs_Plycn_ *plycn, Const double ll[2]);\n\n\n\n\nCSplycnH\n returns the grid scale factor, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSplycnC convergence angle\n\n\ndouble CSplycnC (Const struct cs_Plycn_ *plycn, Const double ll[2]);\n\n\n\n\nCSplycnC\n returns the convergence angle in degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. At the current time, definitive formulas for the convergence angle of this projection elude us. The convergence angle is computed using the \nCS_llazdd\n function.\n\n\nCSplycnQ definition quality check\n\n\nint CSplycnQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSplycnQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the American Polyconic Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSplycnQ\n only examines those components specific to the American Polyconic Projection. \nCSplycnQ\n returns in err_list an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSplycnQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSplycnL Latitude/longitude check\n\n\nint CSplycnL(Const struct cs_Plycn_ *plycn, int cnt, Const double pnts[][3]);\n\n\n\n\nCSplycnL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nplycn\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSplycnsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSplycnL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSplycnX Xy coordinate check\n\n\nint CSplycnX (Const struct cs_Plycn_ *plycn, int cnt, Const double pnts[][3]);\n\n\n\n\nCSplycnX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nplycn\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSplycnsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSplycnL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSplycnS setup\n\n\nvoid CSplycnS(struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSplycnS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian, the origin latitude, and other projection parameters are known, there are many calculations that need only be performed once. \nCSplycnS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCSplycnS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the American Polyconic projection are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the central meridian.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum\n\n\nThe values of equatorial radius and eccentricity are extracted from the datum element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Plycn_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nplycn\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSplycnF\n, \nCSplycnI\n, \nCSplycnK\n, \nCSplycnH\n, and \nCSplycnC\n functions require as their first argument.\n\n\nAzimuthal Equal Area Projection (CSazmea)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Lambert Azimuthal Equal Area Projection\n\n\nCsazmeaF Forward conversion\n\n\nint CSazmeaF (Const struct cs_Azmea_ *azmea, double xy[2], Const double ll[2])\n\n\n\n\nGiven a properly initialized \ncs_Azmea_\n structure via the \nazmea\n argument, \nCSazmeaF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSazmeaF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSazmeaI Inverse conversion\n\n\nint CSazmeaI (Const struct cs_Azmea_ *azmea, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Azmea_\n structure via the \nazmea\n argument, \nCSazmeaI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSazmeaI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCsazmeaK grid scale (K) normal\n\n\ndouble CSazmeaK (Const struct cs_Azmea_ * azmea, Const double ll[ 2]);\n\n\n\n\nCSazmeaK\n returns the grid scale factor normal to the radial at the geodetic location specified by the \nll\n argument. In the case of the ellipsoidal form of this projection, analytical formulas for this value have not been located and the result is arrived at using the \nCS_llazdd\n function.\n\n\nCSazmeaH grid scale (H) radial\n\n\ndouble CSazmeaH (Const struct cs_Azmea_ * azmea, Const double ll[ 2]);\n\n\n\n\nCSazmeaH\n returns the grid scale factor along a radial line from the coordinate system origin to the point provided. Since this projection is authalic (i.e. equal area), the value returned is the reciprocal of that returned by \nCSazmeaK\n.\n\n\nCSazmeaC Convergence angle\n\n\ndouble CSazmeaC (Const struct cs_Azmea_ * azmea, Const double ll[ 2]);\n\n\n\n\nCSazmeaC\n returns the convergence angle in degrees east of north of the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at using the \nCS_llazdd\n function.\n\n\nCSazmeaQ definition Quality check\n\n\nint CSazmeaQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSazmeaQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Azimuthal Equal Area Projection. \nCS_cschk\n examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSazmeaQ\n only examines those components specific to the Azimuthal Equal Area Projection. \nCSazmeaQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSazmeaQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSazmeaL Latitude/longitude check\n\n\nint CSazmeaL (Const struct cs_Azmea_ *azmea, int cnt, Const double pnts[][3]);\n\n\n\n\nCSazmeaL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nazmea\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSazmeasL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSazmeaL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSazmeaX Xy coordinate check\n\n\nint CSazmeaX (Const struct cs_Azmea_ *azmea, int cnt, Const double pnts[][3]);\n\n\n\n\nCSazmeaX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nazmea\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt == 2\n), or a closed region (\ncnt\n \n 3). \nCSazmeasX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSazmeaL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSazmeaS Setup\n\n\nvoid CSazmeaS(struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSazmeaS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once. \nCSazmeaS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the argument provided to \nCSazmeaS\n serves as the source for input and the repository for the results as described below\n\n\nCoordinate system definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time.\n\n\nThe following parameters must be set:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nThe azimuth, in degrees east of north, of the positive Y-axis of the coordinate system.\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the \ndatum\n element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Azmea_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nazmea\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSazmeaF\n, \nCSazmeaI\n, \nCSazmeaK\n, \nCSazmeaH\n, and \nCSazmeaC\n functions require as their first argument.\n\n\nAzmuthal Equidistant Projection (Csazmed)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Azimuthal Equidistant Projection.\n\n\nCSazmedF Forward conversion\n\n\nint CSazmedF (Const struct cs_Azmed_ *azmed, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Azmed_\n structure via the \nazmed\n argument, \nCSazmedF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSazmedF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSazmedI Inverse conversion\n\n\nint CSazmedI (Const struct cs_Azmed_ *azmed, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Azmed_\n structure via the \nazmed\n argument, \nCSazmedI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSazmedI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSazmedK grid scale (K) normal\n\n\ndouble CSazmedK (Const struct cs_Azmed_ *azmed, Const doubl  ll[2]);\n\n\n\n\nCSazmedK\n returns the grid scale factor normal to the radial at the geodetic location specified by the \nll\n argument. In the case of the ellipsoidal form of this projection, analytical formulas for this value have not been located and the result is arrived at using the \nCS_llazdd\n function.\n\n\nCSazmedH grid scale (H) radial\n\n\ndouble CSazmedH (Const struct cs_Azmed_ *azmed, Const double ll[2]);\n\n\n\n\nCSazmedH\n returns the value 1.0; the scale at any point in the direction of a line emanating from the origin and passing through the any point of any coordinate system based on this projection. (This is what makes this projection an Equidistant Projection.)\n\n\nCSazmedC convergence angle\n\n\ndouble CSazmedC (Const struct cs_Azmed_ *azmed, Const double ll[2]);\n\n\n\n\nCSazmedC\n returns the convergence angle in degrees east of north of the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at using the \nCS_llazdd\n function.\n\n\nCSazmedQ definition quality check\n\n\nint CSazmedQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);\n\n\n\n\nCSazmedQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Azimuthal Equidistant Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSazmedQ\n only examines those components specific to the Azimuthal Equidistant Projection. \nCSazmedQ\n returns in err_list an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSazmedQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSazmedL Latitude/longitude check\n\n\nint CSazmedL (Const struct cs_Azmed_ *azmed, int cnt, Const double pnts[][3]);\n\n\n\n\nCSazmedL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nazmed\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSazmedsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSazmedL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSazmedX Xy coordinate check\n\n\nint CSazmedX (Const struct cs_Azmed_ * azmed, int cnt, Const double pnts[][3]);\n\n\n\n\nCSazmedX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nazmed\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSazmedsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSazmedL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSazmedS Setup\n\n\nvoid CSazmedS(struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSazmedS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once. \nCSazmedS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the first argument provided to \nCSazmedS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. There are two variations to this projection:\n\n\n\n\nLambert Azimuthal Equidistant (\ncs_PRJCOD_AZMED\n)\n\n\nLambert Azimuthal Equidistant, Elevated Ellipsoid (\ncs_PRJCOD_AZEDE\n)\n\n\n\n\nThe following parameters are common to both variations:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nLambert Azimuthal Equidistant Projection\n\n\nThis is the traditional variation of the Lambert Azimuthal Equidistant projection. Note that it differs slightly from many other implementations in that it accepts a parameter value for the azimuth of the Y axis relative to true north. This provides support for local/company coordinate system. Even better local/company coordinate system support is provided by the Lambert Azimuthal Equidistant, Elevated Ellipsoid variation.\n\n\nThe parameter must be specified in degrees east of north. An azimuth west of north would be specified with a negative value.\n\n\nThe following parameters must be set:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nThe azimuth, in degrees east of north, of the positive Y-axis of the coordinate system.\n\n\n\n\n\n\n\n\nLambert Azimuthal Equidistant, Elevated Ellipsoid (cs_PRJCOD_AZEDE)\n\n\nThis variation of the Lambert Azimuthal Equidistant projection accepts an average elevation parameter which is added to the equatiorial radii of the ellipsoid. This better enbales CS-MAP to emulate a local/company coordinate system.\n\n\nThe parameter must be specified in system units. That is, if the coordinate system unit is, say, FEET; the average elevation must also be specified in feet.\n\n\nThe following parameters must be set;\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nThe azimuth, in degrees east of north, of the positive Y-axis of the coordinate system.\n\n\n\n\n\n\nprj_prm2\n\n\nThe average elevation in the region of the system, expressed in coordinate system units.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the \ndatum\n element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Azmed_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nazmed\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSazmedF\n, \nCSazmedI\n, \nCSazmedK\n, \nCSazmedH\n, and \nCSazmedC\n functions require as their first argument.\n\n\nBonne Projection Projection (CSbonne)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Bonne Projection. Setting the standard parallel equal to the equator produces a Sinusoidal Projection. Setting the standard parallel to either pole produces the Werner Projection.\n\n\nCSbonneF Forward conversion\n\n\nint CSbonneF (Const struct cs_Bonne_ *bonne, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Bonne_\n structure via the \nbonne\n argument, \nCSbonneF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSbonneF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSbonneI Inverse conversion\n\n\nint CSbonneI (Const struct cs_Bonne_ *bonne, double ll[2],Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Bonne_\n structure via the \nbonne\n argument, \nCSbonneI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSbonneI\n normally returns \ncs_CNVRT_NRM\nL. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSbonneK parallel scale (K)\n\n\ndouble CSbonneK (Const struct cs_Bonne_ *bonne, Const double ll[2]);\n\n\n\n\nCSbonneK\n returns the value 1.0 which is the grid scale factor, along any parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSbonneH meridian scale (H)\n\n\ndouble CSbonneH (Const struct cs_Bonne_ *bonne, Const double ll[2]);\n\n\n\n\nCSbonneK\n returns the grid scale, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. Analytical formulas for this value have not been located and the result is arrived at using the \nCS_llazdd\n function.\n\n\nCSbonneC Convergence angle\n\n\ndouble CSbonneC (Const struct cs_Bonne_ *bonne, Const double ll[2]);\n\n\n\n\nCSbonneC\n returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. Analytical formulas for this value have not been located and the result is arrived at using the \nCS_llazdd\n function.\n\n\nCSbonneQ definition quality check\n\n\nint CSbonneQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSbonneQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Boone Projection. \nCS_cschk\n examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSbonneQ\n only examines those components specific to the Bonne Projection. \nCSbonneQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSbonneQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSbonneL Latitude/longitude check\n\n\nint CSbonneL (Const struct cs_Bonne_ *bonne, int cnt, Const double pnts[][3]);\n\n\n\n\nCSbonneL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nbonne\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSbonnesL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSbonneL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSbonneX Xy coordinate check\n\n\nint CSbonneX (Const struct cs_Bonne_ *bonne, int cnt, Const double pnts[][3]);\n\n\n\n\nCSbonneX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nbonne\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSbonnesX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSbonneL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSbonneS Setup\n\n\nvoid CSbonneS (struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSbonneS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallel, the origin longitude, and other projection parameters are known, there are many calculations that need only be performed once. \nCSbonneS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCSbonneS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the Bonne Projection are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the central meridian of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the standard parallel of the projection.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nquad\n\n\nan integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the \ndatum\n element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Bonne_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nbonne\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSbonneF\n, \nCSbonneI\n, \nCSbonneK\n, \nCSbonneH\n, and \nCSbonneC\n functions require as their first argument.\n\n\nBipolar Oblique Conformal Conic Projection (CSbpcnc)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Bipolar Oblique Conformal Conic Projection. This projection was developed, by O. M. Miller (of Miller Cylindrical fame), specifically for mapping both the North American and South American continents on the same conformal map. This projection is supported for the sphere only. The equatorial radius of the referenced ellipsoid is used as the radius of the sphere.\n\n\nCSbpcncF Forward conversion\n\n\nint CSbpcncF (Const struct cs_Bpcnc_ *bpcnc, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Bpcnc_\n structure via the \nbpcnc\n argument, \nCSbpcncF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSbpcncF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSbpcncI Inverse conversion\n\n\nint CSbpcncI (Const struct cs_Bpcnc_ *bpcnc, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Bpcnc_\n structure via the \nbpcnc\n argument, \nCSbpcncI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSbpcncI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSbpcncK parallel scale (K)\n\n\ndouble CSbpcncK ( Const struct cs_Bpcnc_ *bpcnc, Const double ll[2]);\n\n\n\n\nCSbpcncK\n returns the grid scale factor, as measured along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. Since this is a conformal projection, there is no H function as the scale along a meridian equals the scale along a parallel.\n\n\nCSbpcncC Convergence angle\n\n\ndouble CSbpcncC ( Const struct cs_Bpcnc_ *bpcnc, Const double ll[2]);\n\n\n\n\nCSbpcncC\n returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. At the current time, formulas that analytically define the convergence angle for this projection elude us. Thus, the convergence angle is determined empirically through the use of the \nCS_llazdd\n function.\n\n\nCSbpcncQ definition quality check\n\n\nint CSbpcncQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSbpcncQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Bi-Polar Conformal Conic Projection. \nCS_cschk\n examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSbpcncQ\n only examines those components specific to the Bi-Polar Conformal Conic Projection. \nCSbpcncQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSbpcncQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSbpcncL Latitude/longitude check\n\n\nint CSbpcncL (Const struct cs_Bpcnc_ *bpcnc, int cnt, Const double pnts[][3]);\n\n\n\n\nCSbpcncL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nbpcnc\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSbpcncsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSbpcncL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSbpcncX Xy coordinate check\n\n\nint CSbpcncX ( Const struct cs_Bpcnc_ *bpcnc, int cnt , Const double pnts[][3]);\n\n\n\n\nCSbpcncX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nbpcnc\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSbpcncsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSbpcncL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSbpcncS Setup\n\n\nvoid CSbpcncS(struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSbpcncS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the poles, the standard parallels, and other projection parameters are known, there are many calculations that need only be performed once. \nCSbpcncS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCSbpcncS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. As far as we know, this projection is usually used only for the specific coordinate system for which it was invented. However, to remain consistent with the rest of CS-MAP, the following parameters can be specified. These parameters specify the location of the two poles upon which the projection is based. The first is always specified by latitude and longitude. The latitude of the second pole must always be specified. However, the longitude of the second pole can be specified either directly (\nprj_prm3\n) or as an angular distance from the first pole (\nprj_prm5\n). If \nprj_prm5\n is greater than zero, the second method is used. In the listing of parameters given below, the values used for the specific map for which this projection was developed are given. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the Bipolar Oblique Conformal Projection are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the first pole (usually the southwest). [- 110.0]\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the first pole. [-20.0]\n\n\n\n\n\n\nprj_prm3\n\n\nLongitude, in degrees, of the second pole (usually the northeast). [-19.99333333333]\n\n\n\n\n\n\nprj_prm4\n\n\nLatitude, in degrees, of the second pole. [+45.0]\n\n\n\n\n\n\nprj_prm5\n\n\nIf greater than zero, this value is considered to be the angular distance, in degrees, from the first pole to the second pole and the longitude of the second pole is computed as such. If this value is less than or equal to zero, the value provided in prj_prm3 is considered the longitude of the second pole. [+104.0]\n\n\n\n\n\n\nprj_prm6\n\n\nAngular distance, in degrees, from either pole to the first of two standard parallels. [+31.0]\n\n\n\n\n\n\nprj_prm7\n\n\nAngular distance, in degrees, from either pole to the second of two standard parallels. [+73.0]\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied. [1.0]\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. [0.0]\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates. [0.0]\n\n\n\n\n\n\nquad\n\n\nan integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe value of equatorial radius is extracted from the datum element of the \ncs_Csprm_\n structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required element is:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe radius of the earth, as a sphere, in meters\n\n\n\n\n\n\n\n\ncs_Bpcnc_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nbpcnc\n element of the \nprj_prm\ns union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSbpcncF\n, \nCSbpcncI\n, \nCSbpcncK\n, \nCSbpcncH\n, \nCSbpcncC\n, and \nCSbpcncB\n functions require as their first argument.\n\n\nCassini Projection (CScsini)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Cassini Projection\n\n\nCScsiniF Forward\n\n\nint CScsiniF (Const struct cs_Csini_ *csini, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Csini_\n structure via the \ncsini\n argument, \nCScsiniI\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCScsiniF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCScsiniI Inverse\n\n\nint CScsiniI (Const struct cs_Csini_ *csini, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Csini_\n structure via the \ncsini\n argument, \nCScsiniI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCScsiniI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCScsiniK parallel scale (K)\n\n\ndouble CScsiniK (Const struct cs_Csini_ *csini, Const double ll[2]);\n\n\n\n\nCScsiniK\n returns the grid scale factor along a line normal to the central meridian of the coordinate system at the geographic location defined by the latitude and longitude provided in the \nll\n array. It is a specific feature of this projection that this scale factor is unity.\n\n\nCScsiniH meridian scale (H)\n\n\ndouble CScsiniH (Const struct cs_Csini_ *csini, Const double ll[2]);\n\n\n\n\nCScsiniH\n returns the grid scale factor along a line parallel to the central meridian of the coordinate system at the geographic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCScsiniC Convergence angle\n\n\ndouble CScsiniC (Const struct cs_Csini_ *csini, Const double ll[2]);\n\n\n\n\nCScsiniC\n returns the convergence angle, in degrees east of north, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. As analytical formulas for this quantity have not yet been located, the result is arrived at empirically using \nCS_aslldd\n.\n\n\nCScsiniQ definition Quality check\n\n\nint CScsiniQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCScsiniQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Cassini Projection. \nCS_cschk\n examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, \nCScsiniQ\n only examines those components specific to the Cassini Projection. \nCScsiniQ\n returns in err_list an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCScsiniQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCScsiniL Latitude/longitude check\n\n\nint CScsiniL (Const struct cs_Csini_ *csini, int cnt, Const double pnts[][3]);\n\n\n\n\nCScsiniL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \ncsini\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCScsinisL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCScsiniL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCScsiniX Xy coordinate check\n\n\nint CScsiniX (Const struct cs_Csini_ *csini, int cnt, Const double pnts[][3]);\n\n\n\n\nCScsiniX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \ncsini\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCScsinisX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCScsiniL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCScsiniS Setup\n\n\nvoid CScsiniS (struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCScsiniS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian, the origin latitude, and other projection parameters are known, there are many calculations that need only be performed once. \nCScsiniS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCScsiniS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the Cassini projection are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the central meridian.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\nScale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units, and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nQuad\n\n\nan integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the datum element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Csini_ Structure\n\n\nThe results of the one-time calculations are recorded in the \ncsini\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCScsiniF\n, \nCScsiniI\n, \nCScsiniK\n, \nCScsiniH\n, and \nCScsiniC\n functions require as their first argument.\n\n\nDanish System 34 (CSsys34)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Danish System 34 Projection. This projection is supported in ellipsoid form only; and most ordinary parameters are hard coded and selected via the 'region' (\nprj_prm1\n) parameter.\n\n\nCSsys34C Convergence angle\n\n\ndouble CSsys34C ( Const struct cs_Sys34_ *sys34, Const double ll[2]);\n\n\n\n\nCSsys34C\n returns the convergence angle in degrees east of north of the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the \nCS_azlld\n function.\n\n\nCSsys34F Forward conversion\n\n\nint CSsys34F (Const struct cs_Sys34_ *sys34, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Sys34_\n structure via the \nsys34\n argument, \nCSsys34F\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSsys34F\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSsys34I Inverse conversion\n\n\nint CSsys34I (Const struct cs_Sys34_ *sys34, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Sys34_\n structure via the \nsys34\n argument, \nCSsys34I\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSsys34I\n normally returns \ncs_CNVRT_NRM\nL. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSsys34K parallel scale (K)\n\n\ndouble CSsys34K (Const struct cs_Sys34_ *sys34, Const double ll[2]);\n\n\n\n\nCSsys34K\n returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of the \nCS_llazdd\n function.\n\n\nCSsys34H meridian scale (H)\n\n\ndouble CSsys34H (Const struct cs_Sys34_ * ys34, Const double ll[2]);\n\n\n\n\nCSsys34H\n returns the grid scale factor along a meridian at the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of the \nCS_llazdd\n function.\n\n\nCSsys34L Latitude/longitude check\n\n\nint CSsys34L (Const struct cs_Sys34_ *sys34, int cnt, Const double pnts[][3]);\n\n\n\n\nCSsys34L\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nsys34\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSsys34sL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSsys34L\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSsys34Q definition quality check\n\n\nint CSsys34Q (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);\n\n\n\n\nCSsys34Q\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Danish System 34 Projection. \nCS_cschk\n examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSsys34Q\n only examines those components specific to the Danish System 34 Projection. \nCSsys34Q\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSsys34Q\n may be called with the NULL pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSsys34X Xy coordinate check\n\n\nint CSsys34X (Const struct cs_Sys34_ *sys34, int cnt , Const double pnts[][3]);\n\n\n\n\nCSsys34X\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nsys34\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSsys34sX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSsys34L\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSsys34S Setup (general)\n\n\nvoid CSsys34S (struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSsys34S\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the zone and other projection parameters are known, there are many calculations that need only be performed once. \nCSsys34S\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the argument provided to \nCSsys34S\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time.\n\n\nThe following parameters must be set:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nIndicates which of the three regions is to apply 1.0 ==\n jylland; 2.0 ==\n sj\u00e6lland, 3.0 ==\n bornholm.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the datum element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Sys34_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nsys34\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSsys344F\n, \nCSsys344I\n, \nCSsys344K\n, \nCSsys344H\n, and \nCSsys34C\n functions require as their first argument.\n\n\nEquidistant Conic Projection (CSedcnc)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Equidistant Conic Projection, also known as the Simple Conic Projection.\n\n\nCSedcncF Forward conversion\n\n\nint CSedcncF (Const struct cs_Edcnc_ *edcnc, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Edcnc_\n structure via the \nedcnc\n argument, \nCSedcncF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSedcncF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSedcncI Inverse conversion\n\n\nint CSedcncI (Const struct cs_Edcnc_ *edcnc, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Edcnc_\n structure via the \nedcnc\n argument, \nCSedcncI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSedcncI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSedcncK parallel scale (K)\n\n\ndouble CSedcncK (Const struct cs_Edcnc_ *edcnc, Const double ll[2]);\n\n\n\n\nCSedcncK\n returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSedcncH meridian scale (H)\n\n\ndouble CSedcncH (Const struct cs_Edcnc_ *edcnc, Const double ll[2]);\n\n\n\n\nCSedcncH\n returns the value of 1.0 that represents the grid scale, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. That is, all distances measured along a meridian of this projection are true to scale, the essence of this projection.\n\n\nCSedcncC Convergence angle\n\n\ndouble CSedcncC (Const struct cs_Edcnc_ *edcnc, Const double ll[2]);\n\n\n\n\nCSedcncC\n returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSedcncQ definition Quality check\n\n\nint CSedcncQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSedcncQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Equidistant Conic Projection. \nCS_cschk\n examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSedcncQ\n only examines those components specific to the Equidistant Conic Projection. \nCSedcncQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSedcncQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSedcncL Latitude/longitude check\n\n\nint CSedcncL (Const struct cs_Edcnc_ *edcnc, int cnt, Const double pnts[][3]);\n\n\n\n\nCSedcncL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nedcnc\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSedcncsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSedcncL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSedcncX Xy coordinate check\n\n\nint CSedcncX (Const struct cs_Edcnc_ *edcnc, int cnt, Const double pnts[][3]);\n\n\n\n\nCSedcncX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nedcnc\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSedcncsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSedcncL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSedcncS Setup\n\n\nvoid CSedcncS (struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSedcncS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallels, the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once. \nCSedcncS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCSedcncS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the Equidistant Conic projection are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLatitude, in degrees, of the first standard parallel, usually the northernmost (it makes no difference).\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency (i.e. a single standard parallel).\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the datum element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Edcnc_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nedcnc\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSedcncF\n, \nCSedcncI\n, \nCSedcncK\n, \nCSedcncH\n, and \nCSedcncC\n functions require as their first argument.\n\n\nEquidistant Cylindrical Projection (CSedcyl)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Equidistant Cylindrical Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere. This projection is also known as the Equirectangular or Rectangular projection. When the reference latitude of this projection is set to zero (i.e. the equator) the result is equivalent to what is known as the Plate Carre\u0301e or Simple Cylindrical projection. When the reference latitude is set to 45? (north or south), a Gall Isographic projection results.\n\n\nCSedcylF Forward conversion\n\n\nint CSedcylF (Const struct cs_Edcyl_ *edcyl,double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Edcyl_\n structure via the \nedcyl\n argument, \nCSedcylF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSedcylF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSedcylI Inverse conversion\n\n\nint CSedcylI (Const struct cs_Edcyl_ *edcyl, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Edcyl_\n structure via the \nedcyl\n argument, \nCSedcylI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSedcylI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system.\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSedcylK parallel scale (K)\n\n\ndouble CSedcylK (Const struct cs_Edcyl_ *edcyl, Const double ll[2]);\n\n\n\n\nCSedcylK\n returns the grid scale factor along a parallel at the geodetic location specified by the \nll\n argument.\n\n\nCSedcylH meridional scale (H)\n\n\ndouble CSedcylH (Const struct cs_Edcyl_ *edcyl, Const double ll[2]);\n\n\n\n\nCSedcylH\n returns the grid scale factor along a meridian at the geodetic location specified by the \nll\n argument.\n\n\nCSedcylC Convergence angle\n\n\ndouble CSedcylC (Const struct cs_Edcyl_ *edcyl, Const double ll[2]);\n\n\n\n\nCSedcylC\n returns the convergence angle in degrees east of north of the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at using the \nCS_azsphr\n function.\n\n\nCSedcylQ definition Quality check\n\n\nint CSedcylQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSedcylQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Equidistant Cylindrical Projection. \nCS_cschk\n examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSedcylQ\n only examines those components specific to the Equidistant Cylindrical Projection. \nCSedcylQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSedcylQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSedcylL Latitude/longitude check\n\n\nint CSedcylL (Const struct cs_Edcyl_ *edcyl, int cnt, Const double pnts[][3]);\n\n\n\n\nCSedcylL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nedcyl\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSedcylsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSedcylL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSedcylX Xy coordinate check\n\n\nint CSedcylX (Const struct cs_Edcyl_ *edcyl, int cnt, Const double pnts[][3]);\n\n\n\n\nCSedcylX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nedcyl\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSedcylsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSedcylL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSedcylS Setup\n\n\nvoid CSedcylS(struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSedcylS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the reference parallel, origin longitude, and other projection parameters are known, there are many calculations which need only be performed once. \nCSedcylS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the argument provided to \nCSedcylS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The following parameters are used:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nThe latitude, in degrees, of the reference parallel.\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe value of equatorial radius is extracted from the datum element of the \ncs_Csprm_\n structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required element is:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe radius of the earth, as a sphere, in meters.\n\n\n\n\n\n\n\n\ncs_Edcyl_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nedcyl\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSedcylF\n, \nCSedcylI\n, \nCSedcylK\n, \nCsedcylH\n, and \nCSedcylC\n functions require as their first argument.\n\n\nEckert IV Projection (CSekrt4)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Eckert IV Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.\n\n\nCSekrt4F Forward conversion\n\n\nint CSekrt4F (Const struct cs_Ekrt4_ *ekrt4, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Ekrt4_\n structure via the \nekrt4\n argument, \nCSekrt4F\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSekrt4F\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSekrt4I Inverse conversion\n\n\nint CSekrt4I (Const struct cs_Ekrt4_ *ekrt4, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Ekrt4_\n structure via the \nekrt4\n argument, \nCSekrt4I\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSekrt4I\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSekrt4K parallel scale (K)\n\n\ndouble CSekrt4K (Const struct cs_Ekrt4_ *ekrt4, Const double ll[2]);\n\n\n\n\nCSekrt4K\n returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.\n\n\nCSekrt4H meridian scale (H)\n\n\ndouble CSekrt4H (Const struct cs_Ekrt4_ *ekrt4, Const double ll[2]);\n\n\n\n\nCSekrt4H\n returns the grid scale factor along a meridian at the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.\n\n\nCSekrt4C Convergence angle\n\n\ndouble CSekrt4C (Const struct cs_Ekrt4_ *ekrt4, Const double ll[2]);\n\n\n\n\nCSekrt4C\n returns the convergence angle in degrees east of north of the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the \nCS_azsphr\n function.\n\n\nCSekrt4Q definition quality check\n\n\nint CSekrt4Q (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);\n\n\n\n\nCSekrt4Q\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Eckert IV Projection. \nCS_cschk\n examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSekrt4Q\n only examines those components specific to the Eckert IV Projection. \nCSekrt4Q\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSekrt4Q\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSekrt4L Latitude/longitude check\n\n\nint CSekrt4L (Const struct cs_Ekrt4_ *ekrt4, int cnt, Const double pnts[][3]);\n\n\n\n\nCSekrt4L\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nekrt4\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSekrt4sL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSekrt4L\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSekrt4X Xy coordinate check\n\n\nint CSekrt4X ( Const struct cs_Ekrt4_ *ekrt4, int cnt, Const double pnts[][3]);\n\n\n\n\nCSekrt4X\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nekrt4\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSekrt4sX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSekrt4L\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSekrt4S Setup (general)\n\n\nvoid CSekrt4S( struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSekrt4S\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian and other projection parameters are known, there are many calculations that need only be performed once. \nCSekrt4S\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the argument provided to \nCSekrt4S\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The following parameters are used:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection (central meridian).\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe value of equatorial radius is extracted from the datum element of the \ncs_Csprm_\n structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required element is:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe radius of the earth, as a sphere, in meters.\n\n\n\n\n\n\n\n\ncs_Ekrt4 Structure\n\n\nThe results of the one-time calculations are recorded in the \nekrt4\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSekrt4F\n, \nCSekrt4I\n, \nCSekrt4K\n, \nCSekrt4H\n, and \nCSekrt4C\n functions require as their first argument.\n\n\nEckert VI Projection (CSekrt6)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Eckert VI Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.\n\n\nCSekrt6F forward conversion\n\n\nint CSekrt6F ( Const struct cs_Ekrt6_ *ekrt6, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Ekrt6_\n structure via the \nekrt6\n argument, \nCSekrt6F\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSekrt6F\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSekrt6I Inverse conversion\n\n\nint CSekrt6I ( Const struct cs_Ekrt6_ *ekrt6, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Ekrt6_\n structure via the \nekrt6\n argument, \nCSekrt6I\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSekrt6I\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSekrt6K parallel scale (K)\n\n\ndouble CSekrt6K ( Const struct cs_Ekrt6_ *ekrt6, Const double ll[2]);\n\n\n\n\nCSekrt6K\n returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.\n\n\nCSekrt6H meridian scale (H)\n\n\ndouble CSekrt6H ( Const struct cs_Ekrt6_ *ekrt6, Const double ll[2]);\n\n\n\n\nCSekrt6H\n returns the grid scale factor along a meridian at the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.\n\n\nCSekrt6C Convergence angle\n\n\ndouble CSekrt6C ( Const struct cs_Ekrt6_ *ekrt6, Const double ll [2]);\n\n\n\n\nCSekrt6C\n returns the convergence angle in degrees east of north of the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the \nCS_azsphr\n function.\n\n\nCSekrt6Q definition quality check\n\n\nint Csekrt6Q( Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);\n\n\n\n\nCSekrt6Q\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Eckert VI Projection. \nCS_cschk\n examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSekrt6Q\n only examines those components specific to the Eckert VI Projection. \nCSekrt6Q\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSekrt6Q\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSekrt6L Latitude/longitude check\n\n\nint Csekrt6L (Const struct cs_Ekrt6_ *ekrt4, int cnt, Const double pnts[][3]);\n\n\n\n\nCSekrt6L\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nekrt6\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSekrt6sL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSekrt6L\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSekrt6X Xy coordinate check\n\n\nint Csekrt6X (Const struct cs_Ekrt6_ *ekrt4, int cnt, Const double pnts[][3]);\n\n\n\n\nCSekrt6X\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nekrt6\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSekrt6sX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSekrt6L\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSekrt6S Setup (general)\n\n\nvoid CSekrt6S(struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSekrt6S\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian and other projection parameters are known, there are many calculations which need only be performed once. \nCSekrt6S\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the argument provided to \nCSekrt6S\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The following parameters are used:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection (central meridian).\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum definition\n\n\nThe value of equatorial radius is extracted from the datum element of the \ncs_Csprm_\n structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required element is:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe radius of the earth, as a sphere, in meters.\n\n\n\n\n\n\n\n\ncs_Ekrt6_ structure\n\n\nThe results of the one-time calculations are recorded in the \nekrt6\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSekrt6F\n, \nCSekrt6I\n, \nCSekrt6K\n, \nCSekrt6H\n, and \nCSekrt6C\n functions require as their first argument.\n\n\nGnomonic Projection (CSgnomc)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Gnomonic Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.\n\n\nThe Gnomonic projection cannot process locations that are 90 degrees or more away from the projection origin. Coordinates that exceed this limit are adjusted to fall on the great circle that defines this limit.\n\n\nCsgnomcF Forward conversion\n\n\nint CSgnomcF ( Const struct cs_Gnomc_ *gnomc, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Gnomc_\n structure via the \ngnomc\n argument, \nCSgnomcF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSgnomcF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCsgnomcI inverse conversion\n\n\nint CSgnomcI (Const struct cs_Gnomc_ *gnomc, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Gnomc_\n structure via the \ngnomc\n argument, \nCSgnomcI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSgnomcI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCsgnomcK grid scale (K) normal to radial\n\n\ndouble CSgnomcK (Const struct cs_Gnomc_ *gnomc, Const double ll[2]);\n\n\n\n\nCSgnomcK\n returns the grid scale factor normal to the radial at the geodetic location specified by the \nll\n argument.\n\n\nCsgnomcH grid scale (H) along radial\n\n\ndouble CSgnomcH (Const struct cs_Gnomc_ *gnomc, Const double ll[2]);\n\n\n\n\nCSgnomcH\n returns the grid scale factor along a radial from the coordinate system origin to (and at) the geodetic location specified by the \nll\n argument.\n\n\nCsgnomcC Convergence angle\n\n\ndouble CSgnomcC (Const struct cs_Gnomc_ * gnomc, Const double ll[2]);\n\n\n\n\nCSgnomcC\n returns the convergence angle in degrees east of north of the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the \nCS_azsphr\n function.\n\n\nCsgnomcL Latitude/longitude check\n\n\nint CSgnomcL (Const struct cs_Gnomc_ * gnomc, int cnt, Const double pnts[][3]);\n\n\n\n\nCSgnomcL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \ngnomc\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSgnomcsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSgnomcL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSgnomcQ definition quality check\n\n\nint CSgnomcQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSgnomcQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Gnomonic Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSgnomcQ\n only examines those components specific to the Gnomonic Projection. \nCSgnomcQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSgnomcQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCsgnomcX Xy coordinate check`\n\n\nint CSgnomcX (Const struct cs_Gnomc_ * gnomc, int cnt, Const double pnts[][3]);\n\n\n\n\nCSgnomcX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the gnomc argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSgnomcsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSgnomcL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSgnomcS Setup\n\n\nvoid CSgnomcS(struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSgnomcS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude and other projection parameters are known, there are many calculations that need only be performed once. \nCSgnomcS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the argument provided to \nCSgnomcS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The following parameters are used:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe value of equatorial radius is extracted from the datum element of the \ncs_Csprm_\n structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required element is:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe radius of the earth, as a sphere, in meters.\n\n\n\n\n\n\n\n\ncs_Gnomc_ Structure\n\n\nThe results of the one-time calculations are recorded in the \ngnomc\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSgnomcF\n, \nCSgnomcI\n, \nCSgnomcK\n, \nCSgnomcH\n, and \nCSgnomcC\n functions require as their first argument.\n\n\nGoode Homolosine Projection (CShmlsn)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Goode Homolosine Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.\n\n\nCShmlsnF forward conversion\n\n\nint CShmlsnF (Const struct cs_Hmlsn_ *hmlsn, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Hmlsn_\n structure via the \nhmlsn\n argument, \nCShmlsnF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCShmlsnF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCShmlsnI Inverse conversion\n\n\nint CShmlsnI (Const struct cs_Hmlsn_ *hmlsn, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Hmlsn_\n structure via the \nhmlsn\n argument, \nCShmlsnI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCShmlsnI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCShmlsnK parallel scale (K)\n\n\ndouble CShmlsnK (Const struct cs_Hmlsn_ *hmlsn, Const double ll[2]);\n\n\n\n\nCShmlsnK\n returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.\n\n\nCShmlsnH meridian scale (H)\n\n\ndouble CShmlsnH (Const struct cs_Hmlsn_ *hmlsn, Const double ll[2]);\n\n\n\n\nCShmlsnH\n returns the grid scale factor along a meridian at the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.\n\n\nCShmlsnC Convergence angle\n\n\ndouble CShmlsnC (Const struct cs_Hmlsn_ *hmlsn, Const double ll[2]);\n\n\n\n\nCShmlsnC\n returns the convergence angle in degrees east of north of the geodetic location specified by the \nll\n argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the \nCS_azsphr\n function.\n\n\nCShmlsnQ definition quality check\n\n\nint CShmlsnQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);\n\n\n\n\nCShmlsnQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Goode Homolosine Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCShmlsnQ\n only examines those components specific to the Goode Homolosine Projection. \nCShmlsnQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_lis\nt, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCShmlsnQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCShmlsnL Latitude/longitude check\n\n\nint CShmlsnL (Const struct cs_Hmlsn_ *hmlsn, int cnt, Const double pnts[][3]);\n\n\n\n\nCShmlsnL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nhmlsn\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCShmlsnsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCShmlsnL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCShmlsnX Xy coordinate check\n\n\nint CShmlsnX (Const struct cs_Hmlsn_ *hmlsn, int cnt, Const double pnts[][3]);\n\n\n\n\nCShmlsnX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nhmlsn\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCShmlsnsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCShmlsnL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCShmlsnS Setup (general)\n\n\nvoid CShmlsnS (struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCShmlsnS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin longitude and other projection parameters are known, there are many calculations which need only be performed once. \nCShmlsnS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the argument provided to \nCShmlsnS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The following parameters are used:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection (central meridian).\n\n\n\n\n\n\nprj_prm1-24\n\n\nThe interrupted form of the Goode Homolosine Projection is fully supported. cs_Csdef _ elements prj_prm1 thru prj_prm24 can be used to specify the extents of the different zones. See \nCS_zones\n for information on how to encode zones.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe value of equatorial radius is extracted from the datum element of the \ncs_Csprm_\n structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required element is:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe radius of the earth, as a sphere, in meters.\n\n\n\n\n\n\n\n\ncs_Hmlsn_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nhmlsn\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCShmlsnF\n, \nCShmlsnI\n, \nCShmlsnK\n, \nCShmlsnH\n, and \nCShmlsnC\n functions require as their first argument.\n\n\nHotine Oblique Mercator Projection (CSoblqm)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Hotine Oblique Mercator Projection. Since this projection is conformal, the K and H scale factors are the same and there is no H function. Six variations of this projection are supported.\n\n\nCSoblqmF Forward conversion\n\n\nint CSoblqmF (Const struct cs_Oblqm_ *oblqm, double xy 2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Oblqm_\n structure via the \noblqm\n argument, \nCSoblqmF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSoblqmF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSoblqmI Inverse conversion\n\n\nint CSoblqmI (Const struct cs_Oblqm_ *oblqm, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Oblqm_\n structure via the \noblqm\n argument, \nCSoblqmI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSoblqmI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSoblqmK scale (K)\n\n\ndouble CSoblqmK (Const struct cs_Oblqm_ *oblqm, Const double ll[2]);\n\n\n\n\nCSoblqmK\n returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. This is calculated using \nCS_llazdd\n as we have been unable to locate definitive formulas for the grid scale factor for this projection.\n\n\nCSoblqmC Convergence angle\n\n\ndouble CSoblqmC (Const struct cs_Oblqm_ *oblqm, Const double ll[2]);\n\n\n\n\nCSoblqmC\n returns the convergence angle is degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. This is calculated using \nCS_llazdd\n as we have been unable to locate definitive formulas for the convergence angle for this projection.\n\n\nCSoblqmQ definition quality check\n\n\nint CSoblqmQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);\n\n\n\n\nCSoblqmQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Oblique Mercator (Hotine) Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSoblqmQ\n only examines those components specific to the Oblique Mercator (Hotine) Projection. \nCSoblqmQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSoblqmQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSoblqmL Latitude/longitude check\n\n\nint CSoblqmL (Const struct cs_Oblqm_ *oblqm, int cnt, Const double pnts[][3]);\n\n\n\n\nCSoblqmL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \noblqm\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSoblqmsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSoblqmL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSoblqmX Xy coordinate check\n\n\nint CSoblqmX (Const struct cs_Oblqm_ *oblqm, int cnt, Const double pnts[][3]);\n\n\n\n\nCSoblqmX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \noblqm\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSoblqmsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSoblqmL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSoblqmS Setup\n\n\nvoid CSoblqmS(struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSoblqmS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central great circle, the origin latitude, and other projection parameters are known, there are many calculations that need only be performed once. \nCSoblqmS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by the \ncsprm\n argument. Thus, this one argument provides \nCSoblqmS\n its input data and the repository for the results as described below.\n\n\nCSoblqmS\n examines the \nprj_code\n element of the \ncs_Csprm_\n structure to determine which of the six variations of this projection is to be setup. In most cases, the variations require different usage of the parameters in the \ncs_Csdef_\n structure as defined below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csldef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the Oblique Mercator projection are dependent upon the variation being implemented.\n\n\nThe following parameters apply to all six variations of the projection:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nscl_red\n\n\nThe scale reduction that is to be applied.\n\n\n\n\n\n\nScale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nQuad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nSingle Point, Unrectified Hotine Oblique Mercator (cs_PRJCOD_HOM1UV)\n\n\nThis variation produces unrectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the \"aposphere\". Rarely, if ever used; retained primarily for historical purposes.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the central point of the projection.\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the central point of the projection.\n\n\n\n\n\n\nprj_prm3\n\n\nThe azimuth of the central great circle, in degrees east of north.\n\n\n\n\n\n\n\n\nTwo Point, Unrectified Hotine Oblique Mercator (cs_PRJCOD_HOM2UV)\n\n\nThis variation produces unrectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the \"aposphere.\" Rarely, if ever used; retained primarily for historical purposes.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the first point on the central geodesic.\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the first point on the central geodesic.\n\n\n\n\n\n\nprj_prm3\n\n\nLongitude, in degrees, of the second point on the central geodesic.\n\n\n\n\n\n\nprj_prm4\n\n\nLatitude, in degrees, of the second point on the central geodesic.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the center of the coordinate system being defined. That is, the point on the central geodesic that has this latitude is the natural origin of the projection.\n\n\n\n\n\n\n\n\nAlaska Variation, Hotine Oblique Mercator (cs_PRJCOD_HOM1XY)\n\n\nThis variation produces rectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the \"aposphere\". The rectification technique is specific to Zone 1 of the Alaska State Plane Coordinate System. It is possible that this variation should also be used for the Great Lakes Survey, but this has not been verified as of this writing.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the central point of the projection.\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the central point of the projection.\n\n\n\n\n\n\nprj_prm3\n\n\nThe azimuth of the central great circle, in degrees east of north.\n\n\n\n\n\n\n\n\nTwo Point, Rectified Hotine Oblique Mercator (cs_PRJCOD_HOM2XY)\n\n\nThis variation produces rectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the \"aposphere\". Rarely, if ever used; retained primarily for historical purposes. To remain consistent with prior releases of CS-MAP, this variation uses the same rectification technique as the Alaska variation described immediately above.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the first point on the central geodesic.\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the first point on the central geodesic.\n\n\n\n\n\n\nprj_prm3\n\n\nLongitude, in degrees, of the second point on the central geodesic.\n\n\n\n\n\n\nprj_prm4\n\n\nLatitude, in degrees, of the second point on the central geodesic.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the center of the coordinate system being defined. That is, the point on the central geodesic that has this latitude is the natural origin of the projection.\n\n\n\n\n\n\n\n\nRectified Skew Orthomorphic (cs_PRJCOD_RSKEW)\n\n\nThis variation produces rectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the \"aposphere\". The rectification technique is that commonly used in places other than Alaska.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the central point of the projection.\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the central point of the projection.\n\n\n\n\n\n\nprj_prm3\n\n\nThe azimuth of the central great circle, in degrees east of north.\n\n\n\n\n\n\n\n\nRectified Skew Orthomorphic Centered (cs_PRJCOD_RSKEWC)\n\n\nThis variation produces rectified cartesian coordinates, the origin of which is at the single defining point. The rectification technique is that commonly used in places other than Alaska.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the central point of the projection.\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the central point of the projection.\n\n\n\n\n\n\nprj_prm3\n\n\nThe azimuth of the central great circle, in degrees east of north.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the datum element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Oblqm_ Structure\n\n\nThe results of the one-time calculations are recorded in the \noblqm\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSoblqmF\n, \nCSoblqmI\n, \nCSoblqmK\n, and \nCSoblqmC\n functions require as their first argument.\n\n\nKrovak Oblique Conformal Conic\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Krovak Oblique Conformal Conic Projection. This projection is used in what used to be Czechoslovokia, and is now the Czech Republic and the Slovak Republic. Since this projection is conformal, the K and H scale factors are the same and there is no H function. Two variations of this projection are supported.\n\n\nThe first variation is the traditional projection as used since the 1920's. The second includes the affine transformation devised for use with the 1995 adjustment.\n\n\nPlease note that traditional Krovak X coordinates increase to the west. When such coordinates are used in the traditional CAD environment, the resulting images are mirrored and are (for most folks anyway) useless. Therefore, this implementation is such that what would normally be positive X coordinates are actually negative coordinates, and the magnitude of the values will be correct. In this way, the absolute value of the coordinate will be what is expected to see, but the coordinates will actually increase to the east, thus making AutoCAD, MicroStation, and other CAD type systems happy campers.\n\n\nCSkrovkF Forward Conversion\n\n\nint CSkrovkF (Const struct cs_Krovk_ *krovk, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Krovk_\n structure via the \nkrovk\n argument, \nCSkrovkF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSkrovkF\n normally returns \ncs_CNVRT_NRM\nL. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nThe \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSkrovkI Inverse conversion\n\n\nint CSkrovkI (Const struct cs_Krovk_ *krovk, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Krovk_\n structure via the \nkrovk\n argument, \nCSkrovkI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSkrovkI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the xy value is not within the domain of the coordinate system.\n\n\nThe \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSkrovkK scale (K)\n\n\ndouble CSkrovkK (Const struct cs_Krovk_ *krovk, Const double ll[2]);\n\n\n\n\nCSkrovkK\n returns the grid scale factor of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. The value \ncs_SclInf\n (defined to be 9,999.00 is CSdata.c) is returned if the \nll\n provided is the oblique pole.\n\n\nCSkrovkC Convergence angle\n\n\ndouble CSkrovkC (Const struct cs_Krovk_ *krovk, Const double ll[2]);\n\n\n\n\nCSkrovkC\n returns the convergence angle in degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSkrovkQ definition quality check\n\n\nint CSkrovkQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);\n\n\n\n\nCSkrovkQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Krovak Oblique Conformal Conic Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSkrovakQ\n only examines those components specific to the Krovak Oblique Conformal Conic Projection. \nCSkrovkQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSkrovkQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nBugs\n\n\nIn the original implementation of this projection, all parameters were hard coded and no checking was necessary. For release 10, this projection was rewritten to accept user defined parameters, but this quality check function was never updated. Therefore, at the current time, there is no parameter checking performed for this projection.\n\n\nCSkrovkL Latitude/longitude check\n\n\nint CSoblqmL (Const struct cs_Oblqm_ *oblqm, int cnt, Const double pnts[][3]);\n\n\n\n\nCSoblqmL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \noblqm\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSoblqmsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSoblqmL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSkrovkX Xy coordinate check\n\n\nint CSoblqmX (Const struct cs_Oblqm_ *oblqm,int cnt,Const double pnts [ ] [ 3] ) ;\n\n\n\n\nAt the current time, \nCSoblqmX\n returns \ncs_CNVRT_OK\n without performing any checks. The arguments are currently ignored. Again, this is due to the unusual legacy of this projection, and the fact that normal coordinates used in the Czech Repulic increase to the west rather than the east.\n\n\nCSkrovkS Setup\n\n\nvoid CSkrovkS (struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSkrovkS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin longitude, origin latitude, oblique pole location, and other projection parameters are known, there are many calculations that need only be performed once. \nCSkrovkS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by the \ncsprm\n argument. Thus, this one argument provides \nCSkrovkS\n its input data and the repository for the results as described below.\n\n\nCSkrovkS\n examines the \nprj_code\n element of the \ncs_Csprm_\n structure to determine which of the two variations of this projection is to be setup. The projection code, therefore, simply determines if the 1995 adjustment transformation is applied to the resulting cartesian coordinates. The parameters for the affine tranformation are (currently) hard coded.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csldef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the Krovak Oblique Conformal Conic Projection are dependent upon the variation being implemented.\n\n\nThe following parameters apply to both variations of the projection:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\norg_lng\n\n\nLongitude, in degrees, of the origin of the projection. As is commonly used in the Czech Repoublic, this is usually the prime meridian of Ferro.\n\n\n\n\n\n\norg_lat\n\n\nLatitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the location of the pole of the oblique cone.\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the location of the pole of the oblique cone.\n\n\n\n\n\n\nprj_prm3\n\n\nLatitude, in degrees on the oblique gaussian surface, of the single standard parallel of the conic projection surface.\n\n\n\n\n\n\nscl_red\n\n\nThe scale reduction that is to be applied.\n\n\n\n\n\n\nScale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nQuad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nKrovak Oblique Conformal Conic, Czechoslovokia (cs_PRJCOD_)\n\n\nThis variation produces the traditional (i.e. unadjusted) Krovak coordinates used in Czechoslovakia since the 1920's. There are no special parameter requirements. Specifying this variation simply turns off the application of the 1995 adjustment.\n\n\nKrovak Oblique Conformal Conic/95 Adjustment\n\n\nThis variation causes an affine transformation to be applied to the traditional coordinates, thus producing coordinates appropriate for the 1995 adjustment. There are no special parameter requirements (at this time). Specifying this variation simply turns on the affine transformation, the coefficients of which are hard coded.\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the datum element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Krovk_ Structure\n\n\nThe results of the one-time calculations are recorded in the \noblqm\n* element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSkrovkF\n, \nCSkrovkI\n, \nCSkrovkK\n, and \nCSkrovkC\n functions require as their first argument.\n\n\nLambert Conformal Conic Projection (CSlmbrt)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Lambert Conformal Conic Projection. Since this projection is a conformal projection, the K and H scale factors are the same and there is no H function. Five variations of this projection are supported.\n\n\nCSlmbrtF Forward conversion\n\n\nint CSlmbrtF (Const struct cs_Lmbrt_ *lmbrt, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Lmbrt_\n structure via the \nlmbrt\n argument, \nCSlmbrtF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSlmbrtF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSlmbrtI Inverse conversion\n\n\nint CSlmbrtI (Const struct cs_Lmbrt_ *lmbrt, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Lmbrt_\n structure via the \nlmbrt\n argument, \nCSlmbrtI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSlmbrtI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSlmbrtK scale (K)\n\n\ndouble CSlmbrtK (Const struct cs_Lmbrt_ *lmbrt, Const double ll[2]);\n````\n\n`CSlmbrtK` returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the **ll** array.\n\n### CSlmbrtC convergence angle\n\n```c\ndouble CSlmbrtC (Const struct cs_Lmbrt_ *lmbrt, Const double ll[2]);\n\n\n\n\nCSlmbrtC\n returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSlmbrtQ definition quality check\n\n\nint CSlmbrtQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSlmbrtQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Lambert Conformal Conic Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSlmbrtQ\n only examines those components specific to the Lambert Conformal Conic Projection. \nCSlmbrtQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSlmbrtQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSlmbrtL Latitude/longitude check\n\n\nint CSlmbrtL (Const struct cs_Lmbrt_ *lmbrt, int cnt, Const double pnts[][3]);\n\n\n\n\nCSlmbrtL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nlmbrt\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSlmbrtsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSlmbrtL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSlmbrtX Xy coordinate check\n\n\nint CSlmbrtX (Const struct cs_Lmbrt_ *lmbrt, int cnt, Const double pnts[][3]);\n\n\n\n\nCSlmbrtX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nlmbrt\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSlmbrtsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSlmbrtL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSlmbrtS setup\n\n\nvoid CSlmbrtS (struct cs_Csprm_*csprm);\n\n\n\n\nThe \nCSlmbrtS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallels, the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once. \nCSlmbrtS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCSlmbrtS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate system definition\n\n\nThe definition of the coordinate system is extracted from the csdef element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time.\n\n\nFive variations of this projection are supported. \nCSlmbrtS\n determines which variation is to be setup by examining the \nprj_code\n element of the \ncs_Csprm_\n structure. The actual use of parameters in the \ncs_Csdef_\n structure (an element of the \ncs_Csprm_\n structure) is dependent on the variation being setup.\n\n\nThe following elements of the \ncs_Csdef_\n structure apply to all five variations:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nScale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nParameter use specific to the five variations is:\n\n\nTwo Standard Parallels (cs_PRJCOD_LMBRT)\n\n\nThis is the traditional version of this projection. The degree of scale reduction to reduce and distribute scale distortion is specified by two standard parallels:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLatitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\n\n\nSingle Standard Parallel (cs_PRJCOD_LM1SP)\n\n\nThis variation is commonly used outside of North America. It is, mathematically, virtually identical to what CS-MAP has long referred to as the Lambert Tangential. The degree of scale reduction to reduce and distribute scale distortion is specified by the scale reduction factor:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\nscl_red\n\n\nThe scale of the projection at the origin defined by org_lng and org_lat.\n\n\n\n\n\n\n\n\nBelgian Variation (cs_PRJCOD_LMBLGN)\n\n\nThis is a minor variation to the traditional Two Standard Parallel version of the projection. This variation will produce the results required by some Belgian coordinate systems:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLatitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\n\n\nWisconsin Variation (cs_PRJCOD_WCCSL)\n\n\nThis is a minor variation to the traditional Two Standard Parallel version of the projection. This variation supports the Wisconsin County Coordinate System group of coordinate systems. This variation uses a parallel ellipsoid technique to adjust horizontal coordinates for average elevation of the region being mapped:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLatitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.\n\n\n\n\n\n\nprj_prm3\n\n\nAverage geoid separation, \nin meters\n, of the region being mapped.\n\n\n\n\n\n\nprj_prm4\n\n\nAverage elevation above the geoid (i.e. orthometric height), \nin system units\n, of the region being mapped.\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\n\n\nMinnesota Variation (cs_PRJCOD_MNDOTL)\n\n\nThis is a minor variation to the traditional Two Standard Parallel version of the projection. This variation supports the county coordinate systems developed by the Minnesota Department of Transportation. This variation uses a parallel ellipsoid technique (different from that used in Wisconsin, of course) to adjust horizontal coordinates for average elevation of the region being mapped:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLatitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as \nprj_prm1\n, to obtain a conic with a single point of tangency.\n\n\n\n\n\n\nprj_prm3\n\n\nAverage height above the ellipsoid, **in system units\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the \ndatum\n element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Lmbrt_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nlmbrt\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSlmbrtF\n, \nCSlmbrtI\n, \nCSlmbrtK\n, and \nCSlmbrtC\n functions require as their first argument.\n\n\nLambert Tangential Projection (CSlmtan)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Lambert Tangential Projection as used by the National Geographic Institute of France. Please note that the current implementation of this projection does not support the spherical form of the projection. With the addition of the single standard parallel variation of the Lambert Conformal Conic, these functions are now redundant; and will be removed in a future release.\n\n\nCSlmtanF Forward conversion\n\n\nint CSlmtanF (Const struct cs_Lmtan_ *lmtan, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Lmtan_\n structure via the \nlmtan\n argument, \nCSlmtanF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSlmtanF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSlmtanI Inverse conversion\n\n\nint CSlmtanI (Const struct cs_Lmtan_ *lmtan, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Lmtan_\n structure via the \nlmtan\n argument, \nCSlmtanI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSlmtanI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSlmtanK parallel scale (K)\n\n\ndouble CSlmtanK (Const struct cs_Lmtan_ *lmtan, Const double ll[2]);\n\n\n\n\nCSlmtanK\n returns the grid scale factor, along a parallel, of the coordinate system at the geodetic location given by the \nll\n argument. Formulas for this calculation have not been located, therefore the result is obtained using the \nCS_llazdd\n function.\n\n\nCSlmtanH meridian scale (H)\n\n\ndouble CSlmtanH (Const struct cs_Lmtan_ *lmtan, Const double ll[2]);\n\n\n\n\nCSlmtanH\n returns the grid scale factor, along a meridian, of the coordinate system at the geodetic location given by the \nll\n argument. Formulas for this calculation have not been located, therefore the result is obtained from the use of the \nCS_llazdd\n function.\n\n\nCSlmtanC Convergence angle\n\n\ndouble CSlmtanC (Const struct cs_Lmtan_ *lmtan, Const double ll[2]);\n\n\n\n\nCSlmtanC\n returns the convergence angle in degrees east of north of the coordinate system at the geodetic location given by the \nll\n argument. Formulas for this calculation have not been located, therefore the result is obtained using the \nCS_llazdd\n function.\n\n\nCSlmtanL Latitude/longitude check\n\n\nint CSlmtanL (Const struct cs_Lmtan_ *lmtan, int cnt, Const double pnts [][3]);\n\n\n\n\nCSlmtanL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nlmtan\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSlmtansL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSlmtanL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSlmtanQ definition quality check\n\n\nint CSlmtanQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSlmtanQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Lambert Tangential Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSlmtanQ\n only examines those components specific to the Lambert Tangential Projection. \nCSlmtanQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSlmtanQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSlmtanX Xy coordinate check\n\n\nint CSlmtanX (Const struct cs_Lmtan_ *lmtan, int cnt, Const double pnts [][3]);\n\n\n\n\nCSlmtanX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnt\ns and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nlmtan\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSlmtansX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSlmtanL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSlmtanS setup\n\n\nvoid CSlmtanS (struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSlmtanS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude, the scale reduction factor, and other projection parameters are known, there are many calculations that need only be performed once. \nCSlmtanS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCSlmtanS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the Lambert Tangential projection are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\norg_lng\n\n\nThe longitude, in degrees, of the origin of the projection relative to Greenwich.\n\n\n\n\n\n\norg_lat\n\n\nThe latitude, in degrees, of the origin of the projection relative to the equator.\n\n\n\n\n\n\nscl_red\n\n\nThe scale reduction factor that is to be applied to the projection.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This value is the X coordinate of the coordinate system origin.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates. This value is the Y coordinate of the coordinate system origin.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the datum element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Lmtan_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nlmtan\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSlmtanF\n, \nCSlmtanI\n, \nCSlmtanK\n, \nCSlmtanH\n, and \nCSlmtanC\n functions require as their first argument.\n\n\nMercator Projection (CSmrcat)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Mercator Projection. Since this projection is conformal, the K and H grid scales are the same and there is no H function.\n\n\nCSmrcatF Forward conversion\n\n\nint CSmrcatF (Const struct cs_Mrcat_ *mrcat, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Mrcat_\n structure via the \nmrcat\n argument, \nCSmrcatF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSmrcatF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSmrcatI Inverse conversion\n\n\nint CSmrcatI (Const struct cs_Mrcat_ *mrcat, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Mrcat_\n structure via the mrcat argument, \nCSmrcatI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSmrcatI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the xy value is not within the domain of the coordinate system.\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSmrcatK scale (K) along a parallel\n\n\ndouble CSmrcatK (Const struct cs_Mrcat_ *mrcat, Const double ll[2]);\n\n\n\n\nCSmrcatK\n returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSmrcatC Convergence angle\n\n\ndouble CSmrcatC (Const struct cs_Mrcat_ *mrcat, Const double ll[2]);\n\n\n\n\nCSmrcatC\n returns the value 0.0 which represents the convergence in degrees east of north of nay coordinate system based on this projection at any latitude and longitude.\n\n\nCSmrcatQ definition Quality check\n\n\nint CSmrcatQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSmrcatQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Mercator Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSmrcatQ\n only examines those components specific to the Mercator Projection. \nCSmrcatQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSmrcatQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSmrcatL Latitude/longitude check\n\n\nint CSmrcatL (Const struct cs_Mrcat_ *mrcat, int cnt, Const double pnts[][3]);\n\n\n\n\nCSmrcatL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nmrcat\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSmrcatsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSmrcatL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSmrcatX Xy coordinate check\n\n\nint CSmrcatX (Const struct cs_Mrcat_ *mrcat, int cnt, Const double pnts[][3]);\n\n\n\n\nCSmrcatX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nmrcat\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSmrcatsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSmrcatL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSmrcatS setup\n\n\nvoid CSmrcatS (struct cs_Csprm_*csprm);\n\n\n\n\nThe \nCSmrcatS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallel, the origin longitude, and other projection parameters are known, there are many calculations that need only be performed once. \nCSmrcatS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCSmrcatS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure which must be initialized for the Mercator Projection are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the central meridian of the coordinate system (or map).\n\n\n\n\n\n\nprj_prm2\n\n\nLatitude, in degrees, of the standard parallel, usually zero indicating the equator. Using a non-zero value has an affect similar to that of the scale reduction factor of other cylindrical projections.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the datum element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Mrcat_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nmrcat\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSmrcatF\n, \nCSmrcatI\n, \nCSmrcatK\n, and \nCSmrcatC\n functions require as their first argument.\n\n\nMiller Projection (CSmillr)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Miller Projection. This projection is only used in the spherical form. Thus, all functions assume a sphere with a radius equal to the equatorial radius of the ellipsoid provided.\n\n\nCSmillrF Forward conversion\n\n\nint CSmillrF (Const struct cs_Millr_ *millr, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Millr_\n structure via the \nmillr\n argument, \nCSmillrF\n will convert the latitude and longitude provided in the \nll\n array to X and Y coordinates, returning the result in the \nxy\n array. \nCSmillrF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSmillrI Inverse conversion\n\n\nint CSmillrI (Const struct cs_Millr_ *millr, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Millr_\n structure via the \nmillr\n argument, \nCSmillrI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSmillrI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the \nxy\n value is not within the domain of the coordinate system.\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSmillrK scale (K) along a parallel\n\n\ndouble CSmillrK (Const struct cs_Millr_ *millr, Const double ll[2]);\n\n\n\n\nCSmillrK\n returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSmillrH scale (H) along a meridian\n\n\ndouble CSmillrH (Const struct cs_Millr_ *millr, Const double ll[2]);\n\n\n\n\nCSmillrH\n returns the grid scale factor, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array.\n\n\nCSmillrC Convergence angle\n\n\ndouble CSmillrC (Const struct cs_Millr_ *millr, Const double ll[2]);\n\n\n\n\nCSmillrC\n returns the value 0.0 which represents the convergence angle in degrees east of north of any coordinate system based on this projection at any latitude and longitude.\n\n\nCSmillrL Latitude/longitude check\n\n\nint CSmillrL (Const struct cs_Millr_ *millr, int cnt, Const double pnts[][3]);\n\n\n\n\nCSmillrL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nmillr\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSmillrsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSmillrL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSmillrQ definition Quality check\n\n\nint CSmillrQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);\n\n\n\n\nCSmillrQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Miller Cylindrical Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSmillrQ\n only examines those components specific to the Miller Cylindrical Projection. \nCSmillrQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSmillrQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSmillrX Xy coordinate check\n\n\nint CSmillrX (Const struct cs_Millr_ *millr, int cnt, Const double pnts[][3]);\n\n\n\n\nCSmillrX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nmillr\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSmillrsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSmillrL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSmillrS setup\n\n\nvoid CSmillrS (struct cs_Csprm_*csprm);\n\n\n\n\nThe \nCSmillrS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin longitude and other projection parameters are known, there are many calculations that need only be performed once. \nCSmillrS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCSmillrS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the Miller Projection are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the central meridian of the coordinate system (or map).\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nquad\n\n\nan integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nDatum Definition\n\n\nThe value of equatorial radius is extracted from the datum element of the \ncs_Csprm_\n structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required element is:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe radius of the earth, as a sphere, in meters.\n\n\n\n\n\n\n\n\ncs_Millr_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nmillr\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSmillrF\n, \nCSmillrI\n, \nCSmillrK\n, \nCSmillrH\n, and \nCSmillrC\n functions require as their first argument.\n\n\nModified Polyconic Projection (CSmodpc)\n\n\nThis set of functions represent the Coordinate System Mapping Package's knowledge of the Modified Polyconic Projection. That is, the projection developed by Lallemand of France and adopted by the International Map Committee (IMC) in London as the basis for the 1:1,000,000 scale International Map of the World (IMW) series in 1909.\n\n\nCSmodpcF Forward conversion\n\n\nint CSmodpcF (Const struct cs_Modpc_ *modpc, double xy[2], Const double ll[2]);\n\n\n\n\nGiven a properly initialized \ncs_Modpc_\n structure via the \nmodpc\n argument, \nCSmodpcF\n will convert the latitude and longitude provided in the a array to X and Y coordinates, returning the result in the \nxy\n array. \nCSmodpcF\n normally returns \ncs_CNVRT_NRML\n. If \nll\n is not within the domain of the coordinate system, \nxy\n is set to a \"rational\" result and \ncs_CNVRT_RNG\n is returned.\n\n\nCSmodpcI Inverse conversion\n\n\nint CSmodpcI (Const struct cs_Modpc_ *modpc, double ll[2], Const double xy[2]);\n\n\n\n\nGiven a properly initialized \ncs_Modpc_\n structure via the \nmodpc\n argument, \nCSmodpcI\n will convert the X and Y coordinates given in the \nxy\n array to latitude and longitude and return the result in the \nll\n array. \nCSmodpcI\n normally returns \ncs_CNVRT_NRML\n. It will return \ncs_CNVRT_RNG\n if the xy value is not within the domain of the coordinate system, or \ncs_CNVRT_INDF\n if the result is indefinite (e.g. longitude is not defined at the poles).\n\n\nIn both cases above, the \nxy\n and \nll\n arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.\n\n\nCSmodpcK grid scale (K), along parallel\n\n\ndouble CSmodpcK ( Const struct cs_Modpc_ *modpc, Const double ll[2]);\n\n\n\n\nCSmodpcK\n returns the grid scale factor, as measured along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. (The use of the \nll\n array is the same as described above.) At the current time, formulas that analytically produce the grid scale factor for this projection elude us. Thus, the grid scale factor is determined using the \nCS_llazdd\n function.\n\n\nCSmodpcH grid scale (H), along meridian\n\n\ndouble CSmodpcH ( Const struct cs_Modpc_ *modpc, Const double ll[2]);\n\n\n\n\nCSmodpcH\n returns the grid scale factor, as measured along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. At the current time, formulas that analytically produce the grid scale factor for this projection elude us. Thus, the grid scale factor is determined using the \nCS_llazdd\n function.\n\n\nCSmodpcC Convergence angle\n\n\ndouble CSmodpcC (Const struct cs_Modpc_ *modpc, Const double ll[2]);\n\n\n\n\nCSmodpcC\n returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the \nll\n array. At the current time, formulas that analytically produce the convergence angle for this projection elude us. Thus, the grid scale factor is determined using the \nCS_llazdd\n function.\n\n\nCSmodpcB Basic calculations\n\n\ndouble CSmodpcB (Const struct cs_Modpc_ *modpc, Const double ll[2], double xy[2], double *their_yc);\n\n\n\n\nInverse calculations for this projection are performed using an iterative algorithm calling the forward function. \nCSmodpcB\n converts geographic coordinates to cartesian coordinates in a form that can be used by both \nCSmodpcF\n and \nCSmodpcI\n; thus eliminating duplicate code in these modules. The \ntheir_yc\n argument provides for the return to the calling function of an additional intermediary result that is required for the inverse calculation.\n\n\nCSmodpcQ definition Quality check\n\n\nint CSmodpcQ ( Const struct cs_Csdef_ *csdef , unsigned short prj_code, int *err_list [], int list_sz);\n\n\n\n\nCSmodpcQ\n determines if the coordinate system definition provided by the \ncsdef\n argument is consistent with the requirements of the Modified Polyconic Projection. \nCS_cschk\n examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, \nCSmodpcQ\n only examines those components specific to the Modified Polyconic Projection. \nCSmodpcQ\n returns in \nerr_list\n an integer code value for each error condition detected, being careful not to exceed the size of \nerr_list\n as indicated by the \nlist_sz\n argument. The number of errors detected, regardless of the size of \nerr_list\n, is always returned. Refer to \nCSerpt\n for a description of the various error codes and their meaning. \nCSmodpcQ\n may be called with the \nNULL\n pointer and/or a zero for the \nerr_list\n and \nlist_sz\n arguments respectively.\n\n\nCSmodpcL Latitude/longitude check\n\n\nint CSmodpcL ( Const struct cs_Modpc_ *modpc, int cnt, Const double pnts[][3]);\n\n\n\n\nCSmodpcL\n determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nmodpc\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a great circle (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSmodpcsL\n's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. \nCSmodpcL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.\n\n\nCSmodpcX Xy coordinate check\n\n\nint CSmodpcX (Const struct cs_Modpc_ *modpc, int cnt, Const double pnts[][3]);\n\n\n\n\nCSmodpcX\n determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the \npnts\n and \ncnt\n arguments are within the mathematical domain of the coordinate system provided by the \nmodpc\n argument. The \npnts\n and \ncnt\n arguments can define a single coordinate (\ncnt\n == 1), a line (\ncnt\n == 2), or a closed region (\ncnt\n \n 3). \nCSmodpcsX\n's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. \nCSmodpcL\n returns \ncs_CNVRT_OK\n if all subject coordinates are within the mathematical domain of the coordinate system. \ncs_CNVRT_DOMN\n is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.\n\n\nCSmodpcS Setup\n\n\nvoid CSmodpcS (struct cs_Csprm_ *csprm);\n\n\n\n\nThe \nCSmodpcS\n function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard meridians, the standard parallels, and other projection parameters are known, there are many calculations that need only be performed once. \nCSmodpcS\n performs these calculations and saves the results in the \ncs_Csprm_\n structure provided by its argument, \ncsprm\n. Thus, the single argument provided to \nCSmodpcS\n serves as the source for input and the repository for the results as described below.\n\n\nCoordinate System Definition\n\n\nThe definition of the coordinate system is extracted from the \ncsdef\n element of the \ncs_Csprm_\n structure. Usually, this is obtained from the Coordinate System Dictionary by the \nCS_csdef\n function; but can be provided by the application at run time. The specific elements of the \ncs_Csdef_\n structure that must be initialized for the Modified Polyconic projection are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprj_prm1\n\n\nLongitude, in degrees, of the central meridian.\n\n\n\n\n\n\nprj_prm2\n\n\nLongitude, in degrees, of the Eastern meridian. The Western meridian is assumed to be west of the Central Meridian by the same amount that the Eastern Meridian is east of the Central Meridian. The Eastern meridian must be east of the central meridian, and not more than 15 degrees of longitude from the central meridian.\n\n\n\n\n\n\nprj_prm3\n\n\nLatitude, in degrees, of the Northern Standard Parallel.\n\n\n\n\n\n\nprj_prm4\n\n\nLatitude, in degrees, of the Southern Standard Parallel.\n\n\n\n\n\n\nscale\n\n\nThe scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.\n\n\n\n\n\n\nx_off\n\n\nThe false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.\n\n\n\n\n\n\ny_off\n\n\nThe false northing to be applied to all Y coordinates.\n\n\n\n\n\n\nquad\n\n\nAn integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.\n\n\n\n\n\n\n\n\nNeither standard parallel may be a pole, nor can the two standard parallels be the same as is supported in other projections. In addition, the Northern Standard Parallel must be the northernmost of the two standard parallels. Finally, the two standard parallels must be within 15 degrees of each other. Note that the projection was designed for maps whose extents are 6 degrees of longitude and 4 degrees of latitude.\n\n\nDatum Definition\n\n\nThe values of equatorial radius and eccentricity are extracted from the datum element of the \ncs_Csprm_\n structure. These are normally obtained from the Ellipsoid Dictionary by the \nCS_dtloc\n function, but may be supplied by the application at run time. Specifically, the required elements are:\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ne_rad\n\n\nThe equatorial radius of the earth in meters.\n\n\n\n\n\n\neccent\n\n\nThis value represents the eccentricity of the ellipsoid.\n\n\n\n\n\n\nto84_via\n\n\nAn integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.\n\n\n\n\n\n\n\n\ncs_Modpc_ Structure\n\n\nThe results of the one-time calculations are recorded in the \nmodpc\n element of the \nprj_prms\n union of the \ncs_Csprm_\n structure. It is a pointer to this initialized structure that the \nCSmodpcF\n, \nCSmodpcI\n, \nCSmodpcK\n, \nCSmodpcH\n, \nCSmodpcC\n, and \nCSmodpcB\n functions require as their first argument.\n\n\nBUGS\n\n\nAs is true with all other projections in CS-MAP, values submitted for conversion are not checked for validity before conversion for performance reasons. In every other case, this does not appear to be a problem. However, experience has show that values which are more than 50% outside the area covered by the projection parameters can produce errors which get reported through matherr. Checking of input values does need to be added to the functions of this projection.", 
            "title": "Cartographic Projection Functions"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cartographic-projection-funtions", 
            "text": "", 
            "title": "Cartographic Projection Funtions"
        }, 
        {
            "location": "/userguide/cartographicprojections/#albers-equal-area-projection-csalber", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Alber Equal Area Conic Projection.", 
            "title": "Albers Equal Area Projection (CSalber)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csalberf-forward-conversion", 
            "text": "int CSalberF (Const struct cs_Alber_ *alber, double xy[2], Const double ll[ 2]);  Given a properly initialized  cs_Alber_  structure via the  alber  argument,  CSalberF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSalberF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSalberF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csalberi-inverse-conversion", 
            "text": "int CSalberI (Const struct cs_Alber_ *alber, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Alber_  structure via the  alber  argument,  CSalberI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSalberI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSalberI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csalberk-grid-scale-k-along-parallel", 
            "text": "double CSalberK (Const struct cs_Alber_ *alber, Const double ll[2]);  CSalberK  returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. (The use of the  ll  array is the same as described above.)", 
            "title": "CSalberK grid scale (K) along parallel"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csalberh-grid-scale-h-along-meridian", 
            "text": "double CSalberH(Const struct cs_Alber_ *alber, Const double ll[2]);  CSalberH  returns the grid scale factor, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSalberH grid scale (H) along meridian"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csalberc-convergence-angle", 
            "text": "double CSalberC(Const struct cs_Alber_ *alber, Const double ll[2]);  CSalberC  returns the convergence angle in degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSalberC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csalberq-definition-quality-check", 
            "text": "int CSalberQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSalberQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Alber Equal Area Projection.  CS_cschk  examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore,  CSalberQ  only examines those components specific to the Alber Equal Area Projection.  CSalberQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_lis t, is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSalberQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSalberQ definition Quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csalberl-latitudelongitude-check", 
            "text": "int CSalberL (Const struct cs_Alber_ *alber, int cnt, Const double pnts[][3]);  CSalberL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  alber  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSalbersL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSalberL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSalberL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csalberx-xy-coordinate-check", 
            "text": "int CSalberX (Const struct cs-Alber_ *alber, int cnt, Const double pnts[][3]);  CSalberX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  alber  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSalbersX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSalberL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSalberX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csalbers-setup", 
            "text": "void CSalberS(struct cs_Csprm_ *csprm);  The  CSalberS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallels, the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once.  CSalberS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CSalberS  serves as the source for input and the repository for the results as described below", 
            "title": "CSalberS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure that must be initialized for the Albers projection are:     Element  Description      prj_prm1  Latitude, in degrees, of the northern standard parallel. Unlike other conics, it is important to distinguish between the northern and southern standard parallels for the Albers.    prj_prm2  Latitude, in degrees, of the southern standard parallel. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.    org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.    Scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    Quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition", 
            "text": "The values of equatorial radius and eccentricity are extracted from the  datum  element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_alber_-structure", 
            "text": "The results of the one-time calculations are recorded in the  alber  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSalberF ,  CSalberI ,  CSalberK ,  CSalberH , and  CSalberC  functions require as their first argument.", 
            "title": "cs_Alber_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#american-polyconic-projection-csplycn", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the American Polyconic Projection.", 
            "title": "American Polyconic Projection (CSplycn)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csplycnf-forward-conversion", 
            "text": "int CSplycnF (Const struct cs_Plycn_ *plycn, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Plycn_  structure via the  plycn  argument,  CSplycnF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSplycnF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSplycnF forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csplycni-inverse-conversion", 
            "text": "int CSplycnI (Const struct cs_Plycn_ *plycn, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Plycn_  structure via the  plycn  argument,  CSplycnI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSplycnI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  ll  and  xy  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSplycnI inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csplycnk-grid-scale-k-along-parallel", 
            "text": "double CSplycnK (Const struct cs_Plycn_ *plycn, Const double ll[2]);  CSplycnK  returns the value 1.0 which represents the grid scale along a parallel of any coordinate system based on this projection at any location.", 
            "title": "CSplycnK grid scale (K) along parallel"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csplycnh-grid-scale-h-along-meridian", 
            "text": "double CSplycnH (Const struct cs_Plycn_ *plycn, Const double ll[2]);  CSplycnH  returns the grid scale factor, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSplycnH grid scale (H) along meridian"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csplycnc-convergence-angle", 
            "text": "double CSplycnC (Const struct cs_Plycn_ *plycn, Const double ll[2]);  CSplycnC  returns the convergence angle in degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. At the current time, definitive formulas for the convergence angle of this projection elude us. The convergence angle is computed using the  CS_llazdd  function.", 
            "title": "CSplycnC convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csplycnq-definition-quality-check", 
            "text": "int CSplycnQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSplycnQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the American Polyconic Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CSplycnQ  only examines those components specific to the American Polyconic Projection.  CSplycnQ  returns in err_list an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSplycnQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSplycnQ definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csplycnl-latitudelongitude-check", 
            "text": "int CSplycnL(Const struct cs_Plycn_ *plycn, int cnt, Const double pnts[][3]);  CSplycnL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  plycn  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSplycnsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSplycnL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSplycnL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csplycnx-xy-coordinate-check", 
            "text": "int CSplycnX (Const struct cs_Plycn_ *plycn, int cnt, Const double pnts[][3]);  CSplycnX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  plycn  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSplycnsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSplycnL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSplycnX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csplycns-setup", 
            "text": "void CSplycnS(struct cs_Csprm_ *csprm);  The  CSplycnS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian, the origin latitude, and other projection parameters are known, there are many calculations that need only be performed once.  CSplycnS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CSplycnS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSplycnS setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_1", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure that must be initialized for the American Polyconic projection are:     Element  Description      prj_prm1  Longitude, in degrees, of the central meridian.    org_lat  The latitude, in degrees, of the origin of the projection.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum", 
            "text": "The values of equatorial radius and eccentricity are extracted from the datum element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_plycn_-structure", 
            "text": "The results of the one-time calculations are recorded in the  plycn  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSplycnF ,  CSplycnI ,  CSplycnK ,  CSplycnH , and  CSplycnC  functions require as their first argument.", 
            "title": "cs_Plycn_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#azimuthal-equal-area-projection-csazmea", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Lambert Azimuthal Equal Area Projection", 
            "title": "Azimuthal Equal Area Projection (CSazmea)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmeaf-forward-conversion", 
            "text": "int CSazmeaF (Const struct cs_Azmea_ *azmea, double xy[2], Const double ll[2])  Given a properly initialized  cs_Azmea_  structure via the  azmea  argument,  CSazmeaF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSazmeaF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CsazmeaF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmeai-inverse-conversion", 
            "text": "int CSazmeaI (Const struct cs_Azmea_ *azmea, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Azmea_  structure via the  azmea  argument,  CSazmeaI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSazmeaI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSazmeaI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmeak-grid-scale-k-normal", 
            "text": "double CSazmeaK (Const struct cs_Azmea_ * azmea, Const double ll[ 2]);  CSazmeaK  returns the grid scale factor normal to the radial at the geodetic location specified by the  ll  argument. In the case of the ellipsoidal form of this projection, analytical formulas for this value have not been located and the result is arrived at using the  CS_llazdd  function.", 
            "title": "CsazmeaK grid scale (K) normal"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmeah-grid-scale-h-radial", 
            "text": "double CSazmeaH (Const struct cs_Azmea_ * azmea, Const double ll[ 2]);  CSazmeaH  returns the grid scale factor along a radial line from the coordinate system origin to the point provided. Since this projection is authalic (i.e. equal area), the value returned is the reciprocal of that returned by  CSazmeaK .", 
            "title": "CSazmeaH grid scale (H) radial"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmeac-convergence-angle", 
            "text": "double CSazmeaC (Const struct cs_Azmea_ * azmea, Const double ll[ 2]);  CSazmeaC  returns the convergence angle in degrees east of north of the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at using the  CS_llazdd  function.", 
            "title": "CSazmeaC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmeaq-definition-quality-check", 
            "text": "int CSazmeaQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSazmeaQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Azimuthal Equal Area Projection.  CS_cschk  examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore,  CSazmeaQ  only examines those components specific to the Azimuthal Equal Area Projection.  CSazmeaQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSazmeaQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSazmeaQ definition Quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmeal-latitudelongitude-check", 
            "text": "int CSazmeaL (Const struct cs_Azmea_ *azmea, int cnt, Const double pnts[][3]);  CSazmeaL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  azmea  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSazmeasL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSazmeaL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSazmeaL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmeax-xy-coordinate-check", 
            "text": "int CSazmeaX (Const struct cs_Azmea_ *azmea, int cnt, Const double pnts[][3]);  CSazmeaX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  azmea  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt == 2 ), or a closed region ( cnt    3).  CSazmeasX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSazmeaL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSazmeaX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmeas-setup", 
            "text": "void CSazmeaS(struct cs_Csprm_ *csprm);  The  CSazmeaS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once.  CSazmeaS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the argument provided to  CSazmeaS  serves as the source for input and the repository for the results as described below", 
            "title": "CSazmeaS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_2", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time.  The following parameters must be set:     Parameter  Description      prj_prm1  The azimuth, in degrees east of north, of the positive Y-axis of the coordinate system.    org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.    y_off  The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate system definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_1", 
            "text": "The values of equatorial radius and eccentricity are extracted from the  datum  element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_azmea_-structure", 
            "text": "The results of the one-time calculations are recorded in the  azmea  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSazmeaF ,  CSazmeaI ,  CSazmeaK ,  CSazmeaH , and  CSazmeaC  functions require as their first argument.", 
            "title": "cs_Azmea_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#azmuthal-equidistant-projection-csazmed", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Azimuthal Equidistant Projection.", 
            "title": "Azmuthal Equidistant Projection (Csazmed)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmedf-forward-conversion", 
            "text": "int CSazmedF (Const struct cs_Azmed_ *azmed, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Azmed_  structure via the  azmed  argument,  CSazmedF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSazmedF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSazmedF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmedi-inverse-conversion", 
            "text": "int CSazmedI (Const struct cs_Azmed_ *azmed, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Azmed_  structure via the  azmed  argument,  CSazmedI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSazmedI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSazmedI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmedk-grid-scale-k-normal", 
            "text": "double CSazmedK (Const struct cs_Azmed_ *azmed, Const doubl  ll[2]);  CSazmedK  returns the grid scale factor normal to the radial at the geodetic location specified by the  ll  argument. In the case of the ellipsoidal form of this projection, analytical formulas for this value have not been located and the result is arrived at using the  CS_llazdd  function.", 
            "title": "CSazmedK grid scale (K) normal"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmedh-grid-scale-h-radial", 
            "text": "double CSazmedH (Const struct cs_Azmed_ *azmed, Const double ll[2]);  CSazmedH  returns the value 1.0; the scale at any point in the direction of a line emanating from the origin and passing through the any point of any coordinate system based on this projection. (This is what makes this projection an Equidistant Projection.)", 
            "title": "CSazmedH grid scale (H) radial"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmedc-convergence-angle", 
            "text": "double CSazmedC (Const struct cs_Azmed_ *azmed, Const double ll[2]);  CSazmedC  returns the convergence angle in degrees east of north of the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at using the  CS_llazdd  function.", 
            "title": "CSazmedC convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmedq-definition-quality-check", 
            "text": "int CSazmedQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);  CSazmedQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Azimuthal Equidistant Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CSazmedQ  only examines those components specific to the Azimuthal Equidistant Projection.  CSazmedQ  returns in err_list an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSazmedQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSazmedQ definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmedl-latitudelongitude-check", 
            "text": "int CSazmedL (Const struct cs_Azmed_ *azmed, int cnt, Const double pnts[][3]);  CSazmedL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  azmed  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSazmedsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSazmedL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSazmedL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmedx-xy-coordinate-check", 
            "text": "int CSazmedX (Const struct cs_Azmed_ * azmed, int cnt, Const double pnts[][3]);  CSazmedX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  azmed  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSazmedsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSazmedL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSazmedX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csazmeds-setup", 
            "text": "void CSazmedS(struct cs_Csprm_ *csprm);  The  CSazmedS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once.  CSazmedS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the first argument provided to  CSazmedS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSazmedS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_3", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. There are two variations to this projection:   Lambert Azimuthal Equidistant ( cs_PRJCOD_AZMED )  Lambert Azimuthal Equidistant, Elevated Ellipsoid ( cs_PRJCOD_AZEDE )   The following parameters are common to both variations:     Parameter  Description      org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.    y_off  The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#lambert-azimuthal-equidistant-projection", 
            "text": "This is the traditional variation of the Lambert Azimuthal Equidistant projection. Note that it differs slightly from many other implementations in that it accepts a parameter value for the azimuth of the Y axis relative to true north. This provides support for local/company coordinate system. Even better local/company coordinate system support is provided by the Lambert Azimuthal Equidistant, Elevated Ellipsoid variation.  The parameter must be specified in degrees east of north. An azimuth west of north would be specified with a negative value.  The following parameters must be set:     Parameter  Description      prj_prm1  The azimuth, in degrees east of north, of the positive Y-axis of the coordinate system.     Lambert Azimuthal Equidistant, Elevated Ellipsoid (cs_PRJCOD_AZEDE)  This variation of the Lambert Azimuthal Equidistant projection accepts an average elevation parameter which is added to the equatiorial radii of the ellipsoid. This better enbales CS-MAP to emulate a local/company coordinate system.  The parameter must be specified in system units. That is, if the coordinate system unit is, say, FEET; the average elevation must also be specified in feet.  The following parameters must be set;     Parameter  Description      prj_prm1  The azimuth, in degrees east of north, of the positive Y-axis of the coordinate system.    prj_prm2  The average elevation in the region of the system, expressed in coordinate system units.", 
            "title": "Lambert Azimuthal Equidistant Projection"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_2", 
            "text": "The values of equatorial radius and eccentricity are extracted from the  datum  element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_azmed_-structure", 
            "text": "The results of the one-time calculations are recorded in the  azmed  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSazmedF ,  CSazmedI ,  CSazmedK ,  CSazmedH , and  CSazmedC  functions require as their first argument.", 
            "title": "cs_Azmed_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#bonne-projection-projection-csbonne", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Bonne Projection. Setting the standard parallel equal to the equator produces a Sinusoidal Projection. Setting the standard parallel to either pole produces the Werner Projection.", 
            "title": "Bonne Projection Projection (CSbonne)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbonnef-forward-conversion", 
            "text": "int CSbonneF (Const struct cs_Bonne_ *bonne, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Bonne_  structure via the  bonne  argument,  CSbonneF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSbonneF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSbonneF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbonnei-inverse-conversion", 
            "text": "int CSbonneI (Const struct cs_Bonne_ *bonne, double ll[2],Const double xy[2]);  Given a properly initialized  cs_Bonne_  structure via the  bonne  argument,  CSbonneI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSbonneI  normally returns  cs_CNVRT_NRM L. It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSbonneI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbonnek-parallel-scale-k", 
            "text": "double CSbonneK (Const struct cs_Bonne_ *bonne, Const double ll[2]);  CSbonneK  returns the value 1.0 which is the grid scale factor, along any parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSbonneK parallel scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbonneh-meridian-scale-h", 
            "text": "double CSbonneH (Const struct cs_Bonne_ *bonne, Const double ll[2]);  CSbonneK  returns the grid scale, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. Analytical formulas for this value have not been located and the result is arrived at using the  CS_llazdd  function.", 
            "title": "CSbonneH meridian scale (H)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbonnec-convergence-angle", 
            "text": "double CSbonneC (Const struct cs_Bonne_ *bonne, Const double ll[2]);  CSbonneC  returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. Analytical formulas for this value have not been located and the result is arrived at using the  CS_llazdd  function.", 
            "title": "CSbonneC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbonneq-definition-quality-check", 
            "text": "int CSbonneQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSbonneQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Boone Projection.  CS_cschk  examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore,  CSbonneQ  only examines those components specific to the Bonne Projection.  CSbonneQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSbonneQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSbonneQ definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbonnel-latitudelongitude-check", 
            "text": "int CSbonneL (Const struct cs_Bonne_ *bonne, int cnt, Const double pnts[][3]);  CSbonneL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  bonne  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSbonnesL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSbonneL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSbonneL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbonnex-xy-coordinate-check", 
            "text": "int CSbonneX (Const struct cs_Bonne_ *bonne, int cnt, Const double pnts[][3]);  CSbonneX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  bonne  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSbonnesX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSbonneL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSbonneX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbonnes-setup", 
            "text": "void CSbonneS (struct cs_Csprm_ *csprm);  The  CSbonneS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallel, the origin longitude, and other projection parameters are known, there are many calculations that need only be performed once.  CSbonneS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CSbonneS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSbonneS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_4", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure that must be initialized for the Bonne Projection are:     Element  Description      org_lng  The longitude, in degrees, of the central meridian of the projection.    org_lat  The latitude, in degrees, of the standard parallel of the projection.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    quad  an integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_3", 
            "text": "The values of equatorial radius and eccentricity are extracted from the  datum  element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_bonne_-structure", 
            "text": "The results of the one-time calculations are recorded in the  bonne  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSbonneF ,  CSbonneI ,  CSbonneK ,  CSbonneH , and  CSbonneC  functions require as their first argument.", 
            "title": "cs_Bonne_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#bipolar-oblique-conformal-conic-projection-csbpcnc", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Bipolar Oblique Conformal Conic Projection. This projection was developed, by O. M. Miller (of Miller Cylindrical fame), specifically for mapping both the North American and South American continents on the same conformal map. This projection is supported for the sphere only. The equatorial radius of the referenced ellipsoid is used as the radius of the sphere.", 
            "title": "Bipolar Oblique Conformal Conic Projection (CSbpcnc)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbpcncf-forward-conversion", 
            "text": "int CSbpcncF (Const struct cs_Bpcnc_ *bpcnc, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Bpcnc_  structure via the  bpcnc  argument,  CSbpcncF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSbpcncF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSbpcncF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbpcnci-inverse-conversion", 
            "text": "int CSbpcncI (Const struct cs_Bpcnc_ *bpcnc, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Bpcnc_  structure via the  bpcnc  argument,  CSbpcncI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSbpcncI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSbpcncI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbpcnck-parallel-scale-k", 
            "text": "double CSbpcncK ( Const struct cs_Bpcnc_ *bpcnc, Const double ll[2]);  CSbpcncK  returns the grid scale factor, as measured along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. Since this is a conformal projection, there is no H function as the scale along a meridian equals the scale along a parallel.", 
            "title": "CSbpcncK parallel scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbpcncc-convergence-angle", 
            "text": "double CSbpcncC ( Const struct cs_Bpcnc_ *bpcnc, Const double ll[2]);  CSbpcncC  returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. At the current time, formulas that analytically define the convergence angle for this projection elude us. Thus, the convergence angle is determined empirically through the use of the  CS_llazdd  function.", 
            "title": "CSbpcncC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbpcncq-definition-quality-check", 
            "text": "int CSbpcncQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSbpcncQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Bi-Polar Conformal Conic Projection.  CS_cschk  examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore,  CSbpcncQ  only examines those components specific to the Bi-Polar Conformal Conic Projection.  CSbpcncQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSbpcncQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSbpcncQ definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbpcncl-latitudelongitude-check", 
            "text": "int CSbpcncL (Const struct cs_Bpcnc_ *bpcnc, int cnt, Const double pnts[][3]);  CSbpcncL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  bpcnc  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSbpcncsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSbpcncL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSbpcncL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbpcncx-xy-coordinate-check", 
            "text": "int CSbpcncX ( Const struct cs_Bpcnc_ *bpcnc, int cnt , Const double pnts[][3]);  CSbpcncX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  bpcnc  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSbpcncsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSbpcncL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSbpcncX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csbpcncs-setup", 
            "text": "void CSbpcncS(struct cs_Csprm_ *csprm);  The  CSbpcncS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the poles, the standard parallels, and other projection parameters are known, there are many calculations that need only be performed once.  CSbpcncS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CSbpcncS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSbpcncS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_5", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. As far as we know, this projection is usually used only for the specific coordinate system for which it was invented. However, to remain consistent with the rest of CS-MAP, the following parameters can be specified. These parameters specify the location of the two poles upon which the projection is based. The first is always specified by latitude and longitude. The latitude of the second pole must always be specified. However, the longitude of the second pole can be specified either directly ( prj_prm3 ) or as an angular distance from the first pole ( prj_prm5 ). If  prj_prm5  is greater than zero, the second method is used. In the listing of parameters given below, the values used for the specific map for which this projection was developed are given. The specific elements of the  cs_Csdef_  structure that must be initialized for the Bipolar Oblique Conformal Projection are:     Element  Description      prj_prm1  Longitude, in degrees, of the first pole (usually the southwest). [- 110.0]    prj_prm2  Latitude, in degrees, of the first pole. [-20.0]    prj_prm3  Longitude, in degrees, of the second pole (usually the northeast). [-19.99333333333]    prj_prm4  Latitude, in degrees, of the second pole. [+45.0]    prj_prm5  If greater than zero, this value is considered to be the angular distance, in degrees, from the first pole to the second pole and the longitude of the second pole is computed as such. If this value is less than or equal to zero, the value provided in prj_prm3 is considered the longitude of the second pole. [+104.0]    prj_prm6  Angular distance, in degrees, from either pole to the first of two standard parallels. [+31.0]    prj_prm7  Angular distance, in degrees, from either pole to the second of two standard parallels. [+73.0]    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied. [1.0]    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. [0.0]    y_off  The false northing to be applied to all Y coordinates. [0.0]    quad  an integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_4", 
            "text": "The value of equatorial radius is extracted from the datum element of the  cs_Csprm_  structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required element is:     Element  Description      e_rad  The radius of the earth, as a sphere, in meters", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_bpcnc_-structure", 
            "text": "The results of the one-time calculations are recorded in the  bpcnc  element of the  prj_prm s union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSbpcncF ,  CSbpcncI ,  CSbpcncK ,  CSbpcncH ,  CSbpcncC , and  CSbpcncB  functions require as their first argument.", 
            "title": "cs_Bpcnc_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cassini-projection-cscsini", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Cassini Projection", 
            "title": "Cassini Projection (CScsini)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cscsinif-forward", 
            "text": "int CScsiniF (Const struct cs_Csini_ *csini, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Csini_  structure via the  csini  argument,  CScsiniI  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CScsiniF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CScsiniF Forward"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cscsinii-inverse", 
            "text": "int CScsiniI (Const struct cs_Csini_ *csini, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Csini_  structure via the  csini  argument,  CScsiniI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CScsiniI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).\nIn both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CScsiniI Inverse"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cscsinik-parallel-scale-k", 
            "text": "double CScsiniK (Const struct cs_Csini_ *csini, Const double ll[2]);  CScsiniK  returns the grid scale factor along a line normal to the central meridian of the coordinate system at the geographic location defined by the latitude and longitude provided in the  ll  array. It is a specific feature of this projection that this scale factor is unity.", 
            "title": "CScsiniK parallel scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cscsinih-meridian-scale-h", 
            "text": "double CScsiniH (Const struct cs_Csini_ *csini, Const double ll[2]);  CScsiniH  returns the grid scale factor along a line parallel to the central meridian of the coordinate system at the geographic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CScsiniH meridian scale (H)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cscsinic-convergence-angle", 
            "text": "double CScsiniC (Const struct cs_Csini_ *csini, Const double ll[2]);  CScsiniC  returns the convergence angle, in degrees east of north, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. As analytical formulas for this quantity have not yet been located, the result is arrived at empirically using  CS_aslldd .", 
            "title": "CScsiniC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cscsiniq-definition-quality-check", 
            "text": "int CScsiniQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CScsiniQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Cassini Projection.  CS_cschk  examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore,  CScsiniQ  only examines those components specific to the Cassini Projection.  CScsiniQ  returns in err_list an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CScsiniQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CScsiniQ definition Quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cscsinil-latitudelongitude-check", 
            "text": "int CScsiniL (Const struct cs_Csini_ *csini, int cnt, Const double pnts[][3]);  CScsiniL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  csini  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CScsinisL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CScsiniL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CScsiniL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cscsinix-xy-coordinate-check", 
            "text": "int CScsiniX (Const struct cs_Csini_ *csini, int cnt, Const double pnts[][3]);  CScsiniX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  csini  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CScsinisX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CScsiniL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CScsiniX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cscsinis-setup", 
            "text": "void CScsiniS (struct cs_Csprm_ *csprm);  The  CScsiniS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian, the origin latitude, and other projection parameters are known, there are many calculations that need only be performed once.  CScsiniS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CScsiniS  serves as the source for input and the repository for the results as described below.", 
            "title": "CScsiniS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_6", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure that must be initialized for the Cassini projection are:     Element  Description      prj_prm1  Longitude, in degrees, of the central meridian.    org_lat  The latitude, in degrees, of the origin of the projection.    Scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units, and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    Quad  an integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_5", 
            "text": "The values of equatorial radius and eccentricity are extracted from the datum element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_csini_-structure", 
            "text": "The results of the one-time calculations are recorded in the  csini  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CScsiniF ,  CScsiniI ,  CScsiniK ,  CScsiniH , and  CScsiniC  functions require as their first argument.", 
            "title": "cs_Csini_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#danish-system-34-cssys34", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Danish System 34 Projection. This projection is supported in ellipsoid form only; and most ordinary parameters are hard coded and selected via the 'region' ( prj_prm1 ) parameter.", 
            "title": "Danish System 34 (CSsys34)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cssys34c-convergence-angle", 
            "text": "double CSsys34C ( Const struct cs_Sys34_ *sys34, Const double ll[2]);  CSsys34C  returns the convergence angle in degrees east of north of the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the  CS_azlld  function.", 
            "title": "CSsys34C Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cssys34f-forward-conversion", 
            "text": "int CSsys34F (Const struct cs_Sys34_ *sys34, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Sys34_  structure via the  sys34  argument,  CSsys34F  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSsys34F  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSsys34F Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cssys34i-inverse-conversion", 
            "text": "int CSsys34I (Const struct cs_Sys34_ *sys34, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Sys34_  structure via the  sys34  argument,  CSsys34I  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSsys34I  normally returns  cs_CNVRT_NRM L. It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).\nIn both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSsys34I Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cssys34k-parallel-scale-k", 
            "text": "double CSsys34K (Const struct cs_Sys34_ *sys34, Const double ll[2]);  CSsys34K  returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of the  CS_llazdd  function.", 
            "title": "CSsys34K parallel scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cssys34h-meridian-scale-h", 
            "text": "double CSsys34H (Const struct cs_Sys34_ * ys34, Const double ll[2]);  CSsys34H  returns the grid scale factor along a meridian at the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of the  CS_llazdd  function.", 
            "title": "CSsys34H meridian scale (H)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cssys34l-latitudelongitude-check", 
            "text": "int CSsys34L (Const struct cs_Sys34_ *sys34, int cnt, Const double pnts[][3]);  CSsys34L  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  sys34  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSsys34sL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSsys34L  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSsys34L Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cssys34q-definition-quality-check", 
            "text": "int CSsys34Q (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);  CSsys34Q  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Danish System 34 Projection.  CS_cschk  examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore,  CSsys34Q  only examines those components specific to the Danish System 34 Projection.  CSsys34Q  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSsys34Q  may be called with the NULL pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSsys34Q definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cssys34x-xy-coordinate-check", 
            "text": "int CSsys34X (Const struct cs_Sys34_ *sys34, int cnt , Const double pnts[][3]);  CSsys34X  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  sys34  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSsys34sX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSsys34L  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSsys34X Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cssys34s-setup-general", 
            "text": "void CSsys34S (struct cs_Csprm_ *csprm);  The  CSsys34S  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the zone and other projection parameters are known, there are many calculations that need only be performed once.  CSsys34S  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the argument provided to  CSsys34S  serves as the source for input and the repository for the results as described below.", 
            "title": "CSsys34S Setup (general)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_7", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time.  The following parameters must be set:     Parameter  Description      prj_prm1  Indicates which of the three regions is to apply 1.0 ==  jylland; 2.0 ==  sj\u00e6lland, 3.0 ==  bornholm.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_6", 
            "text": "The values of equatorial radius and eccentricity are extracted from the datum element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_sys34_-structure", 
            "text": "The results of the one-time calculations are recorded in the  sys34  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSsys344F ,  CSsys344I ,  CSsys344K ,  CSsys344H , and  CSsys34C  functions require as their first argument.", 
            "title": "cs_Sys34_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#equidistant-conic-projection-csedcnc", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Equidistant Conic Projection, also known as the Simple Conic Projection.", 
            "title": "Equidistant Conic Projection (CSedcnc)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcncf-forward-conversion", 
            "text": "int CSedcncF (Const struct cs_Edcnc_ *edcnc, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Edcnc_  structure via the  edcnc  argument,  CSedcncF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSedcncF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSedcncF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcnci-inverse-conversion", 
            "text": "int CSedcncI (Const struct cs_Edcnc_ *edcnc, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Edcnc_  structure via the  edcnc  argument,  CSedcncI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSedcncI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).\nIn both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSedcncI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcnck-parallel-scale-k", 
            "text": "double CSedcncK (Const struct cs_Edcnc_ *edcnc, Const double ll[2]);  CSedcncK  returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSedcncK parallel scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcnch-meridian-scale-h", 
            "text": "double CSedcncH (Const struct cs_Edcnc_ *edcnc, Const double ll[2]);  CSedcncH  returns the value of 1.0 that represents the grid scale, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. That is, all distances measured along a meridian of this projection are true to scale, the essence of this projection.", 
            "title": "CSedcncH meridian scale (H)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcncc-convergence-angle", 
            "text": "double CSedcncC (Const struct cs_Edcnc_ *edcnc, Const double ll[2]);  CSedcncC  returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSedcncC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcncq-definition-quality-check", 
            "text": "int CSedcncQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSedcncQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Equidistant Conic Projection.  CS_cschk  examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore,  CSedcncQ  only examines those components specific to the Equidistant Conic Projection.  CSedcncQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSedcncQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSedcncQ definition Quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcncl-latitudelongitude-check", 
            "text": "int CSedcncL (Const struct cs_Edcnc_ *edcnc, int cnt, Const double pnts[][3]);  CSedcncL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  edcnc  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSedcncsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSedcncL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSedcncL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcncx-xy-coordinate-check", 
            "text": "int CSedcncX (Const struct cs_Edcnc_ *edcnc, int cnt, Const double pnts[][3]);  CSedcncX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  edcnc  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSedcncsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSedcncL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSedcncX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcncs-setup", 
            "text": "void CSedcncS (struct cs_Csprm_ *csprm);  The  CSedcncS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallels, the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once.  CSedcncS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CSedcncS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSedcncS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_8", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure that must be initialized for the Equidistant Conic projection are:     Element  Description      prj_prm1  Latitude, in degrees, of the first standard parallel, usually the northernmost (it makes no difference).    prj_prm2  Latitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency (i.e. a single standard parallel).    org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_7", 
            "text": "The values of equatorial radius and eccentricity are extracted from the datum element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_edcnc_-structure", 
            "text": "The results of the one-time calculations are recorded in the  edcnc  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSedcncF ,  CSedcncI ,  CSedcncK ,  CSedcncH , and  CSedcncC  functions require as their first argument.", 
            "title": "cs_Edcnc_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#equidistant-cylindrical-projection-csedcyl", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Equidistant Cylindrical Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere. This projection is also known as the Equirectangular or Rectangular projection. When the reference latitude of this projection is set to zero (i.e. the equator) the result is equivalent to what is known as the Plate Carre\u0301e or Simple Cylindrical projection. When the reference latitude is set to 45? (north or south), a Gall Isographic projection results.", 
            "title": "Equidistant Cylindrical Projection (CSedcyl)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcylf-forward-conversion", 
            "text": "int CSedcylF (Const struct cs_Edcyl_ *edcyl,double xy[2], Const double ll[2]);  Given a properly initialized  cs_Edcyl_  structure via the  edcyl  argument,  CSedcylF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSedcylF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSedcylF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcyli-inverse-conversion", 
            "text": "int CSedcylI (Const struct cs_Edcyl_ *edcyl, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Edcyl_  structure via the  edcyl  argument,  CSedcylI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSedcylI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system.  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSedcylI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcylk-parallel-scale-k", 
            "text": "double CSedcylK (Const struct cs_Edcyl_ *edcyl, Const double ll[2]);  CSedcylK  returns the grid scale factor along a parallel at the geodetic location specified by the  ll  argument.", 
            "title": "CSedcylK parallel scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcylh-meridional-scale-h", 
            "text": "double CSedcylH (Const struct cs_Edcyl_ *edcyl, Const double ll[2]);  CSedcylH  returns the grid scale factor along a meridian at the geodetic location specified by the  ll  argument.", 
            "title": "CSedcylH meridional scale (H)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcylc-convergence-angle", 
            "text": "double CSedcylC (Const struct cs_Edcyl_ *edcyl, Const double ll[2]);  CSedcylC  returns the convergence angle in degrees east of north of the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at using the  CS_azsphr  function.", 
            "title": "CSedcylC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcylq-definition-quality-check", 
            "text": "int CSedcylQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSedcylQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Equidistant Cylindrical Projection.  CS_cschk  examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore,  CSedcylQ  only examines those components specific to the Equidistant Cylindrical Projection.  CSedcylQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSedcylQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSedcylQ definition Quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcyll-latitudelongitude-check", 
            "text": "int CSedcylL (Const struct cs_Edcyl_ *edcyl, int cnt, Const double pnts[][3]);  CSedcylL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  edcyl  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSedcylsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSedcylL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSedcylL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcylx-xy-coordinate-check", 
            "text": "int CSedcylX (Const struct cs_Edcyl_ *edcyl, int cnt, Const double pnts[][3]);  CSedcylX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  edcyl  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSedcylsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSedcylL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSedcylX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csedcyls-setup", 
            "text": "void CSedcylS(struct cs_Csprm_ *csprm);  The  CSedcylS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the reference parallel, origin longitude, and other projection parameters are known, there are many calculations which need only be performed once.  CSedcylS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the argument provided to  CSedcylS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSedcylS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_9", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The following parameters are used:     Parameter  Description      prj_prm1  The latitude, in degrees, of the reference parallel.    org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.    y_off  The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_8", 
            "text": "The value of equatorial radius is extracted from the datum element of the  cs_Csprm_  structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required element is:     Element  Description      e_rad  The radius of the earth, as a sphere, in meters.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_edcyl_-structure", 
            "text": "The results of the one-time calculations are recorded in the  edcyl  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSedcylF ,  CSedcylI ,  CSedcylK ,  CsedcylH , and  CSedcylC  functions require as their first argument.", 
            "title": "cs_Edcyl_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#eckert-iv-projection-csekrt4", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Eckert IV Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.", 
            "title": "Eckert IV Projection (CSekrt4)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt4f-forward-conversion", 
            "text": "int CSekrt4F (Const struct cs_Ekrt4_ *ekrt4, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Ekrt4_  structure via the  ekrt4  argument,  CSekrt4F  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSekrt4F  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSekrt4F Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt4i-inverse-conversion", 
            "text": "int CSekrt4I (Const struct cs_Ekrt4_ *ekrt4, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Ekrt4_  structure via the  ekrt4  argument,  CSekrt4I  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSekrt4I  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSekrt4I Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt4k-parallel-scale-k", 
            "text": "double CSekrt4K (Const struct cs_Ekrt4_ *ekrt4, Const double ll[2]);  CSekrt4K  returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.", 
            "title": "CSekrt4K parallel scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt4h-meridian-scale-h", 
            "text": "double CSekrt4H (Const struct cs_Ekrt4_ *ekrt4, Const double ll[2]);  CSekrt4H  returns the grid scale factor along a meridian at the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.", 
            "title": "CSekrt4H meridian scale (H)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt4c-convergence-angle", 
            "text": "double CSekrt4C (Const struct cs_Ekrt4_ *ekrt4, Const double ll[2]);  CSekrt4C  returns the convergence angle in degrees east of north of the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the  CS_azsphr  function.", 
            "title": "CSekrt4C Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt4q-definition-quality-check", 
            "text": "int CSekrt4Q (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);  CSekrt4Q  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Eckert IV Projection.  CS_cschk  examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore,  CSekrt4Q  only examines those components specific to the Eckert IV Projection.  CSekrt4Q  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSekrt4Q  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSekrt4Q definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt4l-latitudelongitude-check", 
            "text": "int CSekrt4L (Const struct cs_Ekrt4_ *ekrt4, int cnt, Const double pnts[][3]);  CSekrt4L  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  ekrt4  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSekrt4sL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSekrt4L  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSekrt4L Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt4x-xy-coordinate-check", 
            "text": "int CSekrt4X ( Const struct cs_Ekrt4_ *ekrt4, int cnt, Const double pnts[][3]);  CSekrt4X  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  ekrt4  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSekrt4sX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSekrt4L  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSekrt4X Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt4s-setup-general", 
            "text": "void CSekrt4S( struct cs_Csprm_ *csprm);  The  CSekrt4S  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian and other projection parameters are known, there are many calculations that need only be performed once.  CSekrt4S  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the argument provided to  CSekrt4S  serves as the source for input and the repository for the results as described below.", 
            "title": "CSekrt4S Setup (general)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_10", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The following parameters are used:     Parameter  Description      org_lng  The longitude, in degrees, of the origin of the projection (central meridian).    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.    y_off  The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_9", 
            "text": "The value of equatorial radius is extracted from the datum element of the  cs_Csprm_  structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required element is:     Element  Description      e_rad  The radius of the earth, as a sphere, in meters.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_ekrt4-structure", 
            "text": "The results of the one-time calculations are recorded in the  ekrt4  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSekrt4F ,  CSekrt4I ,  CSekrt4K ,  CSekrt4H , and  CSekrt4C  functions require as their first argument.", 
            "title": "cs_Ekrt4 Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#eckert-vi-projection-csekrt6", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Eckert VI Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.", 
            "title": "Eckert VI Projection (CSekrt6)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt6f-forward-conversion", 
            "text": "int CSekrt6F ( Const struct cs_Ekrt6_ *ekrt6, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Ekrt6_  structure via the  ekrt6  argument,  CSekrt6F  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSekrt6F  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSekrt6F forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt6i-inverse-conversion", 
            "text": "int CSekrt6I ( Const struct cs_Ekrt6_ *ekrt6, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Ekrt6_  structure via the  ekrt6  argument,  CSekrt6I  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSekrt6I  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSekrt6I Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt6k-parallel-scale-k", 
            "text": "double CSekrt6K ( Const struct cs_Ekrt6_ *ekrt6, Const double ll[2]);  CSekrt6K  returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.", 
            "title": "CSekrt6K parallel scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt6h-meridian-scale-h", 
            "text": "double CSekrt6H ( Const struct cs_Ekrt6_ *ekrt6, Const double ll[2]);  CSekrt6H  returns the grid scale factor along a meridian at the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.", 
            "title": "CSekrt6H meridian scale (H)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt6c-convergence-angle", 
            "text": "double CSekrt6C ( Const struct cs_Ekrt6_ *ekrt6, Const double ll [2]);  CSekrt6C  returns the convergence angle in degrees east of north of the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the  CS_azsphr  function.", 
            "title": "CSekrt6C Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt6q-definition-quality-check", 
            "text": "int Csekrt6Q( Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);  CSekrt6Q  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Eckert VI Projection.  CS_cschk  examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore,  CSekrt6Q  only examines those components specific to the Eckert VI Projection.  CSekrt6Q  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSekrt6Q  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSekrt6Q definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt6l-latitudelongitude-check", 
            "text": "int Csekrt6L (Const struct cs_Ekrt6_ *ekrt4, int cnt, Const double pnts[][3]);  CSekrt6L  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  ekrt6  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSekrt6sL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSekrt6L  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSekrt6L Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt6x-xy-coordinate-check", 
            "text": "int Csekrt6X (Const struct cs_Ekrt6_ *ekrt4, int cnt, Const double pnts[][3]);  CSekrt6X  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  ekrt6  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSekrt6sX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSekrt6L  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSekrt6X Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csekrt6s-setup-general", 
            "text": "void CSekrt6S(struct cs_Csprm_ *csprm);  The  CSekrt6S  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian and other projection parameters are known, there are many calculations which need only be performed once.  CSekrt6S  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the argument provided to  CSekrt6S  serves as the source for input and the repository for the results as described below.", 
            "title": "CSekrt6S Setup (general)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_11", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The following parameters are used:     Parameter  Description      org_lng  The longitude, in degrees, of the origin of the projection (central meridian).    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.    y_off  The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_10", 
            "text": "The value of equatorial radius is extracted from the datum element of the  cs_Csprm_  structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required element is:     Element  Description      e_rad  The radius of the earth, as a sphere, in meters.", 
            "title": "Datum definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_ekrt6_-structure", 
            "text": "The results of the one-time calculations are recorded in the  ekrt6  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSekrt6F ,  CSekrt6I ,  CSekrt6K ,  CSekrt6H , and  CSekrt6C  functions require as their first argument.", 
            "title": "cs_Ekrt6_ structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#gnomonic-projection-csgnomc", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Gnomonic Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.  The Gnomonic projection cannot process locations that are 90 degrees or more away from the projection origin. Coordinates that exceed this limit are adjusted to fall on the great circle that defines this limit.", 
            "title": "Gnomonic Projection (CSgnomc)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csgnomcf-forward-conversion", 
            "text": "int CSgnomcF ( Const struct cs_Gnomc_ *gnomc, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Gnomc_  structure via the  gnomc  argument,  CSgnomcF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSgnomcF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CsgnomcF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csgnomci-inverse-conversion", 
            "text": "int CSgnomcI (Const struct cs_Gnomc_ *gnomc, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Gnomc_  structure via the  gnomc  argument,  CSgnomcI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSgnomcI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CsgnomcI inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csgnomck-grid-scale-k-normal-to-radial", 
            "text": "double CSgnomcK (Const struct cs_Gnomc_ *gnomc, Const double ll[2]);  CSgnomcK  returns the grid scale factor normal to the radial at the geodetic location specified by the  ll  argument.", 
            "title": "CsgnomcK grid scale (K) normal to radial"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csgnomch-grid-scale-h-along-radial", 
            "text": "double CSgnomcH (Const struct cs_Gnomc_ *gnomc, Const double ll[2]);  CSgnomcH  returns the grid scale factor along a radial from the coordinate system origin to (and at) the geodetic location specified by the  ll  argument.", 
            "title": "CsgnomcH grid scale (H) along radial"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csgnomcc-convergence-angle", 
            "text": "double CSgnomcC (Const struct cs_Gnomc_ * gnomc, Const double ll[2]);  CSgnomcC  returns the convergence angle in degrees east of north of the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the  CS_azsphr  function.", 
            "title": "CsgnomcC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csgnomcl-latitudelongitude-check", 
            "text": "int CSgnomcL (Const struct cs_Gnomc_ * gnomc, int cnt, Const double pnts[][3]);  CSgnomcL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  gnomc  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSgnomcsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSgnomcL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CsgnomcL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csgnomcq-definition-quality-check", 
            "text": "int CSgnomcQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSgnomcQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Gnomonic Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CSgnomcQ  only examines those components specific to the Gnomonic Projection.  CSgnomcQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSgnomcQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSgnomcQ definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csgnomcx-xy-coordinate-check", 
            "text": "int CSgnomcX (Const struct cs_Gnomc_ * gnomc, int cnt, Const double pnts[][3]);  CSgnomcX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the gnomc argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSgnomcsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSgnomcL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CsgnomcX Xy coordinate check`"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csgnomcs-setup", 
            "text": "void CSgnomcS(struct cs_Csprm_ *csprm);  The  CSgnomcS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude and other projection parameters are known, there are many calculations that need only be performed once.  CSgnomcS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the argument provided to  CSgnomcS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSgnomcS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_12", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The following parameters are used:     Parameter  Description      org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.    y_off  The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_11", 
            "text": "The value of equatorial radius is extracted from the datum element of the  cs_Csprm_  structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required element is:     Element  Description      e_rad  The radius of the earth, as a sphere, in meters.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_gnomc_-structure", 
            "text": "The results of the one-time calculations are recorded in the  gnomc  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSgnomcF ,  CSgnomcI ,  CSgnomcK ,  CSgnomcH , and  CSgnomcC  functions require as their first argument.", 
            "title": "cs_Gnomc_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#goode-homolosine-projection-cshmlsn", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Goode Homolosine Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.", 
            "title": "Goode Homolosine Projection (CShmlsn)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cshmlsnf-forward-conversion", 
            "text": "int CShmlsnF (Const struct cs_Hmlsn_ *hmlsn, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Hmlsn_  structure via the  hmlsn  argument,  CShmlsnF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CShmlsnF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CShmlsnF forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cshmlsni-inverse-conversion", 
            "text": "int CShmlsnI (Const struct cs_Hmlsn_ *hmlsn, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Hmlsn_  structure via the  hmlsn  argument,  CShmlsnI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CShmlsnI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CShmlsnI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cshmlsnk-parallel-scale-k", 
            "text": "double CShmlsnK (Const struct cs_Hmlsn_ *hmlsn, Const double ll[2]);  CShmlsnK  returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.", 
            "title": "CShmlsnK parallel scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cshmlsnh-meridian-scale-h", 
            "text": "double CShmlsnH (Const struct cs_Hmlsn_ *hmlsn, Const double ll[2]);  CShmlsnH  returns the grid scale factor along a meridian at the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.", 
            "title": "CShmlsnH meridian scale (H)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cshmlsnc-convergence-angle", 
            "text": "double CShmlsnC (Const struct cs_Hmlsn_ *hmlsn, Const double ll[2]);  CShmlsnC  returns the convergence angle in degrees east of north of the geodetic location specified by the  ll  argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the  CS_azsphr  function.", 
            "title": "CShmlsnC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cshmlsnq-definition-quality-check", 
            "text": "int CShmlsnQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);  CShmlsnQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Goode Homolosine Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CShmlsnQ  only examines those components specific to the Goode Homolosine Projection.  CShmlsnQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_lis t, is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CShmlsnQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CShmlsnQ definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cshmlsnl-latitudelongitude-check", 
            "text": "int CShmlsnL (Const struct cs_Hmlsn_ *hmlsn, int cnt, Const double pnts[][3]);  CShmlsnL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  hmlsn  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CShmlsnsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CShmlsnL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CShmlsnL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cshmlsnx-xy-coordinate-check", 
            "text": "int CShmlsnX (Const struct cs_Hmlsn_ *hmlsn, int cnt, Const double pnts[][3]);  CShmlsnX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  hmlsn  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CShmlsnsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CShmlsnL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CShmlsnX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cshmlsns-setup-general", 
            "text": "void CShmlsnS (struct cs_Csprm_ *csprm);  The  CShmlsnS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin longitude and other projection parameters are known, there are many calculations which need only be performed once.  CShmlsnS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the argument provided to  CShmlsnS  serves as the source for input and the repository for the results as described below.", 
            "title": "CShmlsnS Setup (general)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_13", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The following parameters are used:     Parameter  Description      org_lng  The longitude, in degrees, of the origin of the projection (central meridian).    prj_prm1-24  The interrupted form of the Goode Homolosine Projection is fully supported. cs_Csdef _ elements prj_prm1 thru prj_prm24 can be used to specify the extents of the different zones. See  CS_zones  for information on how to encode zones.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.    y_off  The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_12", 
            "text": "The value of equatorial radius is extracted from the datum element of the  cs_Csprm_  structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required element is:     Element  Description      e_rad  The radius of the earth, as a sphere, in meters.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_hmlsn_-structure", 
            "text": "The results of the one-time calculations are recorded in the  hmlsn  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CShmlsnF ,  CShmlsnI ,  CShmlsnK ,  CShmlsnH , and  CShmlsnC  functions require as their first argument.", 
            "title": "cs_Hmlsn_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#hotine-oblique-mercator-projection-csoblqm", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Hotine Oblique Mercator Projection. Since this projection is conformal, the K and H scale factors are the same and there is no H function. Six variations of this projection are supported.", 
            "title": "Hotine Oblique Mercator Projection (CSoblqm)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csoblqmf-forward-conversion", 
            "text": "int CSoblqmF (Const struct cs_Oblqm_ *oblqm, double xy 2], Const double ll[2]);  Given a properly initialized  cs_Oblqm_  structure via the  oblqm  argument,  CSoblqmF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSoblqmF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSoblqmF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csoblqmi-inverse-conversion", 
            "text": "int CSoblqmI (Const struct cs_Oblqm_ *oblqm, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Oblqm_  structure via the  oblqm  argument,  CSoblqmI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSoblqmI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).\nIn both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSoblqmI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csoblqmk-scale-k", 
            "text": "double CSoblqmK (Const struct cs_Oblqm_ *oblqm, Const double ll[2]);  CSoblqmK  returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. This is calculated using  CS_llazdd  as we have been unable to locate definitive formulas for the grid scale factor for this projection.", 
            "title": "CSoblqmK scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csoblqmc-convergence-angle", 
            "text": "double CSoblqmC (Const struct cs_Oblqm_ *oblqm, Const double ll[2]);  CSoblqmC  returns the convergence angle is degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. This is calculated using  CS_llazdd  as we have been unable to locate definitive formulas for the convergence angle for this projection.", 
            "title": "CSoblqmC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csoblqmq-definition-quality-check", 
            "text": "int CSoblqmQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);  CSoblqmQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Oblique Mercator (Hotine) Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CSoblqmQ  only examines those components specific to the Oblique Mercator (Hotine) Projection.  CSoblqmQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSoblqmQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSoblqmQ definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csoblqml-latitudelongitude-check", 
            "text": "int CSoblqmL (Const struct cs_Oblqm_ *oblqm, int cnt, Const double pnts[][3]);  CSoblqmL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  oblqm  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSoblqmsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSoblqmL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSoblqmL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csoblqmx-xy-coordinate-check", 
            "text": "int CSoblqmX (Const struct cs_Oblqm_ *oblqm, int cnt, Const double pnts[][3]);  CSoblqmX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  oblqm  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSoblqmsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSoblqmL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSoblqmX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csoblqms-setup", 
            "text": "void CSoblqmS(struct cs_Csprm_ *csprm);  The  CSoblqmS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central great circle, the origin latitude, and other projection parameters are known, there are many calculations that need only be performed once.  CSoblqmS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by the  csprm  argument. Thus, this one argument provides  CSoblqmS  its input data and the repository for the results as described below.  CSoblqmS  examines the  prj_code  element of the  cs_Csprm_  structure to determine which of the six variations of this projection is to be setup. In most cases, the variations require different usage of the parameters in the  cs_Csdef_  structure as defined below.", 
            "title": "CSoblqmS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_14", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csldef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure that must be initialized for the Oblique Mercator projection are dependent upon the variation being implemented.  The following parameters apply to all six variations of the projection:     Parameter  Description      scl_red  The scale reduction that is to be applied.    Scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    Quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#single-point-unrectified-hotine-oblique-mercator-cs_prjcod_hom1uv", 
            "text": "This variation produces unrectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the \"aposphere\". Rarely, if ever used; retained primarily for historical purposes.     Parameter  Description      prj_prm1  Longitude, in degrees, of the central point of the projection.    prj_prm2  Latitude, in degrees, of the central point of the projection.    prj_prm3  The azimuth of the central great circle, in degrees east of north.", 
            "title": "Single Point, Unrectified Hotine Oblique Mercator (cs_PRJCOD_HOM1UV)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#two-point-unrectified-hotine-oblique-mercator-cs_prjcod_hom2uv", 
            "text": "This variation produces unrectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the \"aposphere.\" Rarely, if ever used; retained primarily for historical purposes.     Parameter  Description      prj_prm1  Longitude, in degrees, of the first point on the central geodesic.    prj_prm2  Latitude, in degrees, of the first point on the central geodesic.    prj_prm3  Longitude, in degrees, of the second point on the central geodesic.    prj_prm4  Latitude, in degrees, of the second point on the central geodesic.    org_lat  The latitude, in degrees, of the center of the coordinate system being defined. That is, the point on the central geodesic that has this latitude is the natural origin of the projection.", 
            "title": "Two Point, Unrectified Hotine Oblique Mercator (cs_PRJCOD_HOM2UV)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#alaska-variation-hotine-oblique-mercator-cs_prjcod_hom1xy", 
            "text": "This variation produces rectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the \"aposphere\". The rectification technique is specific to Zone 1 of the Alaska State Plane Coordinate System. It is possible that this variation should also be used for the Great Lakes Survey, but this has not been verified as of this writing.     Parameter  Description      prj_prm1  Longitude, in degrees, of the central point of the projection.    prj_prm2  Latitude, in degrees, of the central point of the projection.    prj_prm3  The azimuth of the central great circle, in degrees east of north.", 
            "title": "Alaska Variation, Hotine Oblique Mercator (cs_PRJCOD_HOM1XY)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#two-point-rectified-hotine-oblique-mercator-cs_prjcod_hom2xy", 
            "text": "This variation produces rectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the \"aposphere\". Rarely, if ever used; retained primarily for historical purposes. To remain consistent with prior releases of CS-MAP, this variation uses the same rectification technique as the Alaska variation described immediately above.     Parameter  Description      prj_prm1  Longitude, in degrees, of the first point on the central geodesic.    prj_prm2  Latitude, in degrees, of the first point on the central geodesic.    prj_prm3  Longitude, in degrees, of the second point on the central geodesic.    prj_prm4  Latitude, in degrees, of the second point on the central geodesic.    org_lat  The latitude, in degrees, of the center of the coordinate system being defined. That is, the point on the central geodesic that has this latitude is the natural origin of the projection.", 
            "title": "Two Point, Rectified Hotine Oblique Mercator (cs_PRJCOD_HOM2XY)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#rectified-skew-orthomorphic-cs_prjcod_rskew", 
            "text": "This variation produces rectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the \"aposphere\". The rectification technique is that commonly used in places other than Alaska.     Parameter  Description      prj_prm1  Longitude, in degrees, of the central point of the projection.    prj_prm2  Latitude, in degrees, of the central point of the projection.    prj_prm3  The azimuth of the central great circle, in degrees east of north.", 
            "title": "Rectified Skew Orthomorphic (cs_PRJCOD_RSKEW)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#rectified-skew-orthomorphic-centered-cs_prjcod_rskewc", 
            "text": "This variation produces rectified cartesian coordinates, the origin of which is at the single defining point. The rectification technique is that commonly used in places other than Alaska.     Parameter  Description      prj_prm1  Longitude, in degrees, of the central point of the projection.    prj_prm2  Latitude, in degrees, of the central point of the projection.    prj_prm3  The azimuth of the central great circle, in degrees east of north.", 
            "title": "Rectified Skew Orthomorphic Centered (cs_PRJCOD_RSKEWC)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_13", 
            "text": "The values of equatorial radius and eccentricity are extracted from the datum element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_oblqm_-structure", 
            "text": "The results of the one-time calculations are recorded in the  oblqm  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSoblqmF ,  CSoblqmI ,  CSoblqmK , and  CSoblqmC  functions require as their first argument.", 
            "title": "cs_Oblqm_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#krovak-oblique-conformal-conic", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Krovak Oblique Conformal Conic Projection. This projection is used in what used to be Czechoslovokia, and is now the Czech Republic and the Slovak Republic. Since this projection is conformal, the K and H scale factors are the same and there is no H function. Two variations of this projection are supported.  The first variation is the traditional projection as used since the 1920's. The second includes the affine transformation devised for use with the 1995 adjustment.  Please note that traditional Krovak X coordinates increase to the west. When such coordinates are used in the traditional CAD environment, the resulting images are mirrored and are (for most folks anyway) useless. Therefore, this implementation is such that what would normally be positive X coordinates are actually negative coordinates, and the magnitude of the values will be correct. In this way, the absolute value of the coordinate will be what is expected to see, but the coordinates will actually increase to the east, thus making AutoCAD, MicroStation, and other CAD type systems happy campers.", 
            "title": "Krovak Oblique Conformal Conic"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cskrovkf-forward-conversion", 
            "text": "int CSkrovkF (Const struct cs_Krovk_ *krovk, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Krovk_  structure via the  krovk  argument,  CSkrovkF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSkrovkF  normally returns  cs_CNVRT_NRM L. If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.  The  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSkrovkF Forward Conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cskrovki-inverse-conversion", 
            "text": "int CSkrovkI (Const struct cs_Krovk_ *krovk, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Krovk_  structure via the  krovk  argument,  CSkrovkI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSkrovkI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the xy value is not within the domain of the coordinate system.  The  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSkrovkI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cskrovkk-scale-k", 
            "text": "double CSkrovkK (Const struct cs_Krovk_ *krovk, Const double ll[2]);  CSkrovkK  returns the grid scale factor of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. The value  cs_SclInf  (defined to be 9,999.00 is CSdata.c) is returned if the  ll  provided is the oblique pole.", 
            "title": "CSkrovkK scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cskrovkc-convergence-angle", 
            "text": "double CSkrovkC (Const struct cs_Krovk_ *krovk, Const double ll[2]);  CSkrovkC  returns the convergence angle in degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSkrovkC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cskrovkq-definition-quality-check", 
            "text": "int CSkrovkQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);  CSkrovkQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Krovak Oblique Conformal Conic Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CSkrovakQ  only examines those components specific to the Krovak Oblique Conformal Conic Projection.  CSkrovkQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSkrovkQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSkrovkQ definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#bugs", 
            "text": "In the original implementation of this projection, all parameters were hard coded and no checking was necessary. For release 10, this projection was rewritten to accept user defined parameters, but this quality check function was never updated. Therefore, at the current time, there is no parameter checking performed for this projection.", 
            "title": "Bugs"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cskrovkl-latitudelongitude-check", 
            "text": "int CSoblqmL (Const struct cs_Oblqm_ *oblqm, int cnt, Const double pnts[][3]);  CSoblqmL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  oblqm  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSoblqmsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSoblqmL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSkrovkL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cskrovkx-xy-coordinate-check", 
            "text": "int CSoblqmX (Const struct cs_Oblqm_ *oblqm,int cnt,Const double pnts [ ] [ 3] ) ;  At the current time,  CSoblqmX  returns  cs_CNVRT_OK  without performing any checks. The arguments are currently ignored. Again, this is due to the unusual legacy of this projection, and the fact that normal coordinates used in the Czech Repulic increase to the west rather than the east.", 
            "title": "CSkrovkX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cskrovks-setup", 
            "text": "void CSkrovkS (struct cs_Csprm_ *csprm);  The  CSkrovkS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin longitude, origin latitude, oblique pole location, and other projection parameters are known, there are many calculations that need only be performed once.  CSkrovkS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by the  csprm  argument. Thus, this one argument provides  CSkrovkS  its input data and the repository for the results as described below.  CSkrovkS  examines the  prj_code  element of the  cs_Csprm_  structure to determine which of the two variations of this projection is to be setup. The projection code, therefore, simply determines if the 1995 adjustment transformation is applied to the resulting cartesian coordinates. The parameters for the affine tranformation are (currently) hard coded.", 
            "title": "CSkrovkS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_15", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csldef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure that must be initialized for the Krovak Oblique Conformal Conic Projection are dependent upon the variation being implemented.  The following parameters apply to both variations of the projection:     Parameter  Description      org_lng  Longitude, in degrees, of the origin of the projection. As is commonly used in the Czech Repoublic, this is usually the prime meridian of Ferro.    org_lat  Latitude, in degrees, of the origin of the projection.    prj_prm1  Longitude, in degrees, of the location of the pole of the oblique cone.    prj_prm2  Latitude, in degrees, of the location of the pole of the oblique cone.    prj_prm3  Latitude, in degrees on the oblique gaussian surface, of the single standard parallel of the conic projection surface.    scl_red  The scale reduction that is to be applied.    Scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    Quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#krovak-oblique-conformal-conic-czechoslovokia-cs_prjcod_", 
            "text": "This variation produces the traditional (i.e. unadjusted) Krovak coordinates used in Czechoslovakia since the 1920's. There are no special parameter requirements. Specifying this variation simply turns off the application of the 1995 adjustment.", 
            "title": "Krovak Oblique Conformal Conic, Czechoslovokia (cs_PRJCOD_)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#krovak-oblique-conformal-conic95-adjustment", 
            "text": "This variation causes an affine transformation to be applied to the traditional coordinates, thus producing coordinates appropriate for the 1995 adjustment. There are no special parameter requirements (at this time). Specifying this variation simply turns on the affine transformation, the coefficients of which are hard coded.", 
            "title": "Krovak Oblique Conformal Conic/95 Adjustment"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_14", 
            "text": "The values of equatorial radius and eccentricity are extracted from the datum element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_krovk_-structure", 
            "text": "The results of the one-time calculations are recorded in the  oblqm * element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSkrovkF ,  CSkrovkI ,  CSkrovkK , and  CSkrovkC  functions require as their first argument.", 
            "title": "cs_Krovk_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#lambert-conformal-conic-projection-cslmbrt", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Lambert Conformal Conic Projection. Since this projection is a conformal projection, the K and H scale factors are the same and there is no H function. Five variations of this projection are supported.", 
            "title": "Lambert Conformal Conic Projection (CSlmbrt)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmbrtf-forward-conversion", 
            "text": "int CSlmbrtF (Const struct cs_Lmbrt_ *lmbrt, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Lmbrt_  structure via the  lmbrt  argument,  CSlmbrtF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSlmbrtF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSlmbrtF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmbrti-inverse-conversion", 
            "text": "int CSlmbrtI (Const struct cs_Lmbrt_ *lmbrt, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Lmbrt_  structure via the  lmbrt  argument,  CSlmbrtI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSlmbrtI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSlmbrtI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmbrtk-scale-k", 
            "text": "double CSlmbrtK (Const struct cs_Lmbrt_ *lmbrt, Const double ll[2]);\n````\n\n`CSlmbrtK` returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the **ll** array.\n\n### CSlmbrtC convergence angle\n\n```c\ndouble CSlmbrtC (Const struct cs_Lmbrt_ *lmbrt, Const double ll[2]);  CSlmbrtC  returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSlmbrtK scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmbrtq-definition-quality-check", 
            "text": "int CSlmbrtQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSlmbrtQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Lambert Conformal Conic Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CSlmbrtQ  only examines those components specific to the Lambert Conformal Conic Projection.  CSlmbrtQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSlmbrtQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSlmbrtQ definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmbrtl-latitudelongitude-check", 
            "text": "int CSlmbrtL (Const struct cs_Lmbrt_ *lmbrt, int cnt, Const double pnts[][3]);  CSlmbrtL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  lmbrt  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSlmbrtsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSlmbrtL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSlmbrtL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmbrtx-xy-coordinate-check", 
            "text": "int CSlmbrtX (Const struct cs_Lmbrt_ *lmbrt, int cnt, Const double pnts[][3]);  CSlmbrtX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  lmbrt  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSlmbrtsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSlmbrtL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSlmbrtX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmbrts-setup", 
            "text": "void CSlmbrtS (struct cs_Csprm_*csprm);  The  CSlmbrtS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallels, the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once.  CSlmbrtS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CSlmbrtS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSlmbrtS setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_16", 
            "text": "The definition of the coordinate system is extracted from the csdef element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time.  Five variations of this projection are supported.  CSlmbrtS  determines which variation is to be setup by examining the  prj_code  element of the  cs_Csprm_  structure. The actual use of parameters in the  cs_Csdef_  structure (an element of the  cs_Csprm_  structure) is dependent on the variation being setup.  The following elements of the  cs_Csdef_  structure apply to all five variations:     Element  Description      Scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.     Parameter use specific to the five variations is:", 
            "title": "Coordinate system definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#two-standard-parallels-cs_prjcod_lmbrt", 
            "text": "This is the traditional version of this projection. The degree of scale reduction to reduce and distribute scale distortion is specified by two standard parallels:     Element  Description      prj_prm1  Latitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).    prj_prm2  Latitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.    org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.", 
            "title": "Two Standard Parallels (cs_PRJCOD_LMBRT)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#single-standard-parallel-cs_prjcod_lm1sp", 
            "text": "This variation is commonly used outside of North America. It is, mathematically, virtually identical to what CS-MAP has long referred to as the Lambert Tangential. The degree of scale reduction to reduce and distribute scale distortion is specified by the scale reduction factor:     Element  Description      org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.    scl_red  The scale of the projection at the origin defined by org_lng and org_lat.", 
            "title": "Single Standard Parallel (cs_PRJCOD_LM1SP)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#belgian-variation-cs_prjcod_lmblgn", 
            "text": "This is a minor variation to the traditional Two Standard Parallel version of the projection. This variation will produce the results required by some Belgian coordinate systems:     Parameter  Description      prj_prm1  Latitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).    prj_prm2  Latitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.    org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.", 
            "title": "Belgian Variation (cs_PRJCOD_LMBLGN)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#wisconsin-variation-cs_prjcod_wccsl", 
            "text": "This is a minor variation to the traditional Two Standard Parallel version of the projection. This variation supports the Wisconsin County Coordinate System group of coordinate systems. This variation uses a parallel ellipsoid technique to adjust horizontal coordinates for average elevation of the region being mapped:     Parameter  Description      prj_prm1  Latitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).    prj_prm2  Latitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.    prj_prm3  Average geoid separation,  in meters , of the region being mapped.    prj_prm4  Average elevation above the geoid (i.e. orthometric height),  in system units , of the region being mapped.    org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.", 
            "title": "Wisconsin Variation (cs_PRJCOD_WCCSL)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#minnesota-variation-cs_prjcod_mndotl", 
            "text": "This is a minor variation to the traditional Two Standard Parallel version of the projection. This variation supports the county coordinate systems developed by the Minnesota Department of Transportation. This variation uses a parallel ellipsoid technique (different from that used in Wisconsin, of course) to adjust horizontal coordinates for average elevation of the region being mapped:     Parameter  Description      prj_prm1  Latitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).    prj_prm2  Latitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as  prj_prm1 , to obtain a conic with a single point of tangency.    prj_prm3  Average height above the ellipsoid, **in system units    org_lng  The longitude, in degrees, of the origin of the projection.    org_lat  The latitude, in degrees, of the origin of the projection.", 
            "title": "Minnesota Variation (cs_PRJCOD_MNDOTL)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_15", 
            "text": "The values of equatorial radius and eccentricity are extracted from the  datum  element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_lmbrt_-structure", 
            "text": "The results of the one-time calculations are recorded in the  lmbrt  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSlmbrtF ,  CSlmbrtI ,  CSlmbrtK , and  CSlmbrtC  functions require as their first argument.", 
            "title": "cs_Lmbrt_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#lambert-tangential-projection-cslmtan", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Lambert Tangential Projection as used by the National Geographic Institute of France. Please note that the current implementation of this projection does not support the spherical form of the projection. With the addition of the single standard parallel variation of the Lambert Conformal Conic, these functions are now redundant; and will be removed in a future release.", 
            "title": "Lambert Tangential Projection (CSlmtan)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmtanf-forward-conversion", 
            "text": "int CSlmtanF (Const struct cs_Lmtan_ *lmtan, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Lmtan_  structure via the  lmtan  argument,  CSlmtanF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSlmtanF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSlmtanF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmtani-inverse-conversion", 
            "text": "int CSlmtanI (Const struct cs_Lmtan_ *lmtan, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Lmtan_  structure via the  lmtan  argument,  CSlmtanI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSlmtanI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSlmtanI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmtank-parallel-scale-k", 
            "text": "double CSlmtanK (Const struct cs_Lmtan_ *lmtan, Const double ll[2]);  CSlmtanK  returns the grid scale factor, along a parallel, of the coordinate system at the geodetic location given by the  ll  argument. Formulas for this calculation have not been located, therefore the result is obtained using the  CS_llazdd  function.", 
            "title": "CSlmtanK parallel scale (K)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmtanh-meridian-scale-h", 
            "text": "double CSlmtanH (Const struct cs_Lmtan_ *lmtan, Const double ll[2]);  CSlmtanH  returns the grid scale factor, along a meridian, of the coordinate system at the geodetic location given by the  ll  argument. Formulas for this calculation have not been located, therefore the result is obtained from the use of the  CS_llazdd  function.", 
            "title": "CSlmtanH meridian scale (H)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmtanc-convergence-angle", 
            "text": "double CSlmtanC (Const struct cs_Lmtan_ *lmtan, Const double ll[2]);  CSlmtanC  returns the convergence angle in degrees east of north of the coordinate system at the geodetic location given by the  ll  argument. Formulas for this calculation have not been located, therefore the result is obtained using the  CS_llazdd  function.", 
            "title": "CSlmtanC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmtanl-latitudelongitude-check", 
            "text": "int CSlmtanL (Const struct cs_Lmtan_ *lmtan, int cnt, Const double pnts [][3]);  CSlmtanL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  lmtan  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSlmtansL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSlmtanL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSlmtanL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmtanq-definition-quality-check", 
            "text": "int CSlmtanQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSlmtanQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Lambert Tangential Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CSlmtanQ  only examines those components specific to the Lambert Tangential Projection.  CSlmtanQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSlmtanQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSlmtanQ definition quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmtanx-xy-coordinate-check", 
            "text": "int CSlmtanX (Const struct cs_Lmtan_ *lmtan, int cnt, Const double pnts [][3]);  CSlmtanX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnt s and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  lmtan  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSlmtansX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSlmtanL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSlmtanX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cslmtans-setup", 
            "text": "void CSlmtanS (struct cs_Csprm_ *csprm);  The  CSlmtanS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude, the scale reduction factor, and other projection parameters are known, there are many calculations that need only be performed once.  CSlmtanS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CSlmtanS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSlmtanS setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_17", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure that must be initialized for the Lambert Tangential projection are:     Element  Description      org_lng  The longitude, in degrees, of the origin of the projection relative to Greenwich.    org_lat  The latitude, in degrees, of the origin of the projection relative to the equator.    scl_red  The scale reduction factor that is to be applied to the projection.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This value is the X coordinate of the coordinate system origin.    y_off  The false northing to be applied to all Y coordinates. This value is the Y coordinate of the coordinate system origin.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_16", 
            "text": "The values of equatorial radius and eccentricity are extracted from the datum element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_lmtan_-structure", 
            "text": "The results of the one-time calculations are recorded in the  lmtan  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSlmtanF ,  CSlmtanI ,  CSlmtanK ,  CSlmtanH , and  CSlmtanC  functions require as their first argument.", 
            "title": "cs_Lmtan_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#mercator-projection-csmrcat", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Mercator Projection. Since this projection is conformal, the K and H grid scales are the same and there is no H function.", 
            "title": "Mercator Projection (CSmrcat)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmrcatf-forward-conversion", 
            "text": "int CSmrcatF (Const struct cs_Mrcat_ *mrcat, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Mrcat_  structure via the  mrcat  argument,  CSmrcatF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSmrcatF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSmrcatF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmrcati-inverse-conversion", 
            "text": "int CSmrcatI (Const struct cs_Mrcat_ *mrcat, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Mrcat_  structure via the mrcat argument,  CSmrcatI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSmrcatI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the xy value is not within the domain of the coordinate system.  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSmrcatI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmrcatk-scale-k-along-a-parallel", 
            "text": "double CSmrcatK (Const struct cs_Mrcat_ *mrcat, Const double ll[2]);  CSmrcatK  returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSmrcatK scale (K) along a parallel"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmrcatc-convergence-angle", 
            "text": "double CSmrcatC (Const struct cs_Mrcat_ *mrcat, Const double ll[2]);  CSmrcatC  returns the value 0.0 which represents the convergence in degrees east of north of nay coordinate system based on this projection at any latitude and longitude.", 
            "title": "CSmrcatC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmrcatq-definition-quality-check", 
            "text": "int CSmrcatQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSmrcatQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Mercator Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CSmrcatQ  only examines those components specific to the Mercator Projection.  CSmrcatQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSmrcatQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSmrcatQ definition Quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmrcatl-latitudelongitude-check", 
            "text": "int CSmrcatL (Const struct cs_Mrcat_ *mrcat, int cnt, Const double pnts[][3]);  CSmrcatL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  mrcat  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSmrcatsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSmrcatL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSmrcatL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmrcatx-xy-coordinate-check", 
            "text": "int CSmrcatX (Const struct cs_Mrcat_ *mrcat, int cnt, Const double pnts[][3]);  CSmrcatX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  mrcat  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSmrcatsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSmrcatL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSmrcatX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmrcats-setup", 
            "text": "void CSmrcatS (struct cs_Csprm_*csprm);  The  CSmrcatS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallel, the origin longitude, and other projection parameters are known, there are many calculations that need only be performed once.  CSmrcatS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CSmrcatS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSmrcatS setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_18", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure which must be initialized for the Mercator Projection are:     Element  Description      prj_prm1  Longitude, in degrees, of the central meridian of the coordinate system (or map).    prj_prm2  Latitude, in degrees, of the standard parallel, usually zero indicating the equator. Using a non-zero value has an affect similar to that of the scale reduction factor of other cylindrical projections.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_17", 
            "text": "The values of equatorial radius and eccentricity are extracted from the datum element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_mrcat_-structure", 
            "text": "The results of the one-time calculations are recorded in the  mrcat  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSmrcatF ,  CSmrcatI ,  CSmrcatK , and  CSmrcatC  functions require as their first argument.", 
            "title": "cs_Mrcat_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#miller-projection-csmillr", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Miller Projection. This projection is only used in the spherical form. Thus, all functions assume a sphere with a radius equal to the equatorial radius of the ellipsoid provided.", 
            "title": "Miller Projection (CSmillr)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmillrf-forward-conversion", 
            "text": "int CSmillrF (Const struct cs_Millr_ *millr, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Millr_  structure via the  millr  argument,  CSmillrF  will convert the latitude and longitude provided in the  ll  array to X and Y coordinates, returning the result in the  xy  array.  CSmillrF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSmillrF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmillri-inverse-conversion", 
            "text": "int CSmillrI (Const struct cs_Millr_ *millr, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Millr_  structure via the  millr  argument,  CSmillrI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSmillrI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the  xy  value is not within the domain of the coordinate system.  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSmillrI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmillrk-scale-k-along-a-parallel", 
            "text": "double CSmillrK (Const struct cs_Millr_ *millr, Const double ll[2]);  CSmillrK  returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSmillrK scale (K) along a parallel"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmillrh-scale-h-along-a-meridian", 
            "text": "double CSmillrH (Const struct cs_Millr_ *millr, Const double ll[2]);  CSmillrH  returns the grid scale factor, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array.", 
            "title": "CSmillrH scale (H) along a meridian"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmillrc-convergence-angle", 
            "text": "double CSmillrC (Const struct cs_Millr_ *millr, Const double ll[2]);  CSmillrC  returns the value 0.0 which represents the convergence angle in degrees east of north of any coordinate system based on this projection at any latitude and longitude.", 
            "title": "CSmillrC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmillrl-latitudelongitude-check", 
            "text": "int CSmillrL (Const struct cs_Millr_ *millr, int cnt, Const double pnts[][3]);  CSmillrL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  millr  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSmillrsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSmillrL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSmillrL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmillrq-definition-quality-check", 
            "text": "int CSmillrQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);  CSmillrQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Miller Cylindrical Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CSmillrQ  only examines those components specific to the Miller Cylindrical Projection.  CSmillrQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSmillrQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSmillrQ definition Quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmillrx-xy-coordinate-check", 
            "text": "int CSmillrX (Const struct cs_Millr_ *millr, int cnt, Const double pnts[][3]);  CSmillrX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  millr  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSmillrsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSmillrL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSmillrX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmillrs-setup", 
            "text": "void CSmillrS (struct cs_Csprm_*csprm);  The  CSmillrS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin longitude and other projection parameters are known, there are many calculations that need only be performed once.  CSmillrS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CSmillrS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSmillrS setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_19", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure that must be initialized for the Miller Projection are:     Element  Description      prj_prm1  Longitude, in degrees, of the central meridian of the coordinate system (or map).    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    quad  an integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_18", 
            "text": "The value of equatorial radius is extracted from the datum element of the  cs_Csprm_  structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required element is:     Element  Description      e_rad  The radius of the earth, as a sphere, in meters.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_millr_-structure", 
            "text": "The results of the one-time calculations are recorded in the  millr  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSmillrF ,  CSmillrI ,  CSmillrK ,  CSmillrH , and  CSmillrC  functions require as their first argument.", 
            "title": "cs_Millr_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#modified-polyconic-projection-csmodpc", 
            "text": "This set of functions represent the Coordinate System Mapping Package's knowledge of the Modified Polyconic Projection. That is, the projection developed by Lallemand of France and adopted by the International Map Committee (IMC) in London as the basis for the 1:1,000,000 scale International Map of the World (IMW) series in 1909.", 
            "title": "Modified Polyconic Projection (CSmodpc)"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmodpcf-forward-conversion", 
            "text": "int CSmodpcF (Const struct cs_Modpc_ *modpc, double xy[2], Const double ll[2]);  Given a properly initialized  cs_Modpc_  structure via the  modpc  argument,  CSmodpcF  will convert the latitude and longitude provided in the a array to X and Y coordinates, returning the result in the  xy  array.  CSmodpcF  normally returns  cs_CNVRT_NRML . If  ll  is not within the domain of the coordinate system,  xy  is set to a \"rational\" result and  cs_CNVRT_RNG  is returned.", 
            "title": "CSmodpcF Forward conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmodpci-inverse-conversion", 
            "text": "int CSmodpcI (Const struct cs_Modpc_ *modpc, double ll[2], Const double xy[2]);  Given a properly initialized  cs_Modpc_  structure via the  modpc  argument,  CSmodpcI  will convert the X and Y coordinates given in the  xy  array to latitude and longitude and return the result in the  ll  array.  CSmodpcI  normally returns  cs_CNVRT_NRML . It will return  cs_CNVRT_RNG  if the xy value is not within the domain of the coordinate system, or  cs_CNVRT_INDF  if the result is indefinite (e.g. longitude is not defined at the poles).  In both cases above, the  xy  and  ll  arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.", 
            "title": "CSmodpcI Inverse conversion"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmodpck-grid-scale-k-along-parallel", 
            "text": "double CSmodpcK ( Const struct cs_Modpc_ *modpc, Const double ll[2]);  CSmodpcK  returns the grid scale factor, as measured along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. (The use of the  ll  array is the same as described above.) At the current time, formulas that analytically produce the grid scale factor for this projection elude us. Thus, the grid scale factor is determined using the  CS_llazdd  function.", 
            "title": "CSmodpcK grid scale (K), along parallel"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmodpch-grid-scale-h-along-meridian", 
            "text": "double CSmodpcH ( Const struct cs_Modpc_ *modpc, Const double ll[2]);  CSmodpcH  returns the grid scale factor, as measured along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. At the current time, formulas that analytically produce the grid scale factor for this projection elude us. Thus, the grid scale factor is determined using the  CS_llazdd  function.", 
            "title": "CSmodpcH grid scale (H), along meridian"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmodpcc-convergence-angle", 
            "text": "double CSmodpcC (Const struct cs_Modpc_ *modpc, Const double ll[2]);  CSmodpcC  returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the  ll  array. At the current time, formulas that analytically produce the convergence angle for this projection elude us. Thus, the grid scale factor is determined using the  CS_llazdd  function.", 
            "title": "CSmodpcC Convergence angle"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmodpcb-basic-calculations", 
            "text": "double CSmodpcB (Const struct cs_Modpc_ *modpc, Const double ll[2], double xy[2], double *their_yc);  Inverse calculations for this projection are performed using an iterative algorithm calling the forward function.  CSmodpcB  converts geographic coordinates to cartesian coordinates in a form that can be used by both  CSmodpcF  and  CSmodpcI ; thus eliminating duplicate code in these modules. The  their_yc  argument provides for the return to the calling function of an additional intermediary result that is required for the inverse calculation.", 
            "title": "CSmodpcB Basic calculations"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmodpcq-definition-quality-check", 
            "text": "int CSmodpcQ ( Const struct cs_Csdef_ *csdef , unsigned short prj_code, int *err_list [], int list_sz);  CSmodpcQ  determines if the coordinate system definition provided by the  csdef  argument is consistent with the requirements of the Modified Polyconic Projection.  CS_cschk  examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore,  CSmodpcQ  only examines those components specific to the Modified Polyconic Projection.  CSmodpcQ  returns in  err_list  an integer code value for each error condition detected, being careful not to exceed the size of  err_list  as indicated by the  list_sz  argument. The number of errors detected, regardless of the size of  err_list , is always returned. Refer to  CSerpt  for a description of the various error codes and their meaning.  CSmodpcQ  may be called with the  NULL  pointer and/or a zero for the  err_list  and  list_sz  arguments respectively.", 
            "title": "CSmodpcQ definition Quality check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmodpcl-latitudelongitude-check", 
            "text": "int CSmodpcL ( Const struct cs_Modpc_ *modpc, int cnt, Const double pnts[][3]);  CSmodpcL  determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  modpc  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a great circle ( cnt  == 2), or a closed region ( cnt    3).  CSmodpcsL 's return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined.  CSmodpcL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.", 
            "title": "CSmodpcL Latitude/longitude check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmodpcx-xy-coordinate-check", 
            "text": "int CSmodpcX (Const struct cs_Modpc_ *modpc, int cnt, Const double pnts[][3]);  CSmodpcX  determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the  pnts  and  cnt  arguments are within the mathematical domain of the coordinate system provided by the  modpc  argument. The  pnts  and  cnt  arguments can define a single coordinate ( cnt  == 1), a line ( cnt  == 2), or a closed region ( cnt    3).  CSmodpcsX 's return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined.  CSmodpcL  returns  cs_CNVRT_OK  if all subject coordinates are within the mathematical domain of the coordinate system.  cs_CNVRT_DOMN  is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.", 
            "title": "CSmodpcX Xy coordinate check"
        }, 
        {
            "location": "/userguide/cartographicprojections/#csmodpcs-setup", 
            "text": "void CSmodpcS (struct cs_Csprm_ *csprm);  The  CSmodpcS  function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard meridians, the standard parallels, and other projection parameters are known, there are many calculations that need only be performed once.  CSmodpcS  performs these calculations and saves the results in the  cs_Csprm_  structure provided by its argument,  csprm . Thus, the single argument provided to  CSmodpcS  serves as the source for input and the repository for the results as described below.", 
            "title": "CSmodpcS Setup"
        }, 
        {
            "location": "/userguide/cartographicprojections/#coordinate-system-definition_20", 
            "text": "The definition of the coordinate system is extracted from the  csdef  element of the  cs_Csprm_  structure. Usually, this is obtained from the Coordinate System Dictionary by the  CS_csdef  function; but can be provided by the application at run time. The specific elements of the  cs_Csdef_  structure that must be initialized for the Modified Polyconic projection are:     Element  Description      prj_prm1  Longitude, in degrees, of the central meridian.    prj_prm2  Longitude, in degrees, of the Eastern meridian. The Western meridian is assumed to be west of the Central Meridian by the same amount that the Eastern Meridian is east of the Central Meridian. The Eastern meridian must be east of the central meridian, and not more than 15 degrees of longitude from the central meridian.    prj_prm3  Latitude, in degrees, of the Northern Standard Parallel.    prj_prm4  Latitude, in degrees, of the Southern Standard Parallel.    scale  The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.    x_off  The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.    y_off  The false northing to be applied to all Y coordinates.    quad  An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.     Neither standard parallel may be a pole, nor can the two standard parallels be the same as is supported in other projections. In addition, the Northern Standard Parallel must be the northernmost of the two standard parallels. Finally, the two standard parallels must be within 15 degrees of each other. Note that the projection was designed for maps whose extents are 6 degrees of longitude and 4 degrees of latitude.", 
            "title": "Coordinate System Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#datum-definition_19", 
            "text": "The values of equatorial radius and eccentricity are extracted from the datum element of the  cs_Csprm_  structure. These are normally obtained from the Ellipsoid Dictionary by the  CS_dtloc  function, but may be supplied by the application at run time. Specifically, the required elements are:     Element  Description      e_rad  The equatorial radius of the earth in meters.    eccent  This value represents the eccentricity of the ellipsoid.    to84_via  An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.", 
            "title": "Datum Definition"
        }, 
        {
            "location": "/userguide/cartographicprojections/#cs_modpc_-structure", 
            "text": "The results of the one-time calculations are recorded in the  modpc  element of the  prj_prms  union of the  cs_Csprm_  structure. It is a pointer to this initialized structure that the  CSmodpcF ,  CSmodpcI ,  CSmodpcK ,  CSmodpcH ,  CSmodpcC , and  CSmodpcB  functions require as their first argument.", 
            "title": "cs_Modpc_ Structure"
        }, 
        {
            "location": "/userguide/cartographicprojections/#bugs_1", 
            "text": "As is true with all other projections in CS-MAP, values submitted for conversion are not checked for validity before conversion for performance reasons. In every other case, this does not appear to be a problem. However, experience has show that values which are more than 50% outside the area covered by the projection parameters can produce errors which get reported through matherr. Checking of input values does need to be added to the functions of this projection.", 
            "title": "BUGS"
        }, 
        {
            "location": "/userguide/datamodules/", 
            "text": "", 
            "title": "Data Modules"
        }, 
        {
            "location": "/license/", 
            "text": "Copyright \u00a9 \n2008\n, \nAutodesk, Inc.\n\n\nAll rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\n\nNeither the name of the \nAutodesk, Inc.\n nor the\n   names of its contributors may be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY \nAutodesk, Inc.\n \u201cAS IS\u201d AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL \nAutodesk, Inc.\n BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", 
            "title": "License"
        }
    ]
}