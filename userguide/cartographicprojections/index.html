<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Cartographic Projection Functions - CS-Map</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
	
	<script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../..">CS-Map</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="../..">Home</a>
                    </li>
                    <li >
                        <a href="../../installation/">Installation</a>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../releasenotes/">Release Notes</a>
</li>
                            
<li >
    <a href="../desc/">Descriptions/Discussions</a>
</li>
                            
<li >
    <a href="../executables/">Executables</a>
</li>
                            
<li >
    <a href="../libraryfunctions/">Library Functions</a>
</li>
                            
<li class="active">
    <a href="./">Cartographic Projection Functions</a>
</li>
                            
<li >
    <a href="../datamodules/">Data Modules</a>
</li>
                        </ul>
                    </li>
                    <li >
                        <a href="../../license/">License</a>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../libraryfunctions/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../datamodules/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#cartographic-projection-funtions">Cartographic Projection Funtions</a></li>
            <li><a href="#albers-equal-area-projection-csalber">Albers Equal Area Projection (CSalber)</a></li>
            <li><a href="#american-polyconic-projection-csplycn">American Polyconic Projection (CSplycn)</a></li>
            <li><a href="#azimuthal-equal-area-projection-csazmea">Azimuthal Equal Area Projection (CSazmea)</a></li>
            <li><a href="#azmuthal-equidistant-projection-csazmed">Azmuthal Equidistant Projection (Csazmed)</a></li>
            <li><a href="#bonne-projection-projection-csbonne">Bonne Projection Projection (CSbonne)</a></li>
            <li><a href="#csbonnec-convergence-angle">CSbonneC Convergence angle</a></li>
            <li><a href="#bipolar-oblique-conformal-conic-projection-csbpcnc">Bipolar Oblique Conformal Conic Projection (CSbpcnc)</a></li>
            <li><a href="#cassini-projection-cscsini">Cassini Projection (CScsini)</a></li>
            <li><a href="#danish-system-34-cssys34">Danish System 34 (CSsys34)</a></li>
            <li><a href="#equidistant-conic-projection-csedcnc">Equidistant Conic Projection (CSedcnc)</a></li>
            <li><a href="#equidistant-cylindrical-projection-csedcyl">Equidistant Cylindrical Projection (CSedcyl)</a></li>
            <li><a href="#eckert-iv-projection-csekrt4">Eckert IV Projection (CSekrt4)</a></li>
            <li><a href="#eckert-vi-projection-csekrt6">Eckert VI Projection (CSekrt6)</a></li>
            <li><a href="#gnomonic-projection-csgnomc">Gnomonic Projection (CSgnomc)</a></li>
            <li><a href="#goode-homolosine-projection-cshmlsn">Goode Homolosine Projection (CShmlsn)</a></li>
            <li><a href="#hotine-oblique-mercator-projection-csoblqm">Hotine Oblique Mercator Projection (CSoblqm)</a></li>
            <li><a href="#krovak-oblique-conformal-conic">Krovak Oblique Conformal Conic</a></li>
            <li><a href="#lambert-conformal-conic-projection-cslmbrt">Lambert Conformal Conic Projection (CSlmbrt)</a></li>
            <li><a href="#lambert-tangential-projection-cslmtan">Lambert Tangential Projection (CSlmtan)</a></li>
            <li><a href="#cslmtanf-forward-conversion">CSlmtanF Forward conversion</a></li>
            <li><a href="#cslmtani-inverse-conversion">CSlmtanI Inverse conversion</a></li>
            <li><a href="#mercator-projection-csmrcat">Mercator Projection (CSmrcat)</a></li>
            <li><a href="#miller-projection-csmillr">Miller Projection (CSmillr)</a></li>
            <li><a href="#modified-polyconic-projection-csmodpc">Modified Polyconic Projection (CSmodpc)</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="cartographic-projection-funtions">Cartographic Projection Funtions</h1>
<h2 id="albers-equal-area-projection-csalber">Albers Equal Area Projection (CSalber)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Alber Equal Area Conic Projection.</p>
<h3 id="csalberf-forward-conversion">CSalberF Forward conversion</h3>
<pre><code class="c">int CSalberF (Const struct cs_Alber_ *alber, double xy[2], Const double ll[ 2]);
</code></pre>

<p>Given a properly initialized <code>cs_Alber_</code> structure via the <strong>alber</strong> argument, <code>CSalberF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSalberF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csalberi-inverse-conversion">CSalberI Inverse conversion</h3>
<pre><code class="c">int CSalberI (Const struct cs_Alber_ *alber, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Alber_</code> structure via the <strong>alber</strong> argument, <code>CSalberI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSalberI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csalberk-grid-scale-k-along-parallel">CSalberK grid scale (K) along parallel</h3>
<pre><code class="c">double CSalberK (Const struct cs_Alber_ *alber, Const double ll[2]);
</code></pre>

<p><code>CSalberK</code> returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. (The use of the <strong>ll</strong> array is the same as described above.)</p>
<h3 id="csalberh-grid-scale-h-along-meridian">CSalberH grid scale (H) along meridian</h3>
<pre><code class="c">double CSalberH(Const struct cs_Alber_ *alber, Const double ll[2]);
</code></pre>

<p><code>CSalberH</code> returns the grid scale factor, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="csalberc-convergence-angle">CSalberC Convergence angle</h3>
<pre><code class="c">double CSalberC(Const struct cs_Alber_ *alber, Const double ll[2]);
</code></pre>

<p><code>CSalberC</code> returns the convergence angle in degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="csalberq-definition-quality-check">CSalberQ definition Quality check</h3>
<pre><code class="c">int CSalberQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSalberQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Alber Equal Area Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSalberQ</code> only examines those components specific to the Alber Equal Area Projection. <code>CSalberQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_lis</strong>t, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSalberQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csalberl-latitudelongitude-check">CSalberL Latitude/longitude check</h3>
<pre><code class="c">int CSalberL (Const struct cs_Alber_ *alber, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSalberL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>alber</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSalbersL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSalberL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csalberx-xy-coordinate-check">CSalberX Xy coordinate check</h3>
<pre><code class="c">int CSalberX (Const struct cs-Alber_ *alber, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSalberX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>alber</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSalbersX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSalberL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csalbers-setup">CSalberS Setup</h3>
<pre><code class="c">void CSalberS(struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSalberS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallels, the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSalberS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CSalberS</code> serves as the source for input and the repository for the results as described below</p>
<h3 id="coordinate-system-definition">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the Albers projection are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Latitude, in degrees, of the northern standard parallel. Unlike other conics, it is important to distinguish between the northern and southern standard parallels for the Albers.</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the southern standard parallel. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.</td>
</tr>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>Scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>Quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition">Datum definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the <strong>datum</strong> element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_alber_-structure">cs_Alber_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>alber</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSalberF</code>, <code>CSalberI</code>, <code>CSalberK</code>, <code>CSalberH</code>, and <code>CSalberC</code> functions require as their first argument.</p>
<h2 id="american-polyconic-projection-csplycn">American Polyconic Projection (CSplycn)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the American Polyconic Projection.</p>
<h3 id="csplycnf-forward-conversion">CSplycnF forward conversion</h3>
<pre><code class="c">int CSplycnF (Const struct cs_Plycn_ *plycn, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Plycn_</code> structure via the <strong>plycn</strong> argument, <code>CSplycnF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSplycnF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csplycni-inverse-conversion">CSplycnI inverse conversion</h3>
<pre><code class="c">int CSplycnI (Const struct cs_Plycn_ *plycn, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Plycn_</code> structure via the <strong>plycn</strong> argument, <code>CSplycnI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSplycnI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>ll</strong> and <strong>xy</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csplycnk-grid-scale-k-along-parallel">CSplycnK grid scale (K) along parallel</h3>
<pre><code class="c">double CSplycnK (Const struct cs_Plycn_ *plycn, Const double ll[2]);
</code></pre>

<p><code>CSplycnK</code> returns the value 1.0 which represents the grid scale along a parallel of any coordinate system based on this projection at any location.</p>
<h3 id="csplycnh-grid-scale-h-along-meridian">CSplycnH grid scale (H) along meridian</h3>
<pre><code class="c">double CSplycnH (Const struct cs_Plycn_ *plycn, Const double ll[2]);
</code></pre>

<p><code>CSplycnH</code> returns the grid scale factor, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="csplycnc-convergence-angle">CSplycnC convergence angle</h3>
<pre><code class="c">double CSplycnC (Const struct cs_Plycn_ *plycn, Const double ll[2]);
</code></pre>

<p><code>CSplycnC</code> returns the convergence angle in degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. At the current time, definitive formulas for the convergence angle of this projection elude us. The convergence angle is computed using the <code>CS_llazdd</code> function.</p>
<h3 id="csplycnq-definition-quality-check">CSplycnQ definition quality check</h3>
<pre><code class="c">int CSplycnQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSplycnQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the American Polyconic Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSplycnQ</code> only examines those components specific to the American Polyconic Projection. <code>CSplycnQ</code> returns in err_list an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSplycnQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csplycnl-latitudelongitude-check">CSplycnL Latitude/longitude check</h3>
<pre><code class="c">int CSplycnL(Const struct cs_Plycn_ *plycn, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSplycnL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>plycn</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSplycnsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSplycnL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csplycnx-xy-coordinate-check">CSplycnX Xy coordinate check</h3>
<pre><code class="c">int CSplycnX (Const struct cs_Plycn_ *plycn, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSplycnX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>plycn</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSplycnsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSplycnL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csplycns-setup">CSplycnS setup</h3>
<pre><code class="c">void CSplycnS(struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSplycnS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian, the origin latitude, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSplycnS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CSplycnS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_1">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the American Polyconic projection are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the central meridian.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum">Datum</h3>
<p>The values of equatorial radius and eccentricity are extracted from the datum element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_plycn_-structure">cs_Plycn_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <code>plycn</code> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSplycnF</code>, <code>CSplycnI</code>, <code>CSplycnK</code>, <code>CSplycnH</code>, and <code>CSplycnC</code> functions require as their first argument.</p>
<h2 id="azimuthal-equal-area-projection-csazmea">Azimuthal Equal Area Projection (CSazmea)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Lambert Azimuthal Equal Area Projection</p>
<h3 id="csazmeaf-forward-conversion">CsazmeaF Forward conversion</h3>
<pre><code class="c">int CSazmeaF (Const struct cs_Azmea_ *azmea, double xy[2], Const double ll[2])
</code></pre>

<p>Given a properly initialized <code>cs_Azmea_</code> structure via the <strong>azmea</strong> argument, <code>CSazmeaF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSazmeaF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csazmeai-inverse-conversion">CSazmeaI Inverse conversion</h3>
<pre><code class="c">int CSazmeaI (Const struct cs_Azmea_ *azmea, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Azmea_</code> structure via the <strong>azmea</strong> argument, <code>CSazmeaI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSazmeaI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csazmeak-grid-scale-k-normal">CsazmeaK grid scale (K) normal</h3>
<pre><code class="c">double CSazmeaK (Const struct cs_Azmea_ * azmea, Const double ll[ 2]);
</code></pre>

<p><code>CSazmeaK</code> returns the grid scale factor normal to the radial at the geodetic location specified by the <strong>ll</strong> argument. In the case of the ellipsoidal form of this projection, analytical formulas for this value have not been located and the result is arrived at using the <code>CS_llazdd</code> function.</p>
<h3 id="csazmeah-grid-scale-h-radial">CSazmeaH grid scale (H) radial</h3>
<pre><code class="c">double CSazmeaH (Const struct cs_Azmea_ * azmea, Const double ll[ 2]);
</code></pre>

<p><code>CSazmeaH</code> returns the grid scale factor along a radial line from the coordinate system origin to the point provided. Since this projection is authalic (i.e. equal area), the value returned is the reciprocal of that returned by <code>CSazmeaK</code>.</p>
<h3 id="csazmeac-convergence-angle">CSazmeaC Convergence angle</h3>
<pre><code class="c">double CSazmeaC (Const struct cs_Azmea_ * azmea, Const double ll[ 2]);
</code></pre>

<p><code>CSazmeaC</code> returns the convergence angle in degrees east of north of the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at using the <code>CS_llazdd</code> function.</p>
<h3 id="csazmeaq-definition-quality-check">CSazmeaQ definition Quality check</h3>
<pre><code class="c">int CSazmeaQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSazmeaQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Azimuthal Equal Area Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSazmeaQ</code> only examines those components specific to the Azimuthal Equal Area Projection. <code>CSazmeaQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSazmeaQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csazmeal-latitudelongitude-check">CSazmeaL Latitude/longitude check</h3>
<pre><code class="c">int CSazmeaL (Const struct cs_Azmea_ *azmea, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSazmeaL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>azmea</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSazmeasL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSazmeaL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csazmeax-xy-coordinate-check">CSazmeaX Xy coordinate check</h3>
<pre><code class="c">int CSazmeaX (Const struct cs_Azmea_ *azmea, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSazmeaX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>azmea</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt == 2</strong>), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSazmeasX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSazmeaL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csazmeas-setup">CSazmeaS Setup</h3>
<pre><code class="c">void CSazmeaS(struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSazmeaS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSazmeaS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the argument provided to <code>CSazmeaS</code> serves as the source for input and the repository for the results as described below</p>
<h3 id="coordinate-system-definition_2">Coordinate system definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time.</p>
<p>The following parameters must be set:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>The azimuth, in degrees east of north, of the positive Y-axis of the coordinate system.</td>
</tr>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_1">Datum definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the <strong>datum</strong> element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_azmea_-structure">cs_Azmea_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>azmea</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSazmeaF</code>, <code>CSazmeaI</code>, <code>CSazmeaK</code>, <code>CSazmeaH</code>, and <code>CSazmeaC</code> functions require as their first argument.</p>
<h2 id="azmuthal-equidistant-projection-csazmed">Azmuthal Equidistant Projection (Csazmed)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Azimuthal Equidistant Projection.</p>
<h3 id="csazmedf-forward-conversion">CSazmedF Forward conversion</h3>
<pre><code class="c">int CSazmedF (Const struct cs_Azmed_ *azmed, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Azmed_</code> structure via the <strong>azmed</strong> argument, <code>CSazmedF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSazmedF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csazmedi-inverse-conversion">CSazmedI Inverse conversion</h3>
<pre><code class="c">int CSazmedI (Const struct cs_Azmed_ *azmed, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Azmed_</code> structure via the <strong>azmed</strong> argument, <code>CSazmedI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSazmedI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csazmedk-grid-scale-k-normal">CSazmedK grid scale (K) normal</h3>
<pre><code class="c">double CSazmedK (Const struct cs_Azmed_ *azmed, Const doubl  ll[2]);
</code></pre>

<p><code>CSazmedK</code> returns the grid scale factor normal to the radial at the geodetic location specified by the <strong>ll</strong> argument. In the case of the ellipsoidal form of this projection, analytical formulas for this value have not been located and the result is arrived at using the <code>CS_llazdd</code> function.</p>
<h3 id="csazmedh-grid-scale-h-radial">CSazmedH grid scale (H) radial</h3>
<pre><code class="c">double CSazmedH (Const struct cs_Azmed_ *azmed, Const double ll[2]);
</code></pre>

<p><code>CSazmedH</code> returns the value 1.0; the scale at any point in the direction of a line emanating from the origin and passing through the any point of any coordinate system based on this projection. (This is what makes this projection an Equidistant Projection.)</p>
<h3 id="csazmedc-convergence-angle">CSazmedC convergence angle</h3>
<pre><code class="c">double CSazmedC (Const struct cs_Azmed_ *azmed, Const double ll[2]);
</code></pre>

<p><code>CSazmedC</code> returns the convergence angle in degrees east of north of the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at using the <code>CS_llazdd</code> function.</p>
<h3 id="csazmedq-definition-quality-check">CSazmedQ definition quality check</h3>
<pre><code class="c">int CSazmedQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);
</code></pre>

<p><code>CSazmedQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Azimuthal Equidistant Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSazmedQ</code> only examines those components specific to the Azimuthal Equidistant Projection. <code>CSazmedQ</code> returns in err_list an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSazmedQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csazmedl-latitudelongitude-check">CSazmedL Latitude/longitude check</h3>
<pre><code class="c">int CSazmedL (Const struct cs_Azmed_ *azmed, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSazmedL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>azmed</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSazmedsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSazmedL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csazmedx-xy-coordinate-check">CSazmedX Xy coordinate check</h3>
<pre><code class="c">int CSazmedX (Const struct cs_Azmed_ * azmed, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSazmedX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>azmed</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSazmedsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSazmedL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csazmeds-setup">CSazmedS Setup</h3>
<pre><code class="c">void CSazmedS(struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSazmedS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSazmedS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the first argument provided to <code>CSazmedS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_3">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. There are two variations to this projection:</p>
<ul>
<li>Lambert Azimuthal Equidistant (<code>cs_PRJCOD_AZMED</code>)</li>
<li>Lambert Azimuthal Equidistant, Elevated Ellipsoid (<code>cs_PRJCOD_AZEDE</code>)</li>
</ul>
<p>The following parameters are common to both variations:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="lambert-azimuthal-equidistant-projection">Lambert Azimuthal Equidistant Projection</h3>
<p>This is the traditional variation of the Lambert Azimuthal Equidistant projection. Note that it differs slightly from many other implementations in that it accepts a parameter value for the azimuth of the Y axis relative to true north. This provides support for local/company coordinate system. Even better local/company coordinate system support is provided by the Lambert Azimuthal Equidistant, Elevated Ellipsoid variation.</p>
<p>The parameter must be specified in degrees east of north. An azimuth west of north would be specified with a negative value.</p>
<p>The following parameters must be set:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>The azimuth, in degrees east of north, of the positive Y-axis of the coordinate system.</td>
</tr>
</tbody>
</table>
<p><em>Lambert Azimuthal Equidistant, Elevated Ellipsoid (cs_PRJCOD_AZEDE)</em></p>
<p>This variation of the Lambert Azimuthal Equidistant projection accepts an average elevation parameter which is added to the equatiorial radii of the ellipsoid. This better enbales CS-MAP to emulate a local/company coordinate system.</p>
<p>The parameter must be specified in system units. That is, if the coordinate system unit is, say, FEET; the average elevation must also be specified in feet.</p>
<p>The following parameters must be set;</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>The azimuth, in degrees east of north, of the positive Y-axis of the coordinate system.</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>The average elevation in the region of the system, expressed in coordinate system units.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_2">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the <strong>datum</strong> element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_azmed_-structure">cs_Azmed_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>azmed</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSazmedF</code>, <code>CSazmedI</code>, <code>CSazmedK</code>, <code>CSazmedH</code>, and <code>CSazmedC</code> functions require as their first argument.</p>
<h2 id="bonne-projection-projection-csbonne">Bonne Projection Projection (CSbonne)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Bonne Projection. Setting the standard parallel equal to the equator produces a Sinusoidal Projection. Setting the standard parallel to either pole produces the Werner Projection.</p>
<h3 id="csbonnef-forward-conversion">CSbonneF Forward conversion</h3>
<pre><code class="c">int CSbonneF (Const struct cs_Bonne_ *bonne, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Bonne_</code> structure via the <strong>bonne</strong> argument, <code>CSbonneF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSbonneF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csbonnei-inverse-conversion">CSbonneI Inverse conversion</h3>
<pre><code class="c">int CSbonneI (Const struct cs_Bonne_ *bonne, double ll[2],Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Bonne_</code> structure via the <strong>bonne</strong> argument, <code>CSbonneI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSbonneI</code> normally returns <code>cs_CNVRT_NRM</code>L. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csbonnek-parallel-scale-k">CSbonneK parallel scale (K)</h3>
<pre><code class="c">double CSbonneK (Const struct cs_Bonne_ *bonne, Const double ll[2]);
</code></pre>

<p><code>CSbonneK</code> returns the value 1.0 which is the grid scale factor, along any parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="csbonneh-meridian-scale-h">CSbonneH meridian scale (H)</h3>
<pre><code class="c">double CSbonneH (Const struct cs_Bonne_ *bonne, Const double ll[2]);
</code></pre>

<p><code>CSbonneK</code> returns the grid scale, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. Analytical formulas for this value have not been located and the result is arrived at using the <code>CS_llazdd</code> function.</p>
<h2 id="csbonnec-convergence-angle">CSbonneC Convergence angle</h2>
<pre><code class="c">double CSbonneC (Const struct cs_Bonne_ *bonne, Const double ll[2]);
</code></pre>

<p><code>CSbonneC</code> returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. Analytical formulas for this value have not been located and the result is arrived at using the <code>CS_llazdd</code> function.</p>
<h3 id="csbonneq-definition-quality-check">CSbonneQ definition quality check</h3>
<pre><code class="c">int CSbonneQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSbonneQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Boone Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSbonneQ</code> only examines those components specific to the Bonne Projection. <code>CSbonneQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSbonneQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csbonnel-latitudelongitude-check">CSbonneL Latitude/longitude check</h3>
<pre><code class="c">int CSbonneL (Const struct cs_Bonne_ *bonne, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSbonneL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>bonne</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSbonnesL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSbonneL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csbonnex-xy-coordinate-check">CSbonneX Xy coordinate check</h3>
<pre><code class="c">int CSbonneX (Const struct cs_Bonne_ *bonne, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSbonneX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>bonne</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSbonnesX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSbonneL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csbonnes-setup">CSbonneS Setup</h3>
<pre><code class="c">void CSbonneS (struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSbonneS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallel, the origin longitude, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSbonneS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CSbonneS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_4">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the Bonne Projection are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the central meridian of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the standard parallel of the projection.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>quad</td>
<td>an integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_3">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the <strong>datum</strong> element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_bonne_-structure">cs_Bonne_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>bonne</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSbonneF</code>, <code>CSbonneI</code>, <code>CSbonneK</code>, <code>CSbonneH</code>, and <code>CSbonneC</code> functions require as their first argument.</p>
<h2 id="bipolar-oblique-conformal-conic-projection-csbpcnc">Bipolar Oblique Conformal Conic Projection (CSbpcnc)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Bipolar Oblique Conformal Conic Projection. This projection was developed, by O. M. Miller (of Miller Cylindrical fame), specifically for mapping both the North American and South American continents on the same conformal map. This projection is supported for the sphere only. The equatorial radius of the referenced ellipsoid is used as the radius of the sphere.</p>
<h3 id="csbpcncf-forward-conversion">CSbpcncF Forward conversion</h3>
<pre><code class="c">int CSbpcncF (Const struct cs_Bpcnc_ *bpcnc, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Bpcnc_</code> structure via the <strong>bpcnc</strong> argument, <code>CSbpcncF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSbpcncF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csbpcnci-inverse-conversion">CSbpcncI Inverse conversion</h3>
<pre><code class="c">int CSbpcncI (Const struct cs_Bpcnc_ *bpcnc, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Bpcnc_</code> structure via the <strong>bpcnc</strong> argument, <code>CSbpcncI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSbpcncI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csbpcnck-parallel-scale-k">CSbpcncK parallel scale (K)</h3>
<pre><code class="c">double CSbpcncK ( Const struct cs_Bpcnc_ *bpcnc, Const double ll[2]);
</code></pre>

<p><code>CSbpcncK</code> returns the grid scale factor, as measured along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. Since this is a conformal projection, there is no H function as the scale along a meridian equals the scale along a parallel.</p>
<h3 id="csbpcncc-convergence-angle">CSbpcncC Convergence angle</h3>
<pre><code class="c">double CSbpcncC ( Const struct cs_Bpcnc_ *bpcnc, Const double ll[2]);
</code></pre>

<p><code>CSbpcncC</code> returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. At the current time, formulas that analytically define the convergence angle for this projection elude us. Thus, the convergence angle is determined empirically through the use of the <code>CS_llazdd</code> function.</p>
<h3 id="csbpcncq-definition-quality-check">CSbpcncQ definition quality check</h3>
<pre><code class="c">int CSbpcncQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSbpcncQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Bi-Polar Conformal Conic Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSbpcncQ</code> only examines those components specific to the Bi-Polar Conformal Conic Projection. <code>CSbpcncQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSbpcncQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csbpcncl-latitudelongitude-check">CSbpcncL Latitude/longitude check</h3>
<pre><code class="c">int CSbpcncL (Const struct cs_Bpcnc_ *bpcnc, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSbpcncL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>bpcnc</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSbpcncsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSbpcncL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csbpcncx-xy-coordinate-check">CSbpcncX Xy coordinate check</h3>
<pre><code class="c">int CSbpcncX ( Const struct cs_Bpcnc_ *bpcnc, int cnt , Const double pnts[][3]);
</code></pre>

<p><code>CSbpcncX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>bpcnc</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSbpcncsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSbpcncL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csbpcncs-setup">CSbpcncS Setup</h3>
<pre><code class="c">void CSbpcncS(struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSbpcncS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the poles, the standard parallels, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSbpcncS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CSbpcncS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_5">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. As far as we know, this projection is usually used only for the specific coordinate system for which it was invented. However, to remain consistent with the rest of CS-MAP, the following parameters can be specified. These parameters specify the location of the two poles upon which the projection is based. The first is always specified by latitude and longitude. The latitude of the second pole must always be specified. However, the longitude of the second pole can be specified either directly (<strong>prj_prm3</strong>) or as an angular distance from the first pole (<strong>prj_prm5</strong>). If <strong>prj_prm5</strong> is greater than zero, the second method is used. In the listing of parameters given below, the values used for the specific map for which this projection was developed are given. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the Bipolar Oblique Conformal Projection are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the first pole (usually the southwest). [- 110.0]</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the first pole. [-20.0]</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>Longitude, in degrees, of the second pole (usually the northeast). [-19.99333333333]</td>
</tr>
<tr>
<td>prj_prm4</td>
<td>Latitude, in degrees, of the second pole. [+45.0]</td>
</tr>
<tr>
<td>prj_prm5</td>
<td>If greater than zero, this value is considered to be the angular distance, in degrees, from the first pole to the second pole and the longitude of the second pole is computed as such. If this value is less than or equal to zero, the value provided in prj_prm3 is considered the longitude of the second pole. [+104.0]</td>
</tr>
<tr>
<td>prj_prm6</td>
<td>Angular distance, in degrees, from either pole to the first of two standard parallels. [+31.0]</td>
</tr>
<tr>
<td>prj_prm7</td>
<td>Angular distance, in degrees, from either pole to the second of two standard parallels. [+73.0]</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied. [1.0]</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. [0.0]</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates. [0.0]</td>
</tr>
<tr>
<td>quad</td>
<td>an integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_4">Datum Definition</h3>
<p>The value of equatorial radius is extracted from the datum element of the <code>cs_Csprm_</code> structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required element is:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The radius of the earth, as a sphere, in meters</td>
</tr>
</tbody>
</table>
<h3 id="cs_bpcnc_-structure">cs_Bpcnc_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>bpcnc</strong> element of the <code>prj_prm</code>s union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSbpcncF</code>, <code>CSbpcncI</code>, <code>CSbpcncK</code>, <code>CSbpcncH</code>, <code>CSbpcncC</code>, and <code>CSbpcncB</code> functions require as their first argument.</p>
<h2 id="cassini-projection-cscsini">Cassini Projection (CScsini)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Cassini Projection</p>
<h3 id="cscsinif-forward">CScsiniF Forward</h3>
<pre><code class="c">int CScsiniF (Const struct cs_Csini_ *csini, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Csini_</code> structure via the <strong>csini</strong> argument, <code>CScsiniI</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CScsiniF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="cscsinii-inverse">CScsiniI Inverse</h3>
<pre><code class="c">int CScsiniI (Const struct cs_Csini_ *csini, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Csini_</code> structure via the <strong>csini</strong> argument, <code>CScsiniI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CScsiniI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).
In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="cscsinik-parallel-scale-k">CScsiniK parallel scale (K)</h3>
<pre><code class="c">double CScsiniK (Const struct cs_Csini_ *csini, Const double ll[2]);
</code></pre>

<p><code>CScsiniK</code> returns the grid scale factor along a line normal to the central meridian of the coordinate system at the geographic location defined by the latitude and longitude provided in the <strong>ll</strong> array. It is a specific feature of this projection that this scale factor is unity.</p>
<h3 id="cscsinih-meridian-scale-h">CScsiniH meridian scale (H)</h3>
<pre><code class="c">double CScsiniH (Const struct cs_Csini_ *csini, Const double ll[2]);
</code></pre>

<p><code>CScsiniH</code> returns the grid scale factor along a line parallel to the central meridian of the coordinate system at the geographic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="cscsinic-convergence-angle">CScsiniC Convergence angle</h3>
<pre><code class="c">double CScsiniC (Const struct cs_Csini_ *csini, Const double ll[2]);
</code></pre>

<p><code>CScsiniC</code> returns the convergence angle, in degrees east of north, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. As analytical formulas for this quantity have not yet been located, the result is arrived at empirically using <code>CS_aslldd</code>.</p>
<h3 id="cscsiniq-definition-quality-check">CScsiniQ definition Quality check</h3>
<pre><code class="c">int CScsiniQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CScsiniQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Cassini Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CScsiniQ</code> only examines those components specific to the Cassini Projection. <code>CScsiniQ</code> returns in err_list an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CScsiniQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="cscsinil-latitudelongitude-check">CScsiniL Latitude/longitude check</h3>
<pre><code class="c">int CScsiniL (Const struct cs_Csini_ *csini, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CScsiniL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>csini</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CScsinisL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CScsiniL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="cscsinix-xy-coordinate-check">CScsiniX Xy coordinate check</h3>
<pre><code class="c">int CScsiniX (Const struct cs_Csini_ *csini, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CScsiniX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>csini</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CScsinisX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CScsiniL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="cscsinis-setup">CScsiniS Setup</h3>
<pre><code class="c">void CScsiniS (struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CScsiniS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian, the origin latitude, and other projection parameters are known, there are many calculations that need only be performed once. <code>CScsiniS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CScsiniS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_6">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the Cassini projection are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the central meridian.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>Scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units, and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>Quad</td>
<td>an integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_5">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the datum element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_csini_-structure">cs_Csini_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>csini</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CScsiniF</code>, <code>CScsiniI</code>, <code>CScsiniK</code>, <code>CScsiniH</code>, and <code>CScsiniC</code> functions require as their first argument.</p>
<h2 id="danish-system-34-cssys34">Danish System 34 (CSsys34)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Danish System 34 Projection. This projection is supported in ellipsoid form only; and most ordinary parameters are hard coded and selected via the 'region' (<strong>prj_prm1</strong>) parameter.</p>
<h3 id="cssys34c-convergence-angle">CSsys34C Convergence angle</h3>
<pre><code class="c">double CSsys34C ( Const struct cs_Sys34_ *sys34, Const double ll[2]);
</code></pre>

<p><code>CSsys34C</code> returns the convergence angle in degrees east of north of the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the <code>CS_azlld</code> function.</p>
<h3 id="cssys34f-forward-conversion">CSsys34F Forward conversion</h3>
<pre><code class="c">int CSsys34F (Const struct cs_Sys34_ *sys34, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Sys34_</code> structure via the <strong>sys34</strong> argument, <code>CSsys34F</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSsys34F</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="cssys34i-inverse-conversion">CSsys34I Inverse conversion</h3>
<pre><code class="c">int CSsys34I (Const struct cs_Sys34_ *sys34, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Sys34_</code> structure via the <strong>sys34</strong> argument, <code>CSsys34I</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSsys34I</code> normally returns <code>cs_CNVRT_NRM</code>L. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).
In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="cssys34k-parallel-scale-k">CSsys34K parallel scale (K)</h3>
<pre><code class="c">double CSsys34K (Const struct cs_Sys34_ *sys34, Const double ll[2]);
</code></pre>

<p><code>CSsys34K</code> returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of the <code>CS_llazdd</code> function.</p>
<h3 id="cssys34h-meridian-scale-h">CSsys34H meridian scale (H)</h3>
<pre><code class="c">double CSsys34H (Const struct cs_Sys34_ * ys34, Const double ll[2]);
</code></pre>

<p><code>CSsys34H</code> returns the grid scale factor along a meridian at the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of the <code>CS_llazdd</code> function.</p>
<h3 id="cssys34l-latitudelongitude-check">CSsys34L Latitude/longitude check</h3>
<pre><code class="c">int CSsys34L (Const struct cs_Sys34_ *sys34, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSsys34L</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>sys34</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSsys34sL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSsys34L</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="cssys34q-definition-quality-check">CSsys34Q definition quality check</h3>
<pre><code class="c">int CSsys34Q (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);
</code></pre>

<p><code>CSsys34Q</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Danish System 34 Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSsys34Q</code> only examines those components specific to the Danish System 34 Projection. <code>CSsys34Q</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSsys34Q</code> may be called with the NULL pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="cssys34x-xy-coordinate-check">CSsys34X Xy coordinate check</h3>
<pre><code class="c">int CSsys34X (Const struct cs_Sys34_ *sys34, int cnt , Const double pnts[][3]);
</code></pre>

<p><code>CSsys34X</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>sys34</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSsys34sX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSsys34L</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="cssys34s-setup-general">CSsys34S Setup (general)</h3>
<pre><code class="c">void CSsys34S (struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSsys34S</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the zone and other projection parameters are known, there are many calculations that need only be performed once. <code>CSsys34S</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the argument provided to <code>CSsys34S</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_7">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time.</p>
<p>The following parameters must be set:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Indicates which of the three regions is to apply 1.0 ==&gt; jylland; 2.0 ==&gt; sjlland, 3.0 ==&gt; bornholm.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_6">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the datum element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_sys34_-structure">cs_Sys34_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>sys34</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSsys344F</code>, <code>CSsys344I</code>, <code>CSsys344K</code>, <code>CSsys344H</code>, and <code>CSsys34C</code> functions require as their first argument.</p>
<h2 id="equidistant-conic-projection-csedcnc">Equidistant Conic Projection (CSedcnc)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Equidistant Conic Projection, also known as the Simple Conic Projection.</p>
<h3 id="csedcncf-forward-conversion">CSedcncF Forward conversion</h3>
<pre><code class="c">int CSedcncF (Const struct cs_Edcnc_ *edcnc, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Edcnc_</code> structure via the <strong>edcnc</strong> argument, <code>CSedcncF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSedcncF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csedcnci-inverse-conversion">CSedcncI Inverse conversion</h3>
<pre><code class="c">int CSedcncI (Const struct cs_Edcnc_ *edcnc, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Edcnc_</code> structure via the <strong>edcnc</strong> argument, <code>CSedcncI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSedcncI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).
In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csedcnck-parallel-scale-k">CSedcncK parallel scale (K)</h3>
<pre><code class="c">double CSedcncK (Const struct cs_Edcnc_ *edcnc, Const double ll[2]);
</code></pre>

<p><code>CSedcncK</code> returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="csedcnch-meridian-scale-h">CSedcncH meridian scale (H)</h3>
<pre><code class="c">double CSedcncH (Const struct cs_Edcnc_ *edcnc, Const double ll[2]);
</code></pre>

<p><code>CSedcncH</code> returns the value of 1.0 that represents the grid scale, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. That is, all distances measured along a meridian of this projection are true to scale, the essence of this projection.</p>
<h3 id="csedcncc-convergence-angle">CSedcncC Convergence angle</h3>
<pre><code class="c">double CSedcncC (Const struct cs_Edcnc_ *edcnc, Const double ll[2]);
</code></pre>

<p><code>CSedcncC</code> returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="csedcncq-definition-quality-check">CSedcncQ definition Quality check</h3>
<pre><code class="c">int CSedcncQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSedcncQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Equidistant Conic Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSedcncQ</code> only examines those components specific to the Equidistant Conic Projection. <code>CSedcncQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSedcncQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csedcncl-latitudelongitude-check">CSedcncL Latitude/longitude check</h3>
<pre><code class="c">int CSedcncL (Const struct cs_Edcnc_ *edcnc, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSedcncL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>edcnc</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSedcncsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSedcncL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csedcncx-xy-coordinate-check">CSedcncX Xy coordinate check</h3>
<pre><code class="c">int CSedcncX (Const struct cs_Edcnc_ *edcnc, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSedcncX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>edcnc</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSedcncsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSedcncL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csedcncs-setup">CSedcncS Setup</h3>
<pre><code class="c">void CSedcncS (struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSedcncS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallels, the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSedcncS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CSedcncS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_8">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the Equidistant Conic projection are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Latitude, in degrees, of the first standard parallel, usually the northernmost (it makes no difference).</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency (i.e. a single standard parallel).</td>
</tr>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_7">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the datum element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_edcnc_-structure">cs_Edcnc_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>edcnc</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSedcncF</code>, <code>CSedcncI</code>, <code>CSedcncK</code>, <code>CSedcncH</code>, and <code>CSedcncC</code> functions require as their first argument.</p>
<h2 id="equidistant-cylindrical-projection-csedcyl">Equidistant Cylindrical Projection (CSedcyl)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Equidistant Cylindrical Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere. This projection is also known as the Equirectangular or Rectangular projection. When the reference latitude of this projection is set to zero (i.e. the equator) the result is equivalent to what is known as the Plate Carree or Simple Cylindrical projection. When the reference latitude is set to 45? (north or south), a Gall Isographic projection results.</p>
<h3 id="csedcylf-forward-conversion">CSedcylF Forward conversion</h3>
<pre><code class="c">int CSedcylF (Const struct cs_Edcyl_ *edcyl,double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Edcyl_</code> structure via the <strong>edcyl</strong> argument, <code>CSedcylF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSedcylF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csedcyli-inverse-conversion">CSedcylI Inverse conversion</h3>
<pre><code class="c">int CSedcylI (Const struct cs_Edcyl_ *edcyl, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Edcyl_</code> structure via the <strong>edcyl</strong> argument, <code>CSedcylI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSedcylI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system.</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csedcylk-parallel-scale-k">CSedcylK parallel scale (K)</h3>
<pre><code class="c">double CSedcylK (Const struct cs_Edcyl_ *edcyl, Const double ll[2]);
</code></pre>

<p><code>CSedcylK</code> returns the grid scale factor along a parallel at the geodetic location specified by the <strong>ll</strong> argument.</p>
<h3 id="csedcylh-meridional-scale-h">CSedcylH meridional scale (H)</h3>
<pre><code class="c">double CSedcylH (Const struct cs_Edcyl_ *edcyl, Const double ll[2]);
</code></pre>

<p><code>CSedcylH</code> returns the grid scale factor along a meridian at the geodetic location specified by the <strong>ll</strong> argument.</p>
<h3 id="csedcylc-convergence-angle">CSedcylC Convergence angle</h3>
<pre><code class="c">double CSedcylC (Const struct cs_Edcyl_ *edcyl, Const double ll[2]);
</code></pre>

<p><code>CSedcylC</code> returns the convergence angle in degrees east of north of the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at using the <code>CS_azsphr</code> function.</p>
<h3 id="csedcylq-definition-quality-check">CSedcylQ definition Quality check</h3>
<pre><code class="c">int CSedcylQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSedcylQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Equidistant Cylindrical Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSedcylQ</code> only examines those components specific to the Equidistant Cylindrical Projection. <code>CSedcylQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSedcylQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csedcyll-latitudelongitude-check">CSedcylL Latitude/longitude check</h3>
<pre><code class="c">int CSedcylL (Const struct cs_Edcyl_ *edcyl, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSedcylL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>edcyl</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSedcylsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSedcylL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csedcylx-xy-coordinate-check">CSedcylX Xy coordinate check</h3>
<pre><code class="c">int CSedcylX (Const struct cs_Edcyl_ *edcyl, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSedcylX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>edcyl</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSedcylsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSedcylL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csedcyls-setup">CSedcylS Setup</h3>
<pre><code class="c">void CSedcylS(struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSedcylS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the reference parallel, origin longitude, and other projection parameters are known, there are many calculations which need only be performed once. <code>CSedcylS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the argument provided to <code>CSedcylS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_9">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The following parameters are used:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>The latitude, in degrees, of the reference parallel.</td>
</tr>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_8">Datum Definition</h3>
<p>The value of equatorial radius is extracted from the datum element of the <code>cs_Csprm_</code> structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required element is:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The radius of the earth, as a sphere, in meters.</td>
</tr>
</tbody>
</table>
<h3 id="cs_edcyl_-structure">cs_Edcyl_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>edcyl</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSedcylF</code>, <code>CSedcylI</code>, <code>CSedcylK</code>, <code>CsedcylH</code>, and <code>CSedcylC</code> functions require as their first argument.</p>
<h2 id="eckert-iv-projection-csekrt4">Eckert IV Projection (CSekrt4)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Eckert IV Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.</p>
<h3 id="csekrt4f-forward-conversion">CSekrt4F Forward conversion</h3>
<pre><code class="c">int CSekrt4F (Const struct cs_Ekrt4_ *ekrt4, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Ekrt4_</code> structure via the <strong>ekrt4</strong> argument, <code>CSekrt4F</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSekrt4F</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csekrt4i-inverse-conversion">CSekrt4I Inverse conversion</h3>
<pre><code class="c">int CSekrt4I (Const struct cs_Ekrt4_ *ekrt4, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Ekrt4_</code> structure via the <strong>ekrt4</strong> argument, <code>CSekrt4I</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSekrt4I</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csekrt4k-parallel-scale-k">CSekrt4K parallel scale (K)</h3>
<pre><code class="c">double CSekrt4K (Const struct cs_Ekrt4_ *ekrt4, Const double ll[2]);
</code></pre>

<p><code>CSekrt4K</code> returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.</p>
<h3 id="csekrt4h-meridian-scale-h">CSekrt4H meridian scale (H)</h3>
<pre><code class="c">double CSekrt4H (Const struct cs_Ekrt4_ *ekrt4, Const double ll[2]);
</code></pre>

<p><code>CSekrt4H</code> returns the grid scale factor along a meridian at the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.</p>
<h3 id="csekrt4c-convergence-angle">CSekrt4C Convergence angle</h3>
<pre><code class="c">double CSekrt4C (Const struct cs_Ekrt4_ *ekrt4, Const double ll[2]);
</code></pre>

<p><code>CSekrt4C</code> returns the convergence angle in degrees east of north of the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the <code>CS_azsphr</code> function.</p>
<h3 id="csekrt4q-definition-quality-check">CSekrt4Q definition quality check</h3>
<pre><code class="c">int CSekrt4Q (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);
</code></pre>

<p><code>CSekrt4Q</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Eckert IV Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSekrt4Q</code> only examines those components specific to the Eckert IV Projection. <code>CSekrt4Q</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSekrt4Q</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csekrt4l-latitudelongitude-check">CSekrt4L Latitude/longitude check</h3>
<pre><code class="c">int CSekrt4L (Const struct cs_Ekrt4_ *ekrt4, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSekrt4L</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>ekrt4</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSekrt4sL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSekrt4L</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csekrt4x-xy-coordinate-check">CSekrt4X Xy coordinate check</h3>
<pre><code class="c">int CSekrt4X ( Const struct cs_Ekrt4_ *ekrt4, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSekrt4X</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>ekrt4</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSekrt4sX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSekrt4L</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csekrt4s-setup-general">CSekrt4S Setup (general)</h3>
<pre><code class="c">void CSekrt4S( struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSekrt4S</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian and other projection parameters are known, there are many calculations that need only be performed once. <code>CSekrt4S</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the argument provided to <code>CSekrt4S</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_10">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The following parameters are used:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection (central meridian).</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_9">Datum Definition</h3>
<p>The value of equatorial radius is extracted from the datum element of the <code>cs_Csprm_</code> structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required element is:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The radius of the earth, as a sphere, in meters.</td>
</tr>
</tbody>
</table>
<h3 id="cs_ekrt4-structure">cs_Ekrt4 Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>ekrt4</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSekrt4F</code>, <code>CSekrt4I</code>, <code>CSekrt4K</code>, <code>CSekrt4H</code>, and <code>CSekrt4C</code> functions require as their first argument.</p>
<h2 id="eckert-vi-projection-csekrt6">Eckert VI Projection (CSekrt6)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Eckert VI Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.</p>
<h3 id="csekrt6f-forward-conversion">CSekrt6F forward conversion</h3>
<pre><code class="c">int CSekrt6F ( Const struct cs_Ekrt6_ *ekrt6, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Ekrt6_</code> structure via the <strong>ekrt6</strong> argument, <code>CSekrt6F</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSekrt6F</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csekrt6i-inverse-conversion">CSekrt6I Inverse conversion</h3>
<pre><code class="c">int CSekrt6I ( Const struct cs_Ekrt6_ *ekrt6, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Ekrt6_</code> structure via the <strong>ekrt6</strong> argument, <code>CSekrt6I</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSekrt6I</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csekrt6k-parallel-scale-k">CSekrt6K parallel scale (K)</h3>
<pre><code class="c">double CSekrt6K ( Const struct cs_Ekrt6_ *ekrt6, Const double ll[2]);
</code></pre>

<p><code>CSekrt6K</code> returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.</p>
<h3 id="csekrt6h-meridian-scale-h">CSekrt6H meridian scale (H)</h3>
<pre><code class="c">double CSekrt6H ( Const struct cs_Ekrt6_ *ekrt6, Const double ll[2]);
</code></pre>

<p><code>CSekrt6H</code> returns the grid scale factor along a meridian at the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.</p>
<h3 id="csekrt6c-convergence-angle">CSekrt6C Convergence angle</h3>
<pre><code class="c">double CSekrt6C ( Const struct cs_Ekrt6_ *ekrt6, Const double ll [2]);
</code></pre>

<p><code>CSekrt6C</code> returns the convergence angle in degrees east of north of the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the <code>CS_azsphr</code> function.</p>
<h3 id="csekrt6q-definition-quality-check">CSekrt6Q definition quality check</h3>
<pre><code class="c">int Csekrt6Q( Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);
</code></pre>

<p><code>CSekrt6Q</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Eckert VI Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates system (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSekrt6Q</code> only examines those components specific to the Eckert VI Projection. <code>CSekrt6Q</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSekrt6Q</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csekrt6l-latitudelongitude-check">CSekrt6L Latitude/longitude check</h3>
<pre><code class="c">int Csekrt6L (Const struct cs_Ekrt6_ *ekrt4, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSekrt6L</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>ekrt6</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSekrt6sL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSekrt6L</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csekrt6x-xy-coordinate-check">CSekrt6X Xy coordinate check</h3>
<pre><code class="c">int Csekrt6X (Const struct cs_Ekrt6_ *ekrt4, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSekrt6X</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>ekrt6</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSekrt6sX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSekrt6L</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csekrt6s-setup-general">CSekrt6S Setup (general)</h3>
<pre><code class="c">void CSekrt6S(struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSekrt6S</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central meridian and other projection parameters are known, there are many calculations which need only be performed once. <code>CSekrt6S</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the argument provided to <code>CSekrt6S</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_11">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The following parameters are used:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection (central meridian).</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_10">Datum definition</h3>
<p>The value of equatorial radius is extracted from the datum element of the <code>cs_Csprm_</code> structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required element is:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The radius of the earth, as a sphere, in meters.</td>
</tr>
</tbody>
</table>
<h3 id="cs_ekrt6_-structure">cs_Ekrt6_ structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>ekrt6</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSekrt6F</code>, <code>CSekrt6I</code>, <code>CSekrt6K</code>, <code>CSekrt6H</code>, and <code>CSekrt6C</code> functions require as their first argument.</p>
<h2 id="gnomonic-projection-csgnomc">Gnomonic Projection (CSgnomc)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Gnomonic Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.</p>
<p>The Gnomonic projection cannot process locations that are 90 degrees or more away from the projection origin. Coordinates that exceed this limit are adjusted to fall on the great circle that defines this limit.</p>
<h3 id="csgnomcf-forward-conversion">CsgnomcF Forward conversion</h3>
<pre><code class="c">int CSgnomcF ( Const struct cs_Gnomc_ *gnomc, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Gnomc_</code> structure via the <strong>gnomc</strong> argument, <code>CSgnomcF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSgnomcF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csgnomci-inverse-conversion">CsgnomcI inverse conversion</h3>
<pre><code class="c">int CSgnomcI (Const struct cs_Gnomc_ *gnomc, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Gnomc_</code> structure via the <strong>gnomc</strong> argument, <code>CSgnomcI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSgnomcI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csgnomck-grid-scale-k-normal-to-radial">CsgnomcK grid scale (K) normal to radial</h3>
<pre><code class="c">double CSgnomcK (Const struct cs_Gnomc_ *gnomc, Const double ll[2]);
</code></pre>

<p><code>CSgnomcK</code> returns the grid scale factor normal to the radial at the geodetic location specified by the <strong>ll</strong> argument.</p>
<h3 id="csgnomch-grid-scale-h-along-radial">CsgnomcH grid scale (H) along radial</h3>
<pre><code class="c">double CSgnomcH (Const struct cs_Gnomc_ *gnomc, Const double ll[2]);
</code></pre>

<p><code>CSgnomcH</code> returns the grid scale factor along a radial from the coordinate system origin to (and at) the geodetic location specified by the <strong>ll</strong> argument.</p>
<h3 id="csgnomcc-convergence-angle">CsgnomcC Convergence angle</h3>
<pre><code class="c">double CSgnomcC (Const struct cs_Gnomc_ * gnomc, Const double ll[2]);
</code></pre>

<p><code>CSgnomcC</code> returns the convergence angle in degrees east of north of the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the <code>CS_azsphr</code> function.</p>
<h3 id="csgnomcl-latitudelongitude-check">CsgnomcL Latitude/longitude check</h3>
<pre><code class="c">int CSgnomcL (Const struct cs_Gnomc_ * gnomc, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSgnomcL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>gnomc</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSgnomcsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSgnomcL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csgnomcq-definition-quality-check">CSgnomcQ definition quality check</h3>
<pre><code class="c">int CSgnomcQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSgnomcQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Gnomonic Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSgnomcQ</code> only examines those components specific to the Gnomonic Projection. <code>CSgnomcQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSgnomcQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csgnomcx-xy-coordinate-check">CsgnomcX Xy coordinate check`</h3>
<pre><code class="c">int CSgnomcX (Const struct cs_Gnomc_ * gnomc, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSgnomcX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the gnomc argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSgnomcsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSgnomcL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csgnomcs-setup">CSgnomcS Setup</h3>
<pre><code class="c">void CSgnomcS(struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSgnomcS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude and other projection parameters are known, there are many calculations that need only be performed once. <code>CSgnomcS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the argument provided to <code>CSgnomcS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_12">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The following parameters are used:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_11">Datum Definition</h3>
<p>The value of equatorial radius is extracted from the datum element of the <code>cs_Csprm_</code> structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required element is:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The radius of the earth, as a sphere, in meters.</td>
</tr>
</tbody>
</table>
<h3 id="cs_gnomc_-structure">cs_Gnomc_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>gnomc</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSgnomcF</code>, <code>CSgnomcI</code>, <code>CSgnomcK</code>, <code>CSgnomcH</code>, and <code>CSgnomcC</code> functions require as their first argument.</p>
<h2 id="goode-homolosine-projection-cshmlsn">Goode Homolosine Projection (CShmlsn)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Goode Homolosine Projection. This projection is supported in spherical form only. The equatorial radius of the supplied ellipsoid is used as the radius of the sphere.</p>
<h3 id="cshmlsnf-forward-conversion">CShmlsnF forward conversion</h3>
<pre><code class="c">int CShmlsnF (Const struct cs_Hmlsn_ *hmlsn, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Hmlsn_</code> structure via the <strong>hmlsn</strong> argument, <code>CShmlsnF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CShmlsnF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="cshmlsni-inverse-conversion">CShmlsnI Inverse conversion</h3>
<pre><code class="c">int CShmlsnI (Const struct cs_Hmlsn_ *hmlsn, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Hmlsn_</code> structure via the <strong>hmlsn</strong> argument, <code>CShmlsnI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CShmlsnI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="cshmlsnk-parallel-scale-k">CShmlsnK parallel scale (K)</h3>
<pre><code class="c">double CShmlsnK (Const struct cs_Hmlsn_ *hmlsn, Const double ll[2]);
</code></pre>

<p><code>CShmlsnK</code> returns the grid scale factor along a parallel of any coordinate system based on this projection at any location. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.</p>
<h3 id="cshmlsnh-meridian-scale-h">CShmlsnH meridian scale (H)</h3>
<pre><code class="c">double CShmlsnH (Const struct cs_Hmlsn_ *hmlsn, Const double ll[2]);
</code></pre>

<p><code>CShmlsnH</code> returns the grid scale factor along a meridian at the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at empirically the use of spherical trigonometry.</p>
<h3 id="cshmlsnc-convergence-angle">CShmlsnC Convergence angle</h3>
<pre><code class="c">double CShmlsnC (Const struct cs_Hmlsn_ *hmlsn, Const double ll[2]);
</code></pre>

<p><code>CShmlsnC</code> returns the convergence angle in degrees east of north of the geodetic location specified by the <strong>ll</strong> argument. Analytical formulas for this value have not been located and the result is arrived at through the use of the <code>CS_azsphr</code> function.</p>
<h3 id="cshmlsnq-definition-quality-check">CShmlsnQ definition quality check</h3>
<pre><code class="c">int CShmlsnQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);
</code></pre>

<p><code>CShmlsnQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Goode Homolosine Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CShmlsnQ</code> only examines those components specific to the Goode Homolosine Projection. <code>CShmlsnQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_lis</strong>t, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CShmlsnQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="cshmlsnl-latitudelongitude-check">CShmlsnL Latitude/longitude check</h3>
<pre><code class="c">int CShmlsnL (Const struct cs_Hmlsn_ *hmlsn, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CShmlsnL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>hmlsn</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CShmlsnsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CShmlsnL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="cshmlsnx-xy-coordinate-check">CShmlsnX Xy coordinate check</h3>
<pre><code class="c">int CShmlsnX (Const struct cs_Hmlsn_ *hmlsn, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CShmlsnX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>hmlsn</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CShmlsnsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CShmlsnL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="cshmlsns-setup-general">CShmlsnS Setup (general)</h3>
<pre><code class="c">void CShmlsnS (struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CShmlsnS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin longitude and other projection parameters are known, there are many calculations which need only be performed once. <code>CShmlsnS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the argument provided to <code>CShmlsnS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_13">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The following parameters are used:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection (central meridian).</td>
</tr>
<tr>
<td>prj_prm1-24</td>
<td>The interrupted form of the Goode Homolosine Projection is fully supported. cs_Csdef _ elements prj_prm1 thru prj_prm24 can be used to specify the extents of the different zones. See <code>CS_zones</code> for information on how to encode zones.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This is the X coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates. This is the Y coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_12">Datum Definition</h3>
<p>The value of equatorial radius is extracted from the datum element of the <code>cs_Csprm_</code> structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required element is:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The radius of the earth, as a sphere, in meters.</td>
</tr>
</tbody>
</table>
<h3 id="cs_hmlsn_-structure">cs_Hmlsn_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>hmlsn</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CShmlsnF</code>, <code>CShmlsnI</code>, <code>CShmlsnK</code>, <code>CShmlsnH</code>, and <code>CShmlsnC</code> functions require as their first argument.</p>
<h2 id="hotine-oblique-mercator-projection-csoblqm">Hotine Oblique Mercator Projection (CSoblqm)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Hotine Oblique Mercator Projection. Since this projection is conformal, the K and H scale factors are the same and there is no H function. Six variations of this projection are supported.</p>
<h3 id="csoblqmf-forward-conversion">CSoblqmF Forward conversion</h3>
<pre><code class="c">int CSoblqmF (Const struct cs_Oblqm_ *oblqm, double xy 2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Oblqm_</code> structure via the <strong>oblqm</strong> argument, <code>CSoblqmF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSoblqmF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csoblqmi-inverse-conversion">CSoblqmI Inverse conversion</h3>
<pre><code class="c">int CSoblqmI (Const struct cs_Oblqm_ *oblqm, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Oblqm_</code> structure via the <strong>oblqm</strong> argument, <code>CSoblqmI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSoblqmI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).
In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csoblqmk-scale-k">CSoblqmK scale (K)</h3>
<pre><code class="c">double CSoblqmK (Const struct cs_Oblqm_ *oblqm, Const double ll[2]);
</code></pre>

<p><code>CSoblqmK</code> returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. This is calculated using <code>CS_llazdd</code> as we have been unable to locate definitive formulas for the grid scale factor for this projection.</p>
<h3 id="csoblqmc-convergence-angle">CSoblqmC Convergence angle</h3>
<pre><code class="c">double CSoblqmC (Const struct cs_Oblqm_ *oblqm, Const double ll[2]);
</code></pre>

<p><code>CSoblqmC</code> returns the convergence angle is degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. This is calculated using <code>CS_llazdd</code> as we have been unable to locate definitive formulas for the convergence angle for this projection.</p>
<h3 id="csoblqmq-definition-quality-check">CSoblqmQ definition quality check</h3>
<pre><code class="c">int CSoblqmQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);
</code></pre>

<p><code>CSoblqmQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Oblique Mercator (Hotine) Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSoblqmQ</code> only examines those components specific to the Oblique Mercator (Hotine) Projection. <code>CSoblqmQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSoblqmQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csoblqml-latitudelongitude-check">CSoblqmL Latitude/longitude check</h3>
<pre><code class="c">int CSoblqmL (Const struct cs_Oblqm_ *oblqm, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSoblqmL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>oblqm</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSoblqmsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSoblqmL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csoblqmx-xy-coordinate-check">CSoblqmX Xy coordinate check</h3>
<pre><code class="c">int CSoblqmX (Const struct cs_Oblqm_ *oblqm, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSoblqmX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>oblqm</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSoblqmsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSoblqmL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csoblqms-setup">CSoblqmS Setup</h3>
<pre><code class="c">void CSoblqmS(struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSoblqmS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the central great circle, the origin latitude, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSoblqmS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by the <strong>csprm</strong> argument. Thus, this one argument provides <code>CSoblqmS</code> its input data and the repository for the results as described below.</p>
<p><code>CSoblqmS</code> examines the <code>prj_code</code> element of the <code>cs_Csprm_</code> structure to determine which of the six variations of this projection is to be setup. In most cases, the variations require different usage of the parameters in the <code>cs_Csdef_</code> structure as defined below.</p>
<h3 id="coordinate-system-definition_14">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csldef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the Oblique Mercator projection are dependent upon the variation being implemented.</p>
<p>The following parameters apply to all six variations of the projection:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>scl_red</td>
<td>The scale reduction that is to be applied.</td>
</tr>
<tr>
<td>Scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>Quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="single-point-unrectified-hotine-oblique-mercator-cs_prjcod_hom1uv">Single Point, Unrectified Hotine Oblique Mercator (cs_PRJCOD_HOM1UV)</h3>
<p>This variation produces unrectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the "aposphere". Rarely, if ever used; retained primarily for historical purposes.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the central point of the projection.</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the central point of the projection.</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>The azimuth of the central great circle, in degrees east of north.</td>
</tr>
</tbody>
</table>
<h3 id="two-point-unrectified-hotine-oblique-mercator-cs_prjcod_hom2uv">Two Point, Unrectified Hotine Oblique Mercator (cs_PRJCOD_HOM2UV)</h3>
<p>This variation produces unrectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the "aposphere." Rarely, if ever used; retained primarily for historical purposes.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the first point on the central geodesic.</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the first point on the central geodesic.</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>Longitude, in degrees, of the second point on the central geodesic.</td>
</tr>
<tr>
<td>prj_prm4</td>
<td>Latitude, in degrees, of the second point on the central geodesic.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the center of the coordinate system being defined. That is, the point on the central geodesic that has this latitude is the natural origin of the projection.</td>
</tr>
</tbody>
</table>
<h3 id="alaska-variation-hotine-oblique-mercator-cs_prjcod_hom1xy">Alaska Variation, Hotine Oblique Mercator (cs_PRJCOD_HOM1XY)</h3>
<p>This variation produces rectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the "aposphere". The rectification technique is specific to Zone 1 of the Alaska State Plane Coordinate System. It is possible that this variation should also be used for the Great Lakes Survey, but this has not been verified as of this writing.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the central point of the projection.</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the central point of the projection.</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>The azimuth of the central great circle, in degrees east of north.</td>
</tr>
</tbody>
</table>
<h3 id="two-point-rectified-hotine-oblique-mercator-cs_prjcod_hom2xy">Two Point, Rectified Hotine Oblique Mercator (cs_PRJCOD_HOM2XY)</h3>
<p>This variation produces rectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the "aposphere". Rarely, if ever used; retained primarily for historical purposes. To remain consistent with prior releases of CS-MAP, this variation uses the same rectification technique as the Alaska variation described immediately above.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the first point on the central geodesic.</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the first point on the central geodesic.</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>Longitude, in degrees, of the second point on the central geodesic.</td>
</tr>
<tr>
<td>prj_prm4</td>
<td>Latitude, in degrees, of the second point on the central geodesic.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the center of the coordinate system being defined. That is, the point on the central geodesic that has this latitude is the natural origin of the projection.</td>
</tr>
</tbody>
</table>
<h3 id="rectified-skew-orthomorphic-cs_prjcod_rskew">Rectified Skew Orthomorphic (cs_PRJCOD_RSKEW)</h3>
<p>This variation produces rectified cartesian coordinates whose origin is the intersection of the central geodesic and the equator of the "aposphere". The rectification technique is that commonly used in places other than Alaska.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the central point of the projection.</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the central point of the projection.</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>The azimuth of the central great circle, in degrees east of north.</td>
</tr>
</tbody>
</table>
<h3 id="rectified-skew-orthomorphic-centered-cs_prjcod_rskewc">Rectified Skew Orthomorphic Centered (cs_PRJCOD_RSKEWC)</h3>
<p>This variation produces rectified cartesian coordinates, the origin of which is at the single defining point. The rectification technique is that commonly used in places other than Alaska.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the central point of the projection.</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the central point of the projection.</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>The azimuth of the central great circle, in degrees east of north.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_13">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the datum element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_oblqm_-structure">cs_Oblqm_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>oblqm</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSoblqmF</code>, <code>CSoblqmI</code>, <code>CSoblqmK</code>, and <code>CSoblqmC</code> functions require as their first argument.</p>
<h2 id="krovak-oblique-conformal-conic">Krovak Oblique Conformal Conic</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Krovak Oblique Conformal Conic Projection. This projection is used in what used to be Czechoslovokia, and is now the Czech Republic and the Slovak Republic. Since this projection is conformal, the K and H scale factors are the same and there is no H function. Two variations of this projection are supported.</p>
<p>The first variation is the traditional projection as used since the 1920's. The second includes the affine transformation devised for use with the 1995 adjustment.</p>
<p>Please note that traditional Krovak X coordinates increase to the west. When such coordinates are used in the traditional CAD environment, the resulting images are mirrored and are (for most folks anyway) useless. Therefore, this implementation is such that what would normally be positive X coordinates are actually negative coordinates, and the magnitude of the values will be correct. In this way, the absolute value of the coordinate will be what is expected to see, but the coordinates will actually increase to the east, thus making AutoCAD, MicroStation, and other CAD type systems happy campers.</p>
<h3 id="cskrovkf-forward-conversion">CSkrovkF Forward Conversion</h3>
<pre><code class="c">int CSkrovkF (Const struct cs_Krovk_ *krovk, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Krovk_</code> structure via the <strong>krovk</strong> argument, <code>CSkrovkF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSkrovkF</code> normally returns <code>cs_CNVRT_NRM</code>L. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<p>The <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="cskrovki-inverse-conversion">CSkrovkI Inverse conversion</h3>
<pre><code class="c">int CSkrovkI (Const struct cs_Krovk_ *krovk, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Krovk_</code> structure via the <strong>krovk</strong> argument, <code>CSkrovkI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSkrovkI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the xy value is not within the domain of the coordinate system.</p>
<p>The <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are the first elements in these arrays, the Y coordinate and the latitude are the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="cskrovkk-scale-k">CSkrovkK scale (K)</h3>
<pre><code class="c">double CSkrovkK (Const struct cs_Krovk_ *krovk, Const double ll[2]);
</code></pre>

<p><code>CSkrovkK</code> returns the grid scale factor of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. The value <code>cs_SclInf</code> (defined to be 9,999.00 is CSdata.c) is returned if the <strong>ll</strong> provided is the oblique pole.</p>
<h3 id="cskrovkc-convergence-angle">CSkrovkC Convergence angle</h3>
<pre><code class="c">double CSkrovkC (Const struct cs_Krovk_ *krovk, Const double ll[2]);
</code></pre>

<p><code>CSkrovkC</code> returns the convergence angle in degrees east of north of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="cskrovkq-definition-quality-check">CSkrovkQ definition quality check</h3>
<pre><code class="c">int CSkrovkQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list [], int list_sz);
</code></pre>

<p><code>CSkrovkQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Krovak Oblique Conformal Conic Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSkrovakQ</code> only examines those components specific to the Krovak Oblique Conformal Conic Projection. <code>CSkrovkQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSkrovkQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="bugs">Bugs</h3>
<p>In the original implementation of this projection, all parameters were hard coded and no checking was necessary. For release 10, this projection was rewritten to accept user defined parameters, but this quality check function was never updated. Therefore, at the current time, there is no parameter checking performed for this projection.</p>
<h3 id="cskrovkl-latitudelongitude-check">CSkrovkL Latitude/longitude check</h3>
<pre><code class="c">int CSoblqmL (Const struct cs_Oblqm_ *oblqm, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSoblqmL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>oblqm</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSoblqmsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSoblqmL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="cskrovkx-xy-coordinate-check">CSkrovkX Xy coordinate check</h3>
<pre><code class="c">int CSoblqmX (Const struct cs_Oblqm_ *oblqm,int cnt,Const double pnts [ ] [ 3] ) ;
</code></pre>

<p>At the current time, <code>CSoblqmX</code> returns <code>cs_CNVRT_OK</code> without performing any checks. The arguments are currently ignored. Again, this is due to the unusual legacy of this projection, and the fact that normal coordinates used in the Czech Repulic increase to the west rather than the east.</p>
<h3 id="cskrovks-setup">CSkrovkS Setup</h3>
<pre><code class="c">void CSkrovkS (struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSkrovkS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin longitude, origin latitude, oblique pole location, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSkrovkS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by the <strong>csprm</strong> argument. Thus, this one argument provides <code>CSkrovkS</code> its input data and the repository for the results as described below.</p>
<p><code>CSkrovkS</code> examines the <strong>prj_code</strong> element of the <code>cs_Csprm_</code> structure to determine which of the two variations of this projection is to be setup. The projection code, therefore, simply determines if the 1995 adjustment transformation is applied to the resulting cartesian coordinates. The parameters for the affine tranformation are (currently) hard coded.</p>
<h3 id="coordinate-system-definition_15">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csldef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the Krovak Oblique Conformal Conic Projection are dependent upon the variation being implemented.</p>
<p>The following parameters apply to both variations of the projection:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>org_lng</td>
<td>Longitude, in degrees, of the origin of the projection. As is commonly used in the Czech Repoublic, this is usually the prime meridian of Ferro.</td>
</tr>
<tr>
<td>org_lat</td>
<td>Latitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the location of the pole of the oblique cone.</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the location of the pole of the oblique cone.</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>Latitude, in degrees on the oblique gaussian surface, of the single standard parallel of the conic projection surface.</td>
</tr>
<tr>
<td>scl_red</td>
<td>The scale reduction that is to be applied.</td>
</tr>
<tr>
<td>Scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>Quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="krovak-oblique-conformal-conic-czechoslovokia-cs_prjcod_">Krovak Oblique Conformal Conic, Czechoslovokia (cs_PRJCOD_)</h3>
<p>This variation produces the traditional (i.e. unadjusted) Krovak coordinates used in Czechoslovakia since the 1920's. There are no special parameter requirements. Specifying this variation simply turns off the application of the 1995 adjustment.</p>
<h3 id="krovak-oblique-conformal-conic95-adjustment">Krovak Oblique Conformal Conic/95 Adjustment</h3>
<p>This variation causes an affine transformation to be applied to the traditional coordinates, thus producing coordinates appropriate for the 1995 adjustment. There are no special parameter requirements (at this time). Specifying this variation simply turns on the affine transformation, the coefficients of which are hard coded.</p>
<h3 id="datum-definition_14">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the datum element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_krovk_-structure">cs_Krovk_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>oblqm</strong>* element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSkrovkF</code>, <code>CSkrovkI</code>, <code>CSkrovkK</code>, and <code>CSkrovkC</code> functions require as their first argument.</p>
<h2 id="lambert-conformal-conic-projection-cslmbrt">Lambert Conformal Conic Projection (CSlmbrt)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Lambert Conformal Conic Projection. Since this projection is a conformal projection, the K and H scale factors are the same and there is no H function. Five variations of this projection are supported.</p>
<h3 id="cslmbrtf-forward-conversion">CSlmbrtF Forward conversion</h3>
<pre><code class="c">int CSlmbrtF (Const struct cs_Lmbrt_ *lmbrt, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Lmbrt_</code> structure via the <strong>lmbrt</strong> argument, <code>CSlmbrtF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSlmbrtF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="cslmbrti-inverse-conversion">CSlmbrtI Inverse conversion</h3>
<pre><code class="c">int CSlmbrtI (Const struct cs_Lmbrt_ *lmbrt, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Lmbrt_</code> structure via the <strong>lmbrt</strong> argument, <code>CSlmbrtI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSlmbrtI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="cslmbrtk-scale-k">CSlmbrtK scale (K)</h3>
<pre><code class="c">double CSlmbrtK (Const struct cs_Lmbrt_ *lmbrt, Const double ll[2]);
````

`CSlmbrtK` returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the **ll** array.

### CSlmbrtC convergence angle

```c
double CSlmbrtC (Const struct cs_Lmbrt_ *lmbrt, Const double ll[2]);
</code></pre>

<p><code>CSlmbrtC</code> returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="cslmbrtq-definition-quality-check">CSlmbrtQ definition quality check</h3>
<pre><code class="c">int CSlmbrtQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSlmbrtQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Lambert Conformal Conic Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSlmbrtQ</code> only examines those components specific to the Lambert Conformal Conic Projection. <code>CSlmbrtQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSlmbrtQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="cslmbrtl-latitudelongitude-check">CSlmbrtL Latitude/longitude check</h3>
<pre><code class="c">int CSlmbrtL (Const struct cs_Lmbrt_ *lmbrt, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSlmbrtL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>lmbrt</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSlmbrtsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSlmbrtL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="cslmbrtx-xy-coordinate-check">CSlmbrtX Xy coordinate check</h3>
<pre><code class="c">int CSlmbrtX (Const struct cs_Lmbrt_ *lmbrt, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSlmbrtX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>lmbrt</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSlmbrtsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSlmbrtL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="cslmbrts-setup">CSlmbrtS setup</h3>
<pre><code class="c">void CSlmbrtS (struct cs_Csprm_*csprm);
</code></pre>

<p>The <code>CSlmbrtS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallels, the origin latitude and longitude, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSlmbrtS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CSlmbrtS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_16">Coordinate system definition</h3>
<p>The definition of the coordinate system is extracted from the csdef element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time.</p>
<p>Five variations of this projection are supported. <code>CSlmbrtS</code> determines which variation is to be setup by examining the <code>prj_code</code> element of the <code>cs_Csprm_</code> structure. The actual use of parameters in the <code>cs_Csdef_</code> structure (an element of the <code>cs_Csprm_</code> structure) is dependent on the variation being setup.</p>
<p>The following elements of the <code>cs_Csdef_</code> structure apply to all five variations:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<p>Parameter use specific to the five variations is:</p>
<h3 id="two-standard-parallels-cs_prjcod_lmbrt">Two Standard Parallels (cs_PRJCOD_LMBRT)</h3>
<p>This is the traditional version of this projection. The degree of scale reduction to reduce and distribute scale distortion is specified by two standard parallels:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Latitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.</td>
</tr>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
</tbody>
</table>
<h3 id="single-standard-parallel-cs_prjcod_lm1sp">Single Standard Parallel (cs_PRJCOD_LM1SP)</h3>
<p>This variation is commonly used outside of North America. It is, mathematically, virtually identical to what CS-MAP has long referred to as the Lambert Tangential. The degree of scale reduction to reduce and distribute scale distortion is specified by the scale reduction factor:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>scl_red</td>
<td>The scale of the projection at the origin defined by org_lng and org_lat.</td>
</tr>
</tbody>
</table>
<h3 id="belgian-variation-cs_prjcod_lmblgn">Belgian Variation (cs_PRJCOD_LMBLGN)</h3>
<p>This is a minor variation to the traditional Two Standard Parallel version of the projection. This variation will produce the results required by some Belgian coordinate systems:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Latitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.</td>
</tr>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
</tbody>
</table>
<h3 id="wisconsin-variation-cs_prjcod_wccsl">Wisconsin Variation (cs_PRJCOD_WCCSL)</h3>
<p>This is a minor variation to the traditional Two Standard Parallel version of the projection. This variation supports the Wisconsin County Coordinate System group of coordinate systems. This variation uses a parallel ellipsoid technique to adjust horizontal coordinates for average elevation of the region being mapped:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Latitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as prj_prm1, to obtain a conic with a single point of tangency.</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>Average geoid separation, <strong>in meters</strong>, of the region being mapped.</td>
</tr>
<tr>
<td>prj_prm4</td>
<td>Average elevation above the geoid (i.e. orthometric height), <strong>in system units</strong>, of the region being mapped.</td>
</tr>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
</tbody>
</table>
<h3 id="minnesota-variation-cs_prjcod_mndotl">Minnesota Variation (cs_PRJCOD_MNDOTL)</h3>
<p>This is a minor variation to the traditional Two Standard Parallel version of the projection. This variation supports the county coordinate systems developed by the Minnesota Department of Transportation. This variation uses a parallel ellipsoid technique (different from that used in Wisconsin, of course) to adjust horizontal coordinates for average elevation of the region being mapped:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Latitude, in degrees, of the first standard parallel, usually the northernmost. For this projection, there is no distinction between the northern and southern standard parallels (i.e. they can be switched with no affect).</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the second standard parallel, usually the southernmost. This is, rarely, the same as <strong>prj_prm1</strong>, to obtain a conic with a single point of tangency.</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>Average height above the ellipsoid, **in system units</td>
</tr>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_15">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the <strong>datum</strong> element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_lmbrt_-structure">cs_Lmbrt_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>lmbrt</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSlmbrtF</code>, <code>CSlmbrtI</code>, <code>CSlmbrtK</code>, and <code>CSlmbrtC</code> functions require as their first argument.</p>
<h2 id="lambert-tangential-projection-cslmtan">Lambert Tangential Projection (CSlmtan)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Lambert Tangential Projection as used by the National Geographic Institute of France. Please note that the current implementation of this projection does not support the spherical form of the projection. With the addition of the single standard parallel variation of the Lambert Conformal Conic, these functions are now redundant; and will be removed in a future release.</p>
<h2 id="cslmtanf-forward-conversion">CSlmtanF Forward conversion</h2>
<pre><code class="c">int CSlmtanF (Const struct cs_Lmtan_ *lmtan, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Lmtan_</code> structure via the <strong>lmtan</strong> argument, <code>CSlmtanF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSlmtanF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h2 id="cslmtani-inverse-conversion">CSlmtanI Inverse conversion</h2>
<pre><code class="c">int CSlmtanI (Const struct cs_Lmtan_ *lmtan, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Lmtan_</code> structure via the <strong>lmtan</strong> argument, <code>CSlmtanI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSlmtanI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="cslmtank-parallel-scale-k">CSlmtanK parallel scale (K)</h3>
<pre><code class="c">double CSlmtanK (Const struct cs_Lmtan_ *lmtan, Const double ll[2]);
</code></pre>

<p><code>CSlmtanK</code> returns the grid scale factor, along a parallel, of the coordinate system at the geodetic location given by the <strong>ll</strong> argument. Formulas for this calculation have not been located, therefore the result is obtained using the <code>CS_llazdd</code> function.</p>
<h3 id="cslmtanh-meridian-scale-h">CSlmtanH meridian scale (H)</h3>
<pre><code class="c">double CSlmtanH (Const struct cs_Lmtan_ *lmtan, Const double ll[2]);
</code></pre>

<p><code>CSlmtanH</code> returns the grid scale factor, along a meridian, of the coordinate system at the geodetic location given by the <strong>ll</strong> argument. Formulas for this calculation have not been located, therefore the result is obtained from the use of the <code>CS_llazdd</code> function.</p>
<h3 id="cslmtanc-convergence-angle">CSlmtanC Convergence angle</h3>
<pre><code class="c">double CSlmtanC (Const struct cs_Lmtan_ *lmtan, Const double ll[2]);
</code></pre>

<p><code>CSlmtanC</code> returns the convergence angle in degrees east of north of the coordinate system at the geodetic location given by the <strong>ll</strong> argument. Formulas for this calculation have not been located, therefore the result is obtained using the <code>CS_llazdd</code> function.</p>
<h3 id="cslmtanl-latitudelongitude-check">CSlmtanL Latitude/longitude check</h3>
<pre><code class="c">int CSlmtanL (Const struct cs_Lmtan_ *lmtan, int cnt, Const double pnts [][3]);
</code></pre>

<p><code>CSlmtanL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>lmtan</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSlmtansL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSlmtanL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="cslmtanq-definition-quality-check">CSlmtanQ definition quality check</h3>
<pre><code class="c">int CSlmtanQ(Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSlmtanQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Lambert Tangential Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSlmtanQ</code> only examines those components specific to the Lambert Tangential Projection. <code>CSlmtanQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSlmtanQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="cslmtanx-xy-coordinate-check">CSlmtanX Xy coordinate check</h3>
<pre><code class="c">int CSlmtanX (Const struct cs_Lmtan_ *lmtan, int cnt, Const double pnts [][3]);
</code></pre>

<p><code>CSlmtanX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnt</strong>s and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>lmtan</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSlmtansX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSlmtanL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="cslmtans-setup">CSlmtanS setup</h3>
<pre><code class="c">void CSlmtanS (struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSlmtanS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin latitude and longitude, the scale reduction factor, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSlmtanS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CSlmtanS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_17">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the Lambert Tangential projection are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>org_lng</td>
<td>The longitude, in degrees, of the origin of the projection relative to Greenwich.</td>
</tr>
<tr>
<td>org_lat</td>
<td>The latitude, in degrees, of the origin of the projection relative to the equator.</td>
</tr>
<tr>
<td>scl_red</td>
<td>The scale reduction factor that is to be applied to the projection.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size. This value is the X coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates. This value is the Y coordinate of the coordinate system origin.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_16">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the datum element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_lmtan_-structure">cs_Lmtan_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>lmtan</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSlmtanF</code>, <code>CSlmtanI</code>, <code>CSlmtanK</code>, <code>CSlmtanH</code>, and <code>CSlmtanC</code> functions require as their first argument.</p>
<h2 id="mercator-projection-csmrcat">Mercator Projection (CSmrcat)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Mercator Projection. Since this projection is conformal, the K and H grid scales are the same and there is no H function.</p>
<h3 id="csmrcatf-forward-conversion">CSmrcatF Forward conversion</h3>
<pre><code class="c">int CSmrcatF (Const struct cs_Mrcat_ *mrcat, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Mrcat_</code> structure via the <strong>mrcat</strong> argument, <code>CSmrcatF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSmrcatF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csmrcati-inverse-conversion">CSmrcatI Inverse conversion</h3>
<pre><code class="c">int CSmrcatI (Const struct cs_Mrcat_ *mrcat, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Mrcat_</code> structure via the mrcat argument, <code>CSmrcatI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSmrcatI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the xy value is not within the domain of the coordinate system.</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csmrcatk-scale-k-along-a-parallel">CSmrcatK scale (K) along a parallel</h3>
<pre><code class="c">double CSmrcatK (Const struct cs_Mrcat_ *mrcat, Const double ll[2]);
</code></pre>

<p><code>CSmrcatK</code> returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="csmrcatc-convergence-angle">CSmrcatC Convergence angle</h3>
<pre><code class="c">double CSmrcatC (Const struct cs_Mrcat_ *mrcat, Const double ll[2]);
</code></pre>

<p><code>CSmrcatC</code> returns the value 0.0 which represents the convergence in degrees east of north of nay coordinate system based on this projection at any latitude and longitude.</p>
<h3 id="csmrcatq-definition-quality-check">CSmrcatQ definition Quality check</h3>
<pre><code class="c">int CSmrcatQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSmrcatQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Mercator Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSmrcatQ</code> only examines those components specific to the Mercator Projection. <code>CSmrcatQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSmrcatQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csmrcatl-latitudelongitude-check">CSmrcatL Latitude/longitude check</h3>
<pre><code class="c">int CSmrcatL (Const struct cs_Mrcat_ *mrcat, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSmrcatL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>mrcat</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSmrcatsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSmrcatL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csmrcatx-xy-coordinate-check">CSmrcatX Xy coordinate check</h3>
<pre><code class="c">int CSmrcatX (Const struct cs_Mrcat_ *mrcat, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSmrcatX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>mrcat</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSmrcatsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSmrcatL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csmrcats-setup">CSmrcatS setup</h3>
<pre><code class="c">void CSmrcatS (struct cs_Csprm_*csprm);
</code></pre>

<p>The <code>CSmrcatS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard parallel, the origin longitude, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSmrcatS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CSmrcatS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_18">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure which must be initialized for the Mercator Projection are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the central meridian of the coordinate system (or map).</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Latitude, in degrees, of the standard parallel, usually zero indicating the equator. Using a non-zero value has an affect similar to that of the scale reduction factor of other cylindrical projections.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_17">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the datum element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_mrcat_-structure">cs_Mrcat_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>mrcat</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSmrcatF</code>, <code>CSmrcatI</code>, <code>CSmrcatK</code>, and <code>CSmrcatC</code> functions require as their first argument.</p>
<h2 id="miller-projection-csmillr">Miller Projection (CSmillr)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Miller Projection. This projection is only used in the spherical form. Thus, all functions assume a sphere with a radius equal to the equatorial radius of the ellipsoid provided.</p>
<h3 id="csmillrf-forward-conversion">CSmillrF Forward conversion</h3>
<pre><code class="c">int CSmillrF (Const struct cs_Millr_ *millr, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Millr_</code> structure via the <strong>millr</strong> argument, <code>CSmillrF</code> will convert the latitude and longitude provided in the <strong>ll</strong> array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSmillrF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csmillri-inverse-conversion">CSmillrI Inverse conversion</h3>
<pre><code class="c">int CSmillrI (Const struct cs_Millr_ *millr, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Millr_</code> structure via the <strong>millr</strong> argument, <code>CSmillrI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSmillrI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the <strong>xy</strong> value is not within the domain of the coordinate system.</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csmillrk-scale-k-along-a-parallel">CSmillrK scale (K) along a parallel</h3>
<pre><code class="c">double CSmillrK (Const struct cs_Millr_ *millr, Const double ll[2]);
</code></pre>

<p><code>CSmillrK</code> returns the grid scale factor, along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="csmillrh-scale-h-along-a-meridian">CSmillrH scale (H) along a meridian</h3>
<pre><code class="c">double CSmillrH (Const struct cs_Millr_ *millr, Const double ll[2]);
</code></pre>

<p><code>CSmillrH</code> returns the grid scale factor, along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array.</p>
<h3 id="csmillrc-convergence-angle">CSmillrC Convergence angle</h3>
<pre><code class="c">double CSmillrC (Const struct cs_Millr_ *millr, Const double ll[2]);
</code></pre>

<p><code>CSmillrC</code> returns the value 0.0 which represents the convergence angle in degrees east of north of any coordinate system based on this projection at any latitude and longitude.</p>
<h3 id="csmillrl-latitudelongitude-check">CSmillrL Latitude/longitude check</h3>
<pre><code class="c">int CSmillrL (Const struct cs_Millr_ *millr, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSmillrL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>millr</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSmillrsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSmillrL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csmillrq-definition-quality-check">CSmillrQ definition Quality check</h3>
<pre><code class="c">int CSmillrQ (Const struct cs_Csdef_ *csdef, unsigned short prj_code, int *err_list[], int list_sz);
</code></pre>

<p><code>CSmillrQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Miller Cylindrical Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSmillrQ</code> only examines those components specific to the Miller Cylindrical Projection. <code>CSmillrQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSmillrQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csmillrx-xy-coordinate-check">CSmillrX Xy coordinate check</h3>
<pre><code class="c">int CSmillrX (Const struct cs_Millr_ *millr, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSmillrX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>millr</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSmillrsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSmillrL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csmillrs-setup">CSmillrS setup</h3>
<pre><code class="c">void CSmillrS (struct cs_Csprm_*csprm);
</code></pre>

<p>The <code>CSmillrS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the origin longitude and other projection parameters are known, there are many calculations that need only be performed once. <code>CSmillrS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CSmillrS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_19">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the Miller Projection are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the central meridian of the coordinate system (or map).</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>quad</td>
<td>an integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<h3 id="datum-definition_18">Datum Definition</h3>
<p>The value of equatorial radius is extracted from the datum element of the <code>cs_Csprm_</code> structure and used as the radius of the sphere. This is normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required element is:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The radius of the earth, as a sphere, in meters.</td>
</tr>
</tbody>
</table>
<h3 id="cs_millr_-structure">cs_Millr_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>millr</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSmillrF</code>, <code>CSmillrI</code>, <code>CSmillrK</code>, <code>CSmillrH</code>, and <code>CSmillrC</code> functions require as their first argument.</p>
<h2 id="modified-polyconic-projection-csmodpc">Modified Polyconic Projection (CSmodpc)</h2>
<p>This set of functions represent the Coordinate System Mapping Package's knowledge of the Modified Polyconic Projection. That is, the projection developed by Lallemand of France and adopted by the International Map Committee (IMC) in London as the basis for the 1:1,000,000 scale International Map of the World (IMW) series in 1909.</p>
<h3 id="csmodpcf-forward-conversion">CSmodpcF Forward conversion</h3>
<pre><code class="c">int CSmodpcF (Const struct cs_Modpc_ *modpc, double xy[2], Const double ll[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Modpc_</code> structure via the <strong>modpc</strong> argument, <code>CSmodpcF</code> will convert the latitude and longitude provided in the a array to X and Y coordinates, returning the result in the <strong>xy</strong> array. <code>CSmodpcF</code> normally returns <code>cs_CNVRT_NRML</code>. If <strong>ll</strong> is not within the domain of the coordinate system, <strong>xy</strong> is set to a "rational" result and <code>cs_CNVRT_RNG</code> is returned.</p>
<h3 id="csmodpci-inverse-conversion">CSmodpcI Inverse conversion</h3>
<pre><code class="c">int CSmodpcI (Const struct cs_Modpc_ *modpc, double ll[2], Const double xy[2]);
</code></pre>

<p>Given a properly initialized <code>cs_Modpc_</code> structure via the <strong>modpc</strong> argument, <code>CSmodpcI</code> will convert the X and Y coordinates given in the <strong>xy</strong> array to latitude and longitude and return the result in the <strong>ll</strong> array. <code>CSmodpcI</code> normally returns <code>cs_CNVRT_NRML</code>. It will return <code>cs_CNVRT_RNG</code> if the xy value is not within the domain of the coordinate system, or <code>cs_CNVRT_INDF</code> if the result is indefinite (e.g. longitude is not defined at the poles).</p>
<p>In both cases above, the <strong>xy</strong> and <strong>ll</strong> arrays may be the same array. The X coordinate and the longitude are carried in the first element in these arrays, the Y coordinate and the latitude in the second element. The latitude and longitude values are in degrees where negative values are used to represent west longitude and south latitude.</p>
<h3 id="csmodpck-grid-scale-k-along-parallel">CSmodpcK grid scale (K), along parallel</h3>
<pre><code class="c">double CSmodpcK ( Const struct cs_Modpc_ *modpc, Const double ll[2]);
</code></pre>

<p><code>CSmodpcK</code> returns the grid scale factor, as measured along a parallel, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. (The use of the <strong>ll</strong> array is the same as described above.) At the current time, formulas that analytically produce the grid scale factor for this projection elude us. Thus, the grid scale factor is determined using the <code>CS_llazdd</code> function.</p>
<h3 id="csmodpch-grid-scale-h-along-meridian">CSmodpcH grid scale (H), along meridian</h3>
<pre><code class="c">double CSmodpcH ( Const struct cs_Modpc_ *modpc, Const double ll[2]);
</code></pre>

<p><code>CSmodpcH</code> returns the grid scale factor, as measured along a meridian, of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. At the current time, formulas that analytically produce the grid scale factor for this projection elude us. Thus, the grid scale factor is determined using the <code>CS_llazdd</code> function.</p>
<h3 id="csmodpcc-convergence-angle">CSmodpcC Convergence angle</h3>
<pre><code class="c">double CSmodpcC (Const struct cs_Modpc_ *modpc, Const double ll[2]);
</code></pre>

<p><code>CSmodpcC</code> returns the convergence angle of the coordinate system at the specific geodetic location defined by the latitude and longitude provided in the <strong>ll</strong> array. At the current time, formulas that analytically produce the convergence angle for this projection elude us. Thus, the grid scale factor is determined using the <code>CS_llazdd</code> function.</p>
<h3 id="csmodpcb-basic-calculations">CSmodpcB Basic calculations</h3>
<pre><code class="c">double CSmodpcB (Const struct cs_Modpc_ *modpc, Const double ll[2], double xy[2], double *their_yc);
</code></pre>

<p>Inverse calculations for this projection are performed using an iterative algorithm calling the forward function. <code>CSmodpcB</code> converts geographic coordinates to cartesian coordinates in a form that can be used by both <code>CSmodpcF</code> and <code>CSmodpcI</code>; thus eliminating duplicate code in these modules. The <strong>their_yc</strong> argument provides for the return to the calling function of an additional intermediary result that is required for the inverse calculation.</p>
<h3 id="csmodpcq-definition-quality-check">CSmodpcQ definition Quality check</h3>
<pre><code class="c">int CSmodpcQ ( Const struct cs_Csdef_ *csdef , unsigned short prj_code, int *err_list [], int list_sz);
</code></pre>

<p><code>CSmodpcQ</code> determines if the coordinate system definition provided by the <strong>csdef</strong> argument is consistent with the requirements of the Modified Polyconic Projection. <code>CS_cschk</code> examines those definition components that are common to all coordinates systems (datum or ellipsoid reference, map scale, and units) and, therefore, <code>CSmodpcQ</code> only examines those components specific to the Modified Polyconic Projection. <code>CSmodpcQ</code> returns in <strong>err_list</strong> an integer code value for each error condition detected, being careful not to exceed the size of <strong>err_list</strong> as indicated by the <strong>list_sz</strong> argument. The number of errors detected, regardless of the size of <strong>err_list</strong>, is always returned. Refer to <code>CSerpt</code> for a description of the various error codes and their meaning. <code>CSmodpcQ</code> may be called with the <strong>NULL</strong> pointer and/or a zero for the <strong>err_list</strong> and <strong>list_sz</strong> arguments respectively.</p>
<h3 id="csmodpcl-latitudelongitude-check">CSmodpcL Latitude/longitude check</h3>
<pre><code class="c">int CSmodpcL ( Const struct cs_Modpc_ *modpc, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSmodpcL</code> determines if the geographic coordinates, great circles, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>modpc</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a great circle (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSmodpcsL</code>'s return value will apply to all coordinates, coordinates on the great circles, and all coordinates within the regions thus defined. <code>CSmodpcL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject geographic coordinates are outside of the mathematical domain of the coordinate system.</p>
<h3 id="csmodpcx-xy-coordinate-check">CSmodpcX Xy coordinate check</h3>
<pre><code class="c">int CSmodpcX (Const struct cs_Modpc_ *modpc, int cnt, Const double pnts[][3]);
</code></pre>

<p><code>CSmodpcX</code> determines if the cartesian coordinates, lines, and/or regions defined by the coordinate list provided by the <strong>pnts</strong> and <strong>cnt</strong> arguments are within the mathematical domain of the coordinate system provided by the <strong>modpc</strong> argument. The <strong>pnts</strong> and <strong>cnt</strong> arguments can define a single coordinate (<strong>cnt</strong> == 1), a line (<strong>cnt</strong> == 2), or a closed region (<strong>cnt</strong> &gt; 3). <code>CSmodpcsX</code>'s return value will apply to all coordinates, coordinates on the lines, and all coordinates within the regions thus defined. <code>CSmodpcL</code> returns <code>cs_CNVRT_OK</code> if all subject coordinates are within the mathematical domain of the coordinate system. <code>cs_CNVRT_DOMN</code> is returned if one or more of the subject coordinates is outside of the mathematical domain of the coordinate system.</p>
<h3 id="csmodpcs-setup">CSmodpcS Setup</h3>
<pre><code class="c">void CSmodpcS (struct cs_Csprm_ *csprm);
</code></pre>

<p>The <code>CSmodpcS</code> function performs all calculations that need only be performed once, given the definition of a specific coordinate system. That is, once the standard meridians, the standard parallels, and other projection parameters are known, there are many calculations that need only be performed once. <code>CSmodpcS</code> performs these calculations and saves the results in the <code>cs_Csprm_</code> structure provided by its argument, <strong>csprm</strong>. Thus, the single argument provided to <code>CSmodpcS</code> serves as the source for input and the repository for the results as described below.</p>
<h3 id="coordinate-system-definition_20">Coordinate System Definition</h3>
<p>The definition of the coordinate system is extracted from the <strong>csdef</strong> element of the <code>cs_Csprm_</code> structure. Usually, this is obtained from the Coordinate System Dictionary by the <code>CS_csdef</code> function; but can be provided by the application at run time. The specific elements of the <code>cs_Csdef_</code> structure that must be initialized for the Modified Polyconic projection are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>prj_prm1</td>
<td>Longitude, in degrees, of the central meridian.</td>
</tr>
<tr>
<td>prj_prm2</td>
<td>Longitude, in degrees, of the Eastern meridian. The Western meridian is assumed to be west of the Central Meridian by the same amount that the Eastern Meridian is east of the Central Meridian. The Eastern meridian must be east of the central meridian, and not more than 15 degrees of longitude from the central meridian.</td>
</tr>
<tr>
<td>prj_prm3</td>
<td>Latitude, in degrees, of the Northern Standard Parallel.</td>
</tr>
<tr>
<td>prj_prm4</td>
<td>Latitude, in degrees, of the Southern Standard Parallel.</td>
</tr>
<tr>
<td>scale</td>
<td>The scale of the coordinate system. This one factor must include the conversion from meters to coordinate system units and the mapping scale that is to be applied.</td>
</tr>
<tr>
<td>x_off</td>
<td>The false easting to be applied to all X coordinates, usually selected to cause all X coordinates within the coordinate system to be positive values of reasonable size.</td>
</tr>
<tr>
<td>y_off</td>
<td>The false northing to be applied to all Y coordinates.</td>
</tr>
<tr>
<td>quad</td>
<td>An integer that indicates the cartesian quadrant of the coordinate system, 1 thru 4. A negative value indicates that the axes are to be swapped after the coordinates have been placed in the indicated quadrant.</td>
</tr>
</tbody>
</table>
<p>Neither standard parallel may be a pole, nor can the two standard parallels be the same as is supported in other projections. In addition, the Northern Standard Parallel must be the northernmost of the two standard parallels. Finally, the two standard parallels must be within 15 degrees of each other. Note that the projection was designed for maps whose extents are 6 degrees of longitude and 4 degrees of latitude.</p>
<h3 id="datum-definition_19">Datum Definition</h3>
<p>The values of equatorial radius and eccentricity are extracted from the datum element of the <code>cs_Csprm_</code> structure. These are normally obtained from the Ellipsoid Dictionary by the <code>CS_dtloc</code> function, but may be supplied by the application at run time. Specifically, the required elements are:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_rad</td>
<td>The equatorial radius of the earth in meters.</td>
</tr>
<tr>
<td>eccent</td>
<td>This value represents the eccentricity of the ellipsoid.</td>
</tr>
<tr>
<td>to84_via</td>
<td>An integer code that specifies the technique that is to be used to convert geographic coordinates based on this datum to WGS84.</td>
</tr>
</tbody>
</table>
<h3 id="cs_modpc_-structure">cs_Modpc_ Structure</h3>
<p>The results of the one-time calculations are recorded in the <strong>modpc</strong> element of the <code>prj_prms</code> union of the <code>cs_Csprm_</code> structure. It is a pointer to this initialized structure that the <code>CSmodpcF</code>, <code>CSmodpcI</code>, <code>CSmodpcK</code>, <code>CSmodpcH</code>, <code>CSmodpcC</code>, and <code>CSmodpcB</code> functions require as their first argument.</p>
<h3 id="bugs_1">BUGS</h3>
<p>As is true with all other projections in CS-MAP, values submitted for conversion are not checked for validity before conversion for performance reasons. In every other case, this does not appear to be a problem. However, experience has show that values which are more than 50% outside the area covered by the projection parameters can produce errors which get reported through matherr. Checking of input values does need to be added to the functions of this projection.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '../..';</script>
        <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
        <script src="../../js/base.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
